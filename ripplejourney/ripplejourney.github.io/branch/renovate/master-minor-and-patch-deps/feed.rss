<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>代码</title>
        <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps</link>
        <description>天道酬勤，恒以致遠（大前端相关技术分享）</description>
        <lastBuildDate>Wed, 29 Oct 2025 09:45:25 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>zh-cn</language>
        <image>
            <title>代码</title>
            <url>/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/assert/sitelogo.png</url>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps</link>
        </image>
        <copyright>代码 2006 - 2025</copyright>
        <item>
            <title><![CDATA[Cloud Native]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/cloud/devops/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/cloud/devops/</guid>
            <pubDate>Wed, 29 Oct 2025 09:37:04 GMT</pubDate>
            <description><![CDATA[cloud native 相关
 目录
* wsl中安装docker 1panel k8s
* zsh和oh-my-zsh美化]]></description>
            <content:encoded><![CDATA[<h1 id="cloud-native" tabindex="-1">Cloud Native <a class="header-anchor" href="#cloud-native" aria-label="Permalink to “Cloud Native”">&#8203;</a></h1>
<p>cloud native 相关</p>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./install_docker_k8s_1panel_in_WSL.html">wsl中安装docker 1panel k8s</a></li>
<li><a href="./zsh和oh-my-zsh美化.html">zsh和oh-my-zsh美化</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[zsh和oh-my-zsh美化]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/cloud/devops/zsh和oh-my-zsh美化.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/cloud/devops/zsh和oh-my-zsh美化.html</guid>
            <pubDate>Tue, 28 Oct 2025 20:00:00 GMT</pubDate>
            <description><![CDATA[查看当前环境的 shell
```bash
echo $SHELL
```
 查看当前系统有那些 shell
```bash
cat /etc/shells
```
 安装 zsh
```bash
s]]></description>
            <content:encoded><![CDATA[<h2 id="准备" tabindex="-1">准备 <a class="header-anchor" href="#准备" aria-label="Permalink to “准备”">&#8203;</a></h2>
<blockquote>
<p>安装wsl以及Ubuntu请参考 <a href="./install_docker_k8s_1panel_in_WSL.html">wsl中安装docker 1panel k8s</a></p>
</blockquote>
<h3 id="查看当前环境的-shell" tabindex="-1">查看当前环境的 shell <a class="header-anchor" href="#查看当前环境的-shell" aria-label="Permalink to “查看当前环境的 shell”">&#8203;</a></h3>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::klbmsvhjzgqqb4ntm5ljq::--><code>echo $SHELL</code></pre>
</div><h3 id="查看当前系统有那些-shell" tabindex="-1">查看当前系统有那些 shell <a class="header-anchor" href="#查看当前系统有那些-shell" aria-label="Permalink to “查看当前系统有那些 shell”">&#8203;</a></h3>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::jtl3slz5b2dhwdqkv406w::--><code>cat /etc/shells</code></pre>
</div><h2 id="安装-zsh" tabindex="-1">安装 zsh <a class="header-anchor" href="#安装-zsh" aria-label="Permalink to “安装 zsh”">&#8203;</a></h2>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::8mzsdi7l27ik3k288q80v::--><code>sudo apt install zsh</code></pre>
</div><h2 id="将-zsh-设置为默认的-shell" tabindex="-1">将 zsh 设置为默认的 shell <a class="header-anchor" href="#将-zsh-设置为默认的-shell" aria-label="Permalink to “将 zsh 设置为默认的 shell”">&#8203;</a></h2>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::wg8bi43wvrrvg5s1yrijc::--><code>chsh -s /bin/zsh</code></pre>
</div><h2 id="安装-oh-my-zsh" tabindex="-1">安装 Oh My Zsh <a class="header-anchor" href="#安装-oh-my-zsh" aria-label="Permalink to “安装 Oh My Zsh”">&#8203;</a></h2>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::vbrfv2ixccsf0rxsffi4m::--><code>git clone https://github.com/ohmyzsh/ohmyzsh.git ~/.oh-my-zsh</code></pre>
</div><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::8ztkkm7ehoyv99r2ok8hfo::--><code>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code></pre>
</div><h2 id="安装-powerlevel10k" tabindex="-1">安装 Powerlevel10k <a class="header-anchor" href="#安装-powerlevel10k" aria-label="Permalink to “安装 Powerlevel10k”">&#8203;</a></h2>
<h3 id="克隆仓库" tabindex="-1">克隆仓库 <a class="header-anchor" href="#克隆仓库" aria-label="Permalink to “克隆仓库”">&#8203;</a></h3>
<blockquote>
<p>GitHub</p>
</blockquote>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::qupkcbckdnc1l4tt2vsce::--><code>git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k</code></pre>
</div><blockquote>
<p>Gitee</p>
</blockquote>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::9lannz7d5t4h1oy4tzsafa::--><code>git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k</code></pre>
</div><h3 id="设置主题" tabindex="-1">设置主题 <a class="header-anchor" href="#设置主题" aria-label="Permalink to “设置主题”">&#8203;</a></h3>
<p>在 <code>~/.zshrc</code> 中添加</p>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::h5dj3890cmpc497yeteu6v::--><code>ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;</code></pre>
</div><p>使配置生效。</p>
<div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre><!--::markdown-it-async::f0wr47u9aqguc5pf83f958::--><code>source ~/.zshrc</code></pre>
</div><h4 id="设置字体为-meslolgs-nf" tabindex="-1">设置字体为 MesloLGS NF <a class="header-anchor" href="#设置字体为-meslolgs-nf" aria-label="Permalink to “设置字体为 MesloLGS NF”">&#8203;</a></h4>
<blockquote>
<p><a href="https://github.com/romkatv/powerlevel10k#manual-font-installation" target="_blank" rel="noreferrer">https://github.com/romkatv/powerlevel10k#manual-font-installation</a></p>
</blockquote>
<h4 id="自定义配置" tabindex="-1">自定义配置 <a class="header-anchor" href="#自定义配置" aria-label="Permalink to “自定义配置”">&#8203;</a></h4>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::ssznoqpz0djioo56ptk49::--><code>p10k configure</code></pre>
</div><h2 id="安装一些-zsh-常用插件" tabindex="-1">安装一些 zsh 常用插件 <a class="header-anchor" href="#安装一些-zsh-常用插件" aria-label="Permalink to “安装一些 zsh 常用插件”">&#8203;</a></h2>
<blockquote>
<p>安装插件后要使用 <code>source .zshrc</code> 使配置生效</p>
</blockquote>
<ul>
<li>
<p>git</p>
<blockquote>
<p>显示 git 的一些功能，默认已经安装</p>
</blockquote>
<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre><!--::markdown-it-async::ee3f5eypizwkxm3gykr7i::--><code>plugins=(git)</code></pre>
</div></li>
<li>
<p>z</p>
<blockquote>
<p>跳转目录，直接在 plugins 里面添加 z</p>
</blockquote>
<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre><!--::markdown-it-async::19le1jheif9f6ozb65eqrc::--><code>plugins=(
        git
        z)</code></pre>
</div></li>
<li>
<p>sudo</p>
<blockquote>
<p>偶尔输入某个命令，提示没有权限，需要加sudo，这个时候按两下ESC，就会在命令行头部加上 sudo 默认已经安装</p>
</blockquote>
<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre><!--::markdown-it-async::mmbth83zijtwfl9zk3eb::--><code>plugins=(
        git
        sudo
        z)</code></pre>
</div></li>
<li>
<p>zsh-autosuggestions</p>
<blockquote>
<p>会记录你之前输入过的所有命令，并且自动匹配你可能想要输入命令，然后按 Tab 补全</p>
</blockquote>
<p><a href="https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md#oh-my-zsh" target="_blank" rel="noreferrer">https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md#oh-my-zsh</a></p>
<p>克隆仓库</p>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::5w3vx0wyp28olnn96nlpbo::--><code>git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions</code></pre>
</div><p>添加配置</p>
<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre><!--::markdown-it-async::teq21hcm0193k0luvk1egr::--><code>plugins=(
        git
        sudo
        z
        zsh-autosuggestions)</code></pre>
</div></li>
<li>
<p>zsh-syntax-highlighting</p>
<blockquote>
<p>直接在输入过程中就会提示你，当前命令是否正确，错误红色，正确绿色</p>
</blockquote>
<p><a href="https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md#oh-my-zsh" target="_blank" rel="noreferrer">https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md#oh-my-zsh</a></p>
<p>克隆仓库</p>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::i60tglboqogqtzgfrehu2p::--><code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting</code></pre>
</div><p>添加配置</p>
<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre><!--::markdown-it-async::f6cjh89si3p9mtegrggsm::--><code>plugins=(
        git
        sudo
        z
        zsh-autosuggestions
        zsh-syntax-highlighting)</code></pre>
</div></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[zsh和oh-my-zsh美化]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/cloud/wsl/zsh和oh-my-zsh美化.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/cloud/wsl/zsh和oh-my-zsh美化.html</guid>
            <pubDate>Tue, 28 Oct 2025 20:00:00 GMT</pubDate>
            <description><![CDATA[- window 11
- 开启`适用与 Linx 的 Windows 子系统`
- 到微软商店下载 `Ubuntu` 系统
- 这里我使用的是 `WSL1`, `wsl --set-default-]]></description>
            <content:encoded><![CDATA[<h2 id="准备" tabindex="-1">准备 <a class="header-anchor" href="#准备" aria-label="Permalink to “准备”">&#8203;</a></h2>
<ul>
<li>window 11</li>
<li>开启<code>适用与 Linx 的 Windows 子系统</code></li>
<li>到微软商店下载 <code>Ubuntu</code> 系统</li>
<li>这里我使用的是 <code>WSL1</code>, <code>wsl --set-default-version &lt;Version&gt;</code></li>
</ul>
<h3 id="查看当前环境的-shell" tabindex="-1">查看当前环境的 shell <a class="header-anchor" href="#查看当前环境的-shell" aria-label="Permalink to “查看当前环境的 shell”">&#8203;</a></h3>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::audg00zm99e6u8m9h1wys::--><code>echo $SHELL</code></pre>
</div><h3 id="查看当前系统有那些-shell" tabindex="-1">查看当前系统有那些 shell <a class="header-anchor" href="#查看当前系统有那些-shell" aria-label="Permalink to “查看当前系统有那些 shell”">&#8203;</a></h3>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::zrf8mqrvbzhfozw7kp15a::--><code>cat /etc/shells</code></pre>
</div><h2 id="安装-zsh" tabindex="-1">安装 zsh <a class="header-anchor" href="#安装-zsh" aria-label="Permalink to “安装 zsh”">&#8203;</a></h2>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::q09ktbndiedji3sjm5ga0a::--><code>sudo apt install zsh</code></pre>
</div><h2 id="将-zsh-设置为默认的-shell" tabindex="-1">将 zsh 设置为默认的 shell <a class="header-anchor" href="#将-zsh-设置为默认的-shell" aria-label="Permalink to “将 zsh 设置为默认的 shell”">&#8203;</a></h2>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::ihqqh268dm2ewkulwlp7x::--><code>chsh -s /bin/zsh</code></pre>
</div><h2 id="安装-oh-my-zsh" tabindex="-1">安装 Oh My Zsh <a class="header-anchor" href="#安装-oh-my-zsh" aria-label="Permalink to “安装 Oh My Zsh”">&#8203;</a></h2>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::sg265pdj2zo861fgj3szf::--><code>git clone https://github.com/ohmyzsh/ohmyzsh.git ~/.oh-my-zsh</code></pre>
</div><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::wagl3rm1omkbtdklx99ggm::--><code>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code></pre>
</div><h2 id="安装-powerlevel10k" tabindex="-1">安装 Powerlevel10k <a class="header-anchor" href="#安装-powerlevel10k" aria-label="Permalink to “安装 Powerlevel10k”">&#8203;</a></h2>
<h3 id="克隆仓库" tabindex="-1">克隆仓库 <a class="header-anchor" href="#克隆仓库" aria-label="Permalink to “克隆仓库”">&#8203;</a></h3>
<blockquote>
<p>GitHub</p>
</blockquote>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::k48bvmile3r8dreo2fbj9n::--><code>git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k</code></pre>
</div><blockquote>
<p>Gitee</p>
</blockquote>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::f5ho4tkxqzpdtwrg52a35b::--><code>git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k</code></pre>
</div><h3 id="设置主题" tabindex="-1">设置主题 <a class="header-anchor" href="#设置主题" aria-label="Permalink to “设置主题”">&#8203;</a></h3>
<p>在 <code>~/.zshrc</code> 中添加</p>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::3wedftwx1cpaeu8r6fjf0m::--><code>ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;</code></pre>
</div><p>使配置生效。</p>
<div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre><!--::markdown-it-async::utnhx353zka252xe8g5zab::--><code>source ~/.zshrc</code></pre>
</div><h4 id="设置字体为-meslolgs-nf" tabindex="-1">设置字体为 MesloLGS NF <a class="header-anchor" href="#设置字体为-meslolgs-nf" aria-label="Permalink to “设置字体为 MesloLGS NF”">&#8203;</a></h4>
<blockquote>
<p><a href="https://github.com/romkatv/powerlevel10k#manual-font-installation" target="_blank" rel="noreferrer">https://github.com/romkatv/powerlevel10k#manual-font-installation</a></p>
</blockquote>
<h4 id="自定义配置" tabindex="-1">自定义配置 <a class="header-anchor" href="#自定义配置" aria-label="Permalink to “自定义配置”">&#8203;</a></h4>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::rc0i6fla85fwf69sideiv::--><code>p10k configure</code></pre>
</div><h2 id="安装一些-zsh-常用插件" tabindex="-1">安装一些 zsh 常用插件 <a class="header-anchor" href="#安装一些-zsh-常用插件" aria-label="Permalink to “安装一些 zsh 常用插件”">&#8203;</a></h2>
<blockquote>
<p>安装插件后要使用 <code>source .zshrc</code> 使配置生效</p>
</blockquote>
<ul>
<li>
<p>git</p>
<blockquote>
<p>显示 git 的一些功能，默认已经安装</p>
</blockquote>
<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre><!--::markdown-it-async::3geqzjs0t7cqhvzoygny::--><code>plugins=(git)</code></pre>
</div></li>
<li>
<p>z</p>
<blockquote>
<p>跳转目录，直接在 plugins 里面添加 z</p>
</blockquote>
<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre><!--::markdown-it-async::b5d5o68pfd6weurn332ox::--><code>plugins=(
        git
        z)</code></pre>
</div></li>
<li>
<p>sudo</p>
<blockquote>
<p>偶尔输入某个命令，提示没有权限，需要加sudo，这个时候按两下ESC，就会在命令行头部加上 sudo 默认已经安装</p>
</blockquote>
<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre><!--::markdown-it-async::sjikmkr9l3j839krnmot5f::--><code>plugins=(
        git
        sudo
        z)</code></pre>
</div></li>
<li>
<p>zsh-autosuggestions</p>
<blockquote>
<p>会记录你之前输入过的所有命令，并且自动匹配你可能想要输入命令，然后按 Tab 补全</p>
</blockquote>
<p><a href="https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md#oh-my-zsh" target="_blank" rel="noreferrer">https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md#oh-my-zsh</a></p>
<p>克隆仓库</p>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::6jhwt1oraswdpa9ca8qz5c::--><code>git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions</code></pre>
</div><p>添加配置</p>
<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre><!--::markdown-it-async::lch59t7jvwacpu5t66v65::--><code>plugins=(
        git
        sudo
        z
        zsh-autosuggestions)</code></pre>
</div></li>
<li>
<p>zsh-syntax-highlighting</p>
<blockquote>
<p>直接在输入过程中就会提示你，当前命令是否正确，错误红色，正确绿色</p>
</blockquote>
<p><a href="https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md#oh-my-zsh" target="_blank" rel="noreferrer">https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md#oh-my-zsh</a></p>
<p>克隆仓库</p>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::f189o6wl5raaaje3yg6c26::--><code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting</code></pre>
</div><p>添加配置</p>
<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre><!--::markdown-it-async::dfsyackxkkt9r1t078dvfo::--><code>plugins=(
        git
        sudo
        z
        zsh-autosuggestions
        zsh-syntax-highlighting)</code></pre>
</div></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[wsl中安装docker 1panel k8s]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/cloud/devops/install_docker_k8s_1panel_in_WSL.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/cloud/devops/install_docker_k8s_1panel_in_WSL.html</guid>
            <pubDate>Mon, 27 Oct 2025 18:00:00 GMT</pubDate>
            <description><![CDATA[设置wsl的系统配置
```bash
 设置wsl的系统配置
notepad $env:UserProfile\.wslconfig
 如果wsl正在运行，需要重启wsl
wsl --shutdown]]></description>
            <content:encoded><![CDATA[<h1 id="wsl中安装docker-1panel-k8s" tabindex="-1">wsl中安装docker 1panel k8s <a class="header-anchor" href="#wsl中安装docker-1panel-k8s" aria-label="Permalink to “wsl中安装docker 1panel k8s”">&#8203;</a></h1>
<blockquote>
<p>仅再2025年当前时间点测试有效，后续相关配置可能变化，自行修改</p>
</blockquote>
<h2 id="设置wsl的系统配置" tabindex="-1">设置wsl的系统配置 <a class="header-anchor" href="#设置wsl的系统配置" aria-label="Permalink to “设置wsl的系统配置”">&#8203;</a></h2>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::9kjw8yfwhrr4gh9f8s2rtl::--><code># 设置wsl的系统配置
#
notepad $env:UserProfile\.wslconfig
# 如果wsl正在运行，需要重启wsl
wsl --shutdown
</code></pre>
</div><p>粘贴如下内容到notepad</p>
<div class="language-ini"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre><!--::markdown-it-async::bkxrnol9wrskrnvvgufwn::--><code>[wsl2]
firewall=false
dhcp=false
ipv6=true
networkingMode=Mirrored
swap=0 # 关闭swap

[experimental]
hostAddressLoopback=true</code></pre>
</div><h2 id="安装wsl并升级到最新版" tabindex="-1">安装wsl并升级到最新版 <a class="header-anchor" href="#安装wsl并升级到最新版" aria-label="Permalink to “安装wsl并升级到最新版”">&#8203;</a></h2>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::l1ytyaqe89kwyhr2l80rrs::--><code>#Win10或者Win11升级到最新版本即可。 启用Windows 子系统功能，使用管理员权限打开一个 PowerShell 窗口，输入以下命令：
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
#还需要再启用虚拟机平台功能，在 PowerShell 中输入以下命令，重启系统：
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart

#或者安装wsl现在可以直接使用wsl命令安装（如果需要）
# wsl --install --no-distribution

#升级wsl 2（如果需要）
# wsl.exe --update --pre-release

#重启后，在 PowerShell 中输入以下命令，将 WSL 默认版本改为 WSL2:
wsl --set-default-version 2
#接下来安装Ubuntu，建议安装24.04版本
wsl --install Ubuntu-24.04

#若要设置与命令一起使用 wsl 的默认 Linux 分发版，请输入：
wsl.exe --set-default Ubuntu-24.04</code></pre>
</div><p>运行进入ubuntu</p>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::4rjvfoyxcfka488poktiu::--><code># 运行进入ubuntu
wsl -d Ubuntu-24.04

# 更改ubuntu更新源
cp /etc/apt/sources.list /etc/apt/sources.list.bak

echo &quot;deb http://mirrors.aliyun.com/ubuntu/ focal main restricted
deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted
deb http://mirrors.aliyun.com/ubuntu/ focal universe
deb http://mirrors.aliyun.com/ubuntu/ focal-updates universe
deb http://mirrors.aliyun.com/ubuntu/ focal multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-updates multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted
deb http://mirrors.aliyun.com/ubuntu/ focal-security universe
deb http://mirrors.aliyun.com/ubuntu/ focal-security multiverse&quot;&gt;/etc/apt/sources.list
# 更新系统
apt update &amp;&amp; apt upgrade -y
# 确认systemd是否启用,当前wsl 已经支持systemd，不需要安装
# systemctl status systemd-resolved</code></pre>
</div><h2 id="安装zsh和oh-my-zsh美化" tabindex="-1">安装zsh和oh-my-zsh美化 <a class="header-anchor" href="#安装zsh和oh-my-zsh美化" aria-label="Permalink to “安装zsh和oh-my-zsh美化”">&#8203;</a></h2>
<p><a href="./zsh和oh-my-zsh美化.html">安装zsh和oh-my-zsh美化</a></p>
<h2 id="安装docker-docker-compose" tabindex="-1">安装docker/docker-compose <a class="header-anchor" href="#安装docker-docker-compose" aria-label="Permalink to “安装docker/docker-compose”">&#8203;</a></h2>
<p>因为wsl2已经完整使用了linux内核了，此种方式和先前在linux虚拟机安装docker类似，步骤如下：</p>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::qjb86dryeo9iogjgarblx::--><code>curl -fsSL https://get.docker.com -o get-docker.sh
# 若无法下载，可以使用阿里云镜像
#curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun

sudo sh get-docker.sh
sudo service docker start

#开机启动
systemctl enable docker
# #禁止开机启动
# systemctl disable docker

# # 检查dockerd进程启动
# service docker status
# ps aux|grep docker
# # 检查拉取镜像等正常
# docker pull busybox
# docker images</code></pre>
</div><blockquote>
<p>Docker 也专门开发了可以使用 WSL2 中的 Docker 守护进程的桌面管理程序, 打开 Docker Desktop WSL2 backend 页面，下载最新的 Docker Desktop for Windows 程序 ，建议下载stable版本。下载地址：<a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noreferrer">https://www.docker.com/products/docker-desktop</a></p>
</blockquote>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::cc033jcuwfbtjph1we2sz::--><code># 安装docker-compose
DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
mkdir -p $DOCKER_CONFIG/cli-plugins
curl -SL https://github.com/docker/compose/releases/download/v2.20.2/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose
#Apply executable permissions to the binary:
chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose
#Test the installation.
docker compose version
</code></pre>
</div><h2 id="卸载-docker" tabindex="-1">卸载 docker <a class="header-anchor" href="#卸载-docker" aria-label="Permalink to “卸载 docker”">&#8203;</a></h2>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::c92r3jmf97gikevsppgf5::--><code># 卸载docker
docker container stop $(docker container ls -aq)
docker system prune -a --volumes
# #或者可以使用apt像卸载其他软件包一样来卸载 Docker：
# sudo apt purge docker-ce
# sudo apt autoremove</code></pre>
</div><h2 id="修改docker数据存储路径-非必要不设置" tabindex="-1">修改docker数据存储路径(非必要不设置) <a class="header-anchor" href="#修改docker数据存储路径-非必要不设置" aria-label="Permalink to “修改docker数据存储路径(非必要不设置)”">&#8203;</a></h2>
<p>wsl ubuntu 默认安装在 c 盘，希望将 docker 的数据存储路径（默认为 /var/lib/docker ）修改到 d 盘。
添加 /etc/docker/daemon.json 文件，内容如下</p>
<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre><!--::markdown-it-async::2g7idkpcaoxkyvaegwzkx::--><code>{
  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;],
  &quot;data-root&quot;: &quot;/mnt/d/data/docker&quot;,
  &quot;log-driver&quot;: &quot;json-file&quot;,
  &quot;log-opts&quot;: { &quot;max-size&quot;: &quot;100m&quot; }
}</code></pre>
</div><blockquote>
<p>docker 启动失败。wls ubuntu docker可能不支持将文件存储到 windows 磁盘。
将 /var/lib/docker 拷贝到 d 盘，报错，应该是 windows 磁盘不支持这些特殊文件(权限问题)。</p>
<div class="language-log"><button title="Copy Code" class="copy"></button><span class="lang">log</span><pre><!--::markdown-it-async::ig48kcvjj5lz700pe4m9a::--><code>hekai@thinkpad-l14:~$ sudo mv /var/lib/docker /mnt/d/data/docker
mv: cannot create special file &#039;/mnt/d/data/docker/volumes/backingFsBlockDev&#039;: Operation not supported
mv: cannot create special file &#039;/mnt/d/data/docker/volumes/docker-centos7-slurm-cluster_mysql/_data/mysql.sock&#039;: Operation not supported
mv: cannot create special file &#039;/mnt/d/data/docker/overlay2/3a272b47e6ae28aa475f3eea705bdb2bdeb83dc97c6feb91cc20e6c49bbc004b-init/work/work/#23d&#039;: Operation not supported
mv: cannot create special file &#039;/mnt/d/data/docker/overlay2/2a012b89cc6a205c6c8a148abae32a5e735695b52a54e2e3e792c2a5e88a00af-init/work/work/#23f&#039;: Operation not supported</code></pre>
</div></blockquote>
<p>接着编辑镜像文件(不存在这个文件的话，会自动创建)：</p>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::1ct7d7207uoy7brcfqcgz::--><code>cat &gt;&gt; /etc/docker/daemon.json&lt;&lt;EOF
{
    &quot;registry-mirrors&quot;: [
        &quot;https://a4zqywx0.mirror.aliyuncs.com&quot;,
        &quot;https://docker.1panel.live&quot;,
        &quot;https://registry-vpc.cn-qingdao.aliyuncs.com&quot;,
        &quot;https://f1361db2.m.daocloud.io&quot;,
        &quot;https://docker.mirrors.ustc.edu.cn&quot;,
        &quot;https://mirror.ccs.tencentyun.com&quot;,
        &quot;https://hub-mirror.c.163.com&quot;,
        &quot;https://docker.m.daocloud.io&quot;,
        &quot;https://docker.imgdb.de&quot;,
        &quot;https://docker-0.unsee.tech&quot;,
        &quot;https://docker.hlmirror.com&quot;,
        &quot;https://cjie.eu.org&quot;,
        &quot;https://f1361db2.m.daocloud.io&quot;,
        &quot;https://docker.mirrors.ustc.edu.cn&quot;,
        &quot;https://mirror.ccs.tencentyun.com&quot;,
        &quot;https://hub-mirror.c.163.com&quot;,
        &quot;https://a4zqywx0.mirror.aliyuncs.com&quot;,
        &quot;https://docker.m.daocloud.io&quot;,
        &quot;https://docker.imgdb.de&quot;,
        &quot;https://docker-0.unsee.tech&quot;,
        &quot;https://docker.hlmirror.com&quot;,
        &quot;https://cjie.eu.org&quot;,
        &quot;https://registry.cn-hangzhou.aliyuncs.com&quot;,
        &quot;https://reg-mirror.qiniu.com&quot;,
        &quot;https://docker.mirrors.ustc.edu.cn&quot;,
        &quot;https://hub-mirror.c.163.com&quot;
    ]
}
EOF
#重启Dokcer
service docker restart</code></pre>
</div><h2 id="安装1panel" tabindex="-1">安装1panel <a class="header-anchor" href="#安装1panel" aria-label="Permalink to “安装1panel”">&#8203;</a></h2>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::15cdtn0rrfxmtzcl0zus1::--><code># 安装1panel
bash -c &quot;$(curl -sSL https://resource.fit2cloud.com/1panel/package/v2/quick_start.sh)&quot;</code></pre>
</div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[wsl中安装docker 1panel k8s]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/cloud/wsl/install docker k8s 1panel in WSL.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/cloud/wsl/install docker k8s 1panel in WSL.html</guid>
            <pubDate>Mon, 27 Oct 2025 18:00:00 GMT</pubDate>
            <description><![CDATA[设置wsl的系统配置
```bash
 设置wsl的系统配置
notepad $env:UserProfile\.wslconfig
 如果wsl正在运行，需要重启wsl
wsl --shutdown]]></description>
            <content:encoded><![CDATA[<h1 id="wsl中安装docker-1panel-k8s" tabindex="-1">wsl中安装docker 1panel k8s <a class="header-anchor" href="#wsl中安装docker-1panel-k8s" aria-label="Permalink to “wsl中安装docker 1panel k8s”">&#8203;</a></h1>
<blockquote>
<p>仅再2025年当前时间点测试有效，后续相关配置可能变化，自行修改</p>
</blockquote>
<h2 id="设置wsl的系统配置" tabindex="-1">设置wsl的系统配置 <a class="header-anchor" href="#设置wsl的系统配置" aria-label="Permalink to “设置wsl的系统配置”">&#8203;</a></h2>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::fm91f88gvb7xwbnm4m8tc::--><code># 设置wsl的系统配置
#
notepad $env:UserProfile\.wslconfig
# 如果wsl正在运行，需要重启wsl
wsl --shutdown
</code></pre>
</div><p>粘贴如下内容到notepad</p>
<div class="language-ini"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre><!--::markdown-it-async::lvy0q1xusypa9099nqivm::--><code>[wsl2]
firewall=false
dhcp=false
ipv6=true
networkingMode=Mirrored
swap=0 # 关闭swap

[experimental]
hostAddressLoopback=true</code></pre>
</div><h2 id="安装wsl并升级到最新版" tabindex="-1">安装wsl并升级到最新版 <a class="header-anchor" href="#安装wsl并升级到最新版" aria-label="Permalink to “安装wsl并升级到最新版”">&#8203;</a></h2>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::y63bty2fr2w4k7woxgq2o::--><code>#Win10或者Win11升级到最新版本即可。 启用Windows 子系统功能，使用管理员权限打开一个 PowerShell 窗口，输入以下命令：
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
#还需要再启用虚拟机平台功能，在 PowerShell 中输入以下命令，重启系统：
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart

#或者安装wsl现在可以直接使用wsl命令安装（如果需要）
# wsl --install --no-distribution

#升级wsl 2（如果需要）
# wsl.exe --update --pre-release

#重启后，在 PowerShell 中输入以下命令，将 WSL 默认版本改为 WSL2:
wsl --set-default-version 2
#接下来安装Ubuntu，建议安装24.04版本
wsl --install Ubuntu-24.04

#若要设置与命令一起使用 wsl 的默认 Linux 分发版，请输入：
wsl.exe --set-default Ubuntu-24.04</code></pre>
</div><p>运行进入ubuntu</p>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::m6s0peo8tsot7ga2vf3oqn::--><code># 运行进入ubuntu
wsl -d Ubuntu-24.04

# 更改ubuntu更新源
cp /etc/apt/sources.list /etc/apt/sources.list.bak

echo &quot;deb http://mirrors.aliyun.com/ubuntu/ focal main restricted
deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted
deb http://mirrors.aliyun.com/ubuntu/ focal universe
deb http://mirrors.aliyun.com/ubuntu/ focal-updates universe
deb http://mirrors.aliyun.com/ubuntu/ focal multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-updates multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted
deb http://mirrors.aliyun.com/ubuntu/ focal-security universe
deb http://mirrors.aliyun.com/ubuntu/ focal-security multiverse&quot;&gt;/etc/apt/sources.list
# 更新系统
apt update &amp;&amp; apt upgrade -y
# 确认systemd是否启用,当前wsl 已经支持systemd，不需要安装
# systemctl status systemd-resolved</code></pre>
</div><h2 id="安装zsh和oh-my-zsh美化" tabindex="-1">安装zsh和oh-my-zsh美化 <a class="header-anchor" href="#安装zsh和oh-my-zsh美化" aria-label="Permalink to “安装zsh和oh-my-zsh美化”">&#8203;</a></h2>
<p><a href="./zsh和oh-my-zsh美化.html">安装zsh和oh-my-zsh美化</a></p>
<h2 id="安装docker-docker-compose" tabindex="-1">安装docker/docker-compose <a class="header-anchor" href="#安装docker-docker-compose" aria-label="Permalink to “安装docker/docker-compose”">&#8203;</a></h2>
<p>因为wsl2已经完整使用了linux内核了，此种方式和先前在linux虚拟机安装docker类似，步骤如下：</p>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::b7nt2e538pbu2tz2oaqgua::--><code>curl -fsSL https://get.docker.com -o get-docker.sh
# 若无法下载，可以使用阿里云镜像
#curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun

sudo sh get-docker.sh
sudo service docker start

#开机启动
systemctl enable docker
# #禁止开机启动
# systemctl disable docker

# # 检查dockerd进程启动
# service docker status
# ps aux|grep docker
# # 检查拉取镜像等正常
# docker pull busybox
# docker images</code></pre>
</div><blockquote>
<p>Docker 也专门开发了可以使用 WSL2 中的 Docker 守护进程的桌面管理程序, 打开 Docker Desktop WSL2 backend 页面，下载最新的 Docker Desktop for Windows 程序 ，建议下载stable版本。下载地址：<a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noreferrer">https://www.docker.com/products/docker-desktop</a></p>
</blockquote>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::1jhi0o7913ph33v90732pb::--><code># 安装docker-compose
DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
mkdir -p $DOCKER_CONFIG/cli-plugins
curl -SL https://github.com/docker/compose/releases/download/v2.20.2/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose
#Apply executable permissions to the binary:
chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose
#Test the installation.
docker compose version
</code></pre>
</div><h2 id="卸载-docker" tabindex="-1">卸载 docker <a class="header-anchor" href="#卸载-docker" aria-label="Permalink to “卸载 docker”">&#8203;</a></h2>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::ek630bsir2gzfxudajzdc::--><code># 卸载docker
docker container stop $(docker container ls -aq)
docker system prune -a --volumes
# #或者可以使用apt像卸载其他软件包一样来卸载 Docker：
# sudo apt purge docker-ce
# sudo apt autoremove</code></pre>
</div><h2 id="修改docker数据存储路径-非必要不设置" tabindex="-1">修改docker数据存储路径(非必要不设置) <a class="header-anchor" href="#修改docker数据存储路径-非必要不设置" aria-label="Permalink to “修改docker数据存储路径(非必要不设置)”">&#8203;</a></h2>
<p>wsl ubuntu 默认安装在 c 盘，希望将 docker 的数据存储路径（默认为 /var/lib/docker ）修改到 d 盘。
添加 /etc/docker/daemon.json 文件，内容如下</p>
<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre><!--::markdown-it-async::jdq2lmvubs1bs4u5leg0c::--><code>{
  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;],
  &quot;data-root&quot;: &quot;/mnt/d/data/docker&quot;,
  &quot;log-driver&quot;: &quot;json-file&quot;,
  &quot;log-opts&quot;: { &quot;max-size&quot;: &quot;100m&quot; }
}</code></pre>
</div><blockquote>
<p>docker 启动失败。wls ubuntu docker可能不支持将文件存储到 windows 磁盘。
将 /var/lib/docker 拷贝到 d 盘，报错，应该是 windows 磁盘不支持这些特殊文件(权限问题)。</p>
<div class="language-log"><button title="Copy Code" class="copy"></button><span class="lang">log</span><pre><!--::markdown-it-async::5sq98klkhmo9robj73cjla::--><code>hekai@thinkpad-l14:~$ sudo mv /var/lib/docker /mnt/d/data/docker
mv: cannot create special file &#039;/mnt/d/data/docker/volumes/backingFsBlockDev&#039;: Operation not supported
mv: cannot create special file &#039;/mnt/d/data/docker/volumes/docker-centos7-slurm-cluster_mysql/_data/mysql.sock&#039;: Operation not supported
mv: cannot create special file &#039;/mnt/d/data/docker/overlay2/3a272b47e6ae28aa475f3eea705bdb2bdeb83dc97c6feb91cc20e6c49bbc004b-init/work/work/#23d&#039;: Operation not supported
mv: cannot create special file &#039;/mnt/d/data/docker/overlay2/2a012b89cc6a205c6c8a148abae32a5e735695b52a54e2e3e792c2a5e88a00af-init/work/work/#23f&#039;: Operation not supported</code></pre>
</div></blockquote>
<p>接着编辑镜像文件(不存在这个文件的话，会自动创建)：</p>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::czs70cfq52whmoi0bmfsh8::--><code>cat &gt;&gt; /etc/docker/daemon.json&lt;&lt;EOF
{
    &quot;registry-mirrors&quot;: [
        &quot;https://a4zqywx0.mirror.aliyuncs.com&quot;,
        &quot;https://docker.1panel.live&quot;,
        &quot;https://registry-vpc.cn-qingdao.aliyuncs.com&quot;,
        &quot;https://f1361db2.m.daocloud.io&quot;,
        &quot;https://docker.mirrors.ustc.edu.cn&quot;,
        &quot;https://mirror.ccs.tencentyun.com&quot;,
        &quot;https://hub-mirror.c.163.com&quot;,
        &quot;https://docker.m.daocloud.io&quot;,
        &quot;https://docker.imgdb.de&quot;,
        &quot;https://docker-0.unsee.tech&quot;,
        &quot;https://docker.hlmirror.com&quot;,
        &quot;https://cjie.eu.org&quot;,
        &quot;https://f1361db2.m.daocloud.io&quot;,
        &quot;https://docker.mirrors.ustc.edu.cn&quot;,
        &quot;https://mirror.ccs.tencentyun.com&quot;,
        &quot;https://hub-mirror.c.163.com&quot;,
        &quot;https://a4zqywx0.mirror.aliyuncs.com&quot;,
        &quot;https://docker.m.daocloud.io&quot;,
        &quot;https://docker.imgdb.de&quot;,
        &quot;https://docker-0.unsee.tech&quot;,
        &quot;https://docker.hlmirror.com&quot;,
        &quot;https://cjie.eu.org&quot;,
        &quot;https://registry.cn-hangzhou.aliyuncs.com&quot;,
        &quot;https://reg-mirror.qiniu.com&quot;,
        &quot;https://docker.mirrors.ustc.edu.cn&quot;,
        &quot;https://hub-mirror.c.163.com&quot;
    ]
}
EOF
#重启Dokcer
service docker restart</code></pre>
</div><h2 id="安装1panel" tabindex="-1">安装1panel <a class="header-anchor" href="#安装1panel" aria-label="Permalink to “安装1panel”">&#8203;</a></h2>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::q15s6ydh3qrxny1khja348::--><code># 安装1panel
bash -c &quot;$(curl -sSL https://resource.fit2cloud.com/1panel/package/v2/quick_start.sh)&quot;</code></pre>
</div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[**PostgreSQL 容器启动失败：WSL 配置终极解决方案**]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/ai/dify/postgresql_wsl_solution.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/ai/dify/postgresql_wsl_solution.html</guid>
            <pubDate>Thu, 11 Sep 2025 16:00:00 GMT</pubDate>
            <description><![CDATA[PostgreSQL 容器启动失败：WSL 配置终极解决方案]]></description>
            <content:encoded><![CDATA[<h1 id="postgresql-容器启动失败-wsl-配置终极解决方案" tabindex="-1"><strong>PostgreSQL 容器启动失败：WSL 配置终极解决方案</strong> <a class="header-anchor" href="#postgresql-容器启动失败-wsl-配置终极解决方案" aria-label="Permalink to “PostgreSQL 容器启动失败：WSL 配置终极解决方案”">&#8203;</a></h1>
<h2 id="问题现象" tabindex="-1"><strong>问题现象</strong> <a class="header-anchor" href="#问题现象" aria-label="Permalink to “问题现象”">&#8203;</a></h2>
<p>在 Windows + WSL 环境下运行 dify\docker&gt; podman compose down &amp;&amp; podman compose up -d, 创建 PostgreSQL 容器时，出现以下错误：</p>
<div class="language-plaintext"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre><!--::markdown-it-async::f0xpzn8m40k42j2mklb5bb::--><code>initdb: error: could not change permissions of directory &quot;/var/lib/postgresql/data/pgdata&quot;: Operation not permitted
chmod: /var/lib/postgresql/data/pgdata: Operation not permitted</code></pre>
</div><hr>
<h2 id="根本原因" tabindex="-1"><strong>根本原因</strong> <a class="header-anchor" href="#根本原因" aria-label="Permalink to “根本原因”">&#8203;</a></h2>
<p>Windows 和 WSL 默认的文件系统挂载方式导致：</p>
<ol>
<li><strong>权限隔离</strong>：WSL 挂载的 Windows 目录（如 <code>/mnt/c/...</code>）默认禁止修改权限。</li>
<li><strong>用户冲突</strong>：容器内用户（如 <code>postgres</code>）无法操作挂载目录的权限。</li>
</ol>
<hr>
<h2 id="终极解决方案-调整-wsl-配置" tabindex="-1"><strong>终极解决方案：调整 WSL 配置</strong> <a class="header-anchor" href="#终极解决方案-调整-wsl-配置" aria-label="Permalink to “终极解决方案：调整 WSL 配置”">&#8203;</a></h2>
<h3 id="_1-修改-wsl-配置文件" tabindex="-1"><strong>1. 修改 WSL 配置文件</strong> <a class="header-anchor" href="#_1-修改-wsl-配置文件" aria-label="Permalink to “1. 修改 WSL 配置文件”">&#8203;</a></h3>
<p>在 WSL 中运行以下命令：</p>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::e9yi2zij5ptoyxn5kzjqt::--><code>sudo nano /etc/wsl.conf</code></pre>
</div><p>添加以下内容（如果文件不存在则新建）：</p>
<div class="language-ini"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre><!--::markdown-it-async::tntp2prb4nie9yj9vla3o::--><code>[automount]
options = &quot;metadata,umask=22,fmask=11&quot;</code></pre>
</div><p>保存后退出（<code>Ctrl+O</code> → <code>Enter</code> → <code>Ctrl+X</code>）。</p>
<h3 id="_2-重启-wsl" tabindex="-1"><strong>2. 重启 WSL</strong> <a class="header-anchor" href="#_2-重启-wsl" aria-label="Permalink to “2. 重启 WSL”">&#8203;</a></h3>
<p>在 Windows PowerShell 中运行：</p>
<div class="language-powershell"><button title="Copy Code" class="copy"></button><span class="lang">powershell</span><pre><!--::markdown-it-async::jrva07f8v9mtwkgkezqtb::--><code>wsl --shutdown</code></pre>
</div><p>重新启动 WSL 终端使配置生效。</p>
<h3 id="_3-验证配置" tabindex="-1"><strong>3. 验证配置</strong> <a class="header-anchor" href="#_3-验证配置" aria-label="Permalink to “3. 验证配置”">&#8203;</a></h3>
<p>在 WSL 中运行：</p>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::n75vaf7lc7gbomxa6jauj::--><code>cat /etc/wsl.conf</code></pre>
</div><p>确认输出包含上述配置。</p>
<hr>
<h2 id="辅助步骤-可选" tabindex="-1"><strong>辅助步骤（可选）</strong> <a class="header-anchor" href="#辅助步骤-可选" aria-label="Permalink to “辅助步骤（可选）”">&#8203;</a></h2>
<h3 id="_1-确保目录存在" tabindex="-1"><strong>1. 确保目录存在</strong> <a class="header-anchor" href="#_1-确保目录存在" aria-label="Permalink to “1. 确保目录存在”">&#8203;</a></h3>
<p>在 Windows 中创建目标目录：</p>
<div class="language-powershell"><button title="Copy Code" class="copy"></button><span class="lang">powershell</span><pre><!--::markdown-it-async::hx02crk2hu6v16cacmkve::--><code>mkdir -p C:\AppData\code\ai\dify\docker\volumes\db\data</code></pre>
</div><h3 id="_2-调整目录权限" tabindex="-1"><strong>2. 调整目录权限</strong> <a class="header-anchor" href="#_2-调整目录权限" aria-label="Permalink to “2. 调整目录权限”">&#8203;</a></h3>
<p>在 WSL 中运行：</p>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::378xbwzqe5kuutwqb8wehf::--><code>sudo chmod -R 755 /mnt/c/AppData/code/ai/dify/docker/volumes/db/data</code></pre>
</div><h3 id="_3-重新启动容器" tabindex="-1"><strong>3. 重新启动容器</strong> <a class="header-anchor" href="#_3-重新启动容器" aria-label="Permalink to “3. 重新启动容器”">&#8203;</a></h3>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::46t3lqbbsttfljrd30iahm::--><code>podman-compose down &amp;&amp; podman-compose up -d</code></pre>
</div><hr>
<h2 id="为什么这是最佳方案" tabindex="-1"><strong>为什么这是最佳方案？</strong> <a class="header-anchor" href="#为什么这是最佳方案" aria-label="Permalink to “为什么这是最佳方案？”">&#8203;</a></h2>
<ol>
<li><strong>一劳永逸</strong>：修改 WSL 配置后，所有容器挂载目录的权限问题自动解决。</li>
<li><strong>无需硬编码用户</strong>：避免在 <code>docker-compose.yml</code> 中强制指定 <code>user: &quot;1000:1000&quot;</code>。</li>
<li><strong>兼容性更好</strong>：支持所有需要权限操作的容器（如 MySQL、MongoDB 等）。</li>
</ol>
<hr>
<h2 id="验证方法" tabindex="-1"><strong>验证方法</strong> <a class="header-anchor" href="#验证方法" aria-label="Permalink to “验证方法”">&#8203;</a></h2>
<ol>
<li>
<p><strong>检查目录权限</strong>
在 WSL 中运行：</p>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::f5cg600wjvtnlvs83onm9c::--><code>ls -ld /mnt/c/AppData/code/ai/dify/docker/volumes/db/data</code></pre>
</div><p>正常输出示例：</p>
<div class="language-plaintext"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre><!--::markdown-it-async::4an3t4jhk9lfs3vkr2cyq6::--><code>drwxr-xr-x 1 user user 4096 Sep 11 10:00 /mnt/c/.../data</code></pre>
</div></li>
<li>
<p><strong>查看容器日志</strong></p>
<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::800c248z00p9uj28jqk07::--><code>podman logs &lt;container_id&gt;</code></pre>
</div><p>确认无权限错误。</p>
</li>
</ol>
<hr>
<h2 id="注意事项" tabindex="-1"><strong>注意事项</strong> <a class="header-anchor" href="#注意事项" aria-label="Permalink to “注意事项”">&#8203;</a></h2>
<ol>
<li><strong>WSL 版本</strong>：仅 WSL 2 支持此配置（通过 <code>wsl -l -v</code> 检查）。</li>
<li><strong>安全限制</strong>：<code>umask=22</code> 表示默认权限为 <code>755</code>（可根据需要调整）。</li>
</ol>
<hr>
<h2 id="总结" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">&#8203;</a></h2>
<p>通过调整 WSL 的 <code>automount</code> 配置，从根本上解决了容器挂载目录的权限问题。此方法简单、通用，是 Windows + WSL 环境下运行数据库容器的推荐方案。</p>
<hr>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[实现自动为 VitePress 网站添加 RSS 订阅的插件]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/vitepress-plugin-rss.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/vitepress-plugin-rss.html</guid>
            <pubDate>Sun, 02 Feb 2025 20:11:06 GMT</pubDate>
            <description><![CDATA[使用 VitePress 作为个人博客的站点越来越多，RSS支持也是博客上的一个功能点，方便读者订阅，本文将介绍如何通过Vite 插件为 VitePress 站点一键添加RSS支持]]></description>
            <content:encoded><![CDATA[<h1 id="实现自动为-vitepress-网站添加-rss-订阅的插件" tabindex="-1">实现自动为 VitePress 网站添加 RSS 订阅的插件 <a class="header-anchor" href="#实现自动为-vitepress-网站添加-rss-订阅的插件" aria-label="Permalink to “实现自动为 VitePress 网站添加 RSS 订阅的插件”">&#8203;</a></h1>
<p>省流：使用 <a href="https://www.npmjs.com/package/vitepress-plugin-rss" target="_blank" rel="noreferrer">vitepress-plugin-rss</a> 这个插件</p>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>在看许多个人博客站点的时候，右上角总会有个RSS订阅的标志</p>
<p><img src="./vitepress-plugin-rss/MTY5MjYyNTQwOTU1Mw==692625409553.png" alt="" loading="lazy"></p>
<p>恰好<a href="https://www.dmsrs.org/" target="_blank" rel="noreferrer">我的博客</a>也是基于 <a href="https://vitepress.dev/" target="_blank" rel="noreferrer">VitePress</a> 搭建的，就想看看能不能也实现这个功能呢？</p>
<p>动手前先搜了一下，先是看到了<a href="https://github.com/clark-cui/vitepress-blog-zaun" target="_blank" rel="noreferrer">vitepress-blog-zaun</a>上有这个RSS的实现支持，再搜了一下发现Vue的官方博客 <a href="https://github.com/vuejs/blog/tree/main" target="_blank" rel="noreferrer">vuejs/blog</a> 也是用的这样的实现</p>
<p>大概就是自定义 VitePress 的 <a href="https://vitepress.dev/reference/site-config#buildend" target="_blank" rel="noreferrer">buildEnd</a> 钩子，在里面实现逻辑获取 <code>md</code> 文件列表，然后通过 <a href="https://www.npmjs.com/package/feed" target="_blank" rel="noreferrer">feed</a> 生成 RSS 文件，<a href="https://github.com/vuejs/blog/blob/main/.vitepress/genFeed.ts" target="_blank" rel="noreferrer">整个逻辑就 50+ 行代码</a></p>
<p>由于我的博客还分离了独立的主题包 <a href="https://theme.sugarat.top/" target="_blank" rel="noreferrer">@sugarat/theme</a>，我想把这个功能加到我的主题包里，这样使用这个主题的就可以简单的配置一下就能使用了，当然也为了方便广大 VitePress 用户更加简便的使用，我将这段逻辑单独分离封装到了 <a href="https://www.npmjs.com/package/vitepress-plugin-rss" target="_blank" rel="noreferrer">vitepress-plugin-rss</a> 这个插件里。</p>
<p><strong>接下来我将会先介绍一下如何食用这个插件，再介绍它的核心实现原理</strong></p>
<h2 id="插件使用" tabindex="-1">插件使用 <a class="header-anchor" href="#插件使用" aria-label="Permalink to “插件使用”">&#8203;</a></h2>
<p>通过 <code>pnpm/npm/yarn</code> 安装插件</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::35fp8qj1fcb8l4pswt02om::--><code>pnpm add vitepress-plugin-rss</code></pre>
</div><p>在 <code>.vitepress/config.ts</code> 配置文件中添加配置使用</p>
<p>下面是最基础的使用配置</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::yuk06wxu1ak6rkdz6ety::--><code>import { RSSOptions, RssPlugin } from &#039;vitepress-plugin-rss&#039;
const baseUrl = &#039;https://www.dmsrs.org&#039;
const RSS: RSSOptions = {
  title: &#039;代码&#039;,
  baseUrl,
  copyright: &#039;Copyright (c) 2018-present, 代码&#039;,
}

export default defineConfig({
  vite: {
    // ↓↓↓↓↓
    plugins: [RssPlugin(RSS)]
    // ↑↑↑↑↑
  }
})</code></pre>
</div><p>然后运行 build 命令，你可以看到在<code>rendering pages...</code>后打印了生成 <code>feed.rss</code> 日志...</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::b2whbuwknx4fyzmteyetea::--><code>pnpm run build</code></pre>
</div><p><img src="./vitepress-plugin-rss/MTY5MjQ1NTAzMzcwMg==692455033702.png" alt="" loading="lazy"></p>
<p>同时会在导航栏的 socialLinks 中添加 rss 图标链接</p>
<p><img src="./vitepress-plugin-rss/MTY5MjQ1NTQ4MDYxMg==692455480612.png" alt="" loading="lazy"></p>
<p>使用是不是非常简单，只需要 10 行代码。</p>
<p>如果你对插件的实现原理感兴趣，请接着往下看 🎉 🎉 🎉。</p>
<h2 id="核心实现原理解析" tabindex="-1">核心实现原理解析 <a class="header-anchor" href="#核心实现原理解析" aria-label="Permalink to “核心实现原理解析”">&#8203;</a></h2>
<p>VitePress 的拓展在官方文档 <a href="https://vitepress.dev/guide/what-is-vitepress#use-cases" target="_blank" rel="noreferrer">Use Cases</a> 部分有提到</p>
<p><img src="./vitepress-plugin-rss/MTY5MjYyNzE4MDA4MA==692627180080.png" alt="" loading="lazy"></p>
<p>其是基于 Vite 的，因此可以使用 Vite 的插件机制来实现主题内容的拓展。</p>
<h3 id="buildend-修改" tabindex="-1">buildEnd 修改 <a class="header-anchor" href="#buildend-修改" aria-label="Permalink to “buildEnd 修改”">&#8203;</a></h3>
<p>从官方的demo种可以看到，RSS 的生成逻辑是放在 buildEnd 中的，因此咱们插件也需要实现间接修改 buildEnd 方法</p>
<p>这个非常的简单，利用 Vite 的插件提供的 <a href="https://vitejs.dev/guide/api-plugin.html#configresolved" target="_blank" rel="noreferrer">configResolved</a> 钩子就行</p>
<p>下面是简单的demo</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::qrkffu88yff6dgjdduxsnr::--><code>import { SiteConfig } from &#039;vitepress&#039;

let resolveConfig: any = null

function configResolved(config: any) {
  // 避免多次执行
  if (resolveConfig) {
    return
  }
  resolveConfig = config

  const VPConfig: SiteConfig = config.vitepress
  if (!VPConfig) {
    return
  }
  const selfBuildEnd = VPConfig.buildEnd
  // 自定义 buildEnd 方法，添加 rss 生成支持
  VPConfig.buildEnd = async (siteConfig: any) =&gt; {
    // 调用自己的
    await selfBuildEnd?.(siteConfig)
    console.log(&#039;buildEnd&#039;, &#039;生成 rss 文件&#039;)
  }
}</code></pre>
</div><p>通过<code>config.vitepress</code>即可拿到vitepress的配置，然后重新定义 <code>buildEnd</code> 方法即可</p>
<p>这里可以直接快速的验证一下</p>
<p><img src="./vitepress-plugin-rss/MTY5MjYyODA0OTEzMA==692628049130.png" alt="" loading="lazy"></p>
<p>运行后可以看到打印了 <code>buildEnd 生成 rss 文件</code>，说明我们的插件的修改已经生效了</p>
<p><img src="./vitepress-plugin-rss/MTY5MjYyODE0MzUyNw==692628143527.png" alt="" loading="lazy"></p>
<h3 id="icon-添加" tabindex="-1">icon 添加 <a class="header-anchor" href="#icon-添加" aria-label="Permalink to “icon 添加”">&#8203;</a></h3>
<p>这个也非常的简单，VitePress 在官方文档里有介绍 <a href="https://vitepress.dev/reference/default-theme-config#sociallinks" target="_blank" rel="noreferrer">socialLinks</a></p>
<p><img src="./vitepress-plugin-rss/MTY5MjYyODMxNTQyMA==692628315420.png" alt="" loading="lazy"></p>
<p>我们只需要在配置修改中添加一个 <code>socialLinks</code> 的配置即可</p>
<p>接着上述的demo，添加如下代码</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::8mebnj2a4uly63yv49ii3n::--><code>VPConfig.site.themeConfig.socialLinks = [
  {
    icon: {
      svg: &#039;svg icon&#039;
    },
    link: &#039;rss url&#039;
  },
  ...VPConfig.site.themeConfig.socialLinks
]</code></pre>
</div><p>svg的图标可以通过 <a href="https://www.xicons.org/#/zh-CN" target="_blank" rel="noreferrer">xicons</a> 这个网站查找</p>
<p>比如我这里找了一个 sun 的图标配上</p>
<p><img src="./vitepress-plugin-rss/MTY5MjYyODc2MjI2MQ==692628762261.png" alt="" loading="lazy"></p>
<p>启动博客后就能看见右上角这个小太阳了</p>
<p><img src="./vitepress-plugin-rss/MTY5MjYyODY2MDQ3OQ==692628660479.png" alt="" loading="lazy"></p>
<h3 id="md文件获取与解析" tabindex="-1">MD文件获取与解析 <a class="header-anchor" href="#md文件获取与解析" aria-label="Permalink to “MD文件获取与解析”">&#8203;</a></h3>
<p>这个是最核心的逻辑了，① 需要获取所有的 <code>md</code> 文件，② 解析里面的 frontmatter ③ 渲染HTML</p>
<p>这个在 <code>vuejs/blog</code> 中可以看到使用的是 VitePress 内置的 <a href="https://vitepress.dev/guide/data-loading#createcontentloader" target="_blank" rel="noreferrer">createContentLoader</a> 方法（里面包含了上述3部分逻辑）</p>
<p>这里把其核心实现拆出来，方便大家理解和更好的自定义（笔者在插件里也没直接使用 <code>createContentLoader</code> 这个方法）</p>
<p><strong>① 通过 fast-glob 获取所有的 md 文件</strong></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::j0m4ksa3f2egqvls4a73o::--><code>import glob from &#039;fast-glob&#039;

const files = glob.sync(`${srcDir}/**/*.md`, { ignore: [&#039;node_modules&#039;] })</code></pre>
</div><p>其中 <code>srcDir</code> 即文章所在的目录，可以通过如下方式获取到相对路径</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::dgk01ce2dnvsht99006f6a::--><code>// config 即 SiteConfig
const srcDir
    = config.srcDir.replace(config.root, &#039;&#039;).replace(/^\//, &#039;&#039;)
    || process.argv.slice(2)?.[1]
    || &#039;.&#039;</code></pre>
</div><p><strong>② 通过 gray-matter 解析 frontmatter</strong></p>
<p>这里<code>frontmatter</code>就是文章开头里两个<code>---</code>之间的内容</p>
<p>例如</p>
<div class="language-md"><button title="Copy Code" class="copy"></button><span class="lang">md</span><pre><!--::markdown-it-async::azp164upcbg7iwrj9tfmj5::--><code>---
title: 示例标题
description: 文章介绍
---</code></pre>
</div><p>利用 gray-matter 解析</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::p67vehforekbxt3tsnrhap::--><code>import fs from &#039;fs&#039;
import matter from &#039;gray-matter&#039;

for (const file of files) {
  const fileContent = fs.readFileSync(file, &#039;utf-8&#039;)
  const { data: frontmatter, excerpt } = matter(fileContent, {
    excerpt: true
  })
}</code></pre>
</div><p>其中 <code>excerpt</code> 即为文章的摘要信息(description)</p>
<p><strong>③ MD 渲染为 HTML</strong></p>
<p>这个使用 VitePress 提供的 <code>createMarkdownRenderer</code> 即可</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::0rd46cbrwamj265j436hamh::--><code>// 由于插件里最后构建成 CJS/ESM 两种格式，VitePress 最新的版本支持 ESM，因此需要动态引入
const { createMarkdownRenderer } = await import(&#039;vitepress&#039;)

const mdRender = await createMarkdownRenderer(
  config.srcDir,
  config.markdown,
  config.site.base,
  config.logger
)
for (const file of files) {
  const fileContent = fs.readFileSync(file, &#039;utf-8&#039;)
  // 生成html
  const html = mdRender.render(fileContent)
}</code></pre>
</div><h3 id="rss文件生成" tabindex="-1">RSS文件生成 <a class="header-anchor" href="#rss文件生成" aria-label="Permalink to “RSS文件生成”">&#8203;</a></h3>
<p>通过上面的 markdown 文件的解析，我们已经拿到了所有的文章信息，接下来就是通过 <a href="https://www.npmjs.com/package/feed" target="_blank" rel="noreferrer">feed</a> 这个库生成 RSS 文件了</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::5hbj2almpu92rimigkh83w::--><code>import { Feed } from &#039;feed&#039;
const feedOptions = {
  // ...
}
const feed = new Feed(feedOptions)

for (const file of files) {
  // 通过前面解析的信息，生成 feed item
  feed.addItem({
    title,
    id: link,
    link,
    description,
    content: html,
    author: [
      {
        name: author,
        ...authorInfo
      }
    ],
    image: frontmatter?.cover,
    date: new Date(date)
  })
}

const RSSFilename = &#039;feed.rss&#039;
const RSSFilepath = path.join(config.outDir, RSSFilename)

// 生成 rss 文件
writeFileSync(RSSFilepath, feed.rss2())</code></pre>
</div><h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>插件的完整源码见 <a href="https://github.com/ripplejourney/ripplejourney.github.io/tree/master/packages/vitepress-plugin-rss" target="_blank" rel="noreferrer">GitHub</a>，欢迎大家试用和反馈</p>
<h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to “参考”">&#8203;</a></h2>
<ul>
<li><a href="https://www.npmjs.com/package/feed" target="_blank" rel="noreferrer">jpmonette/feed</a></li>
<li><a href="https://github.com/vuejs/blog/tree/main" target="_blank" rel="noreferrer">vuejs/blog</a></li>
</ul>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/vitepress-plugin-rss/MTY5MjYyNTQwOTU1Mw==692625409553.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[github代码库管理]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/coding/github/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/coding/github/</guid>
            <pubDate>Sun, 26 Jan 2025 13:21:52 GMT</pubDate>
            <description><![CDATA[目录
* 大数相加&Git删除当前分支下的所有历史版本与log并同步至GitHub_git如何清除历史版本
* SourceTree SSH密钥缓存问题解决]]></description>
            <content:encoded><![CDATA[<h1 id="github代码库管理" tabindex="-1">github代码库管理 <a class="header-anchor" href="#github代码库管理" aria-label="Permalink to “github代码库管理”">&#8203;</a></h1>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./Git删除当前分支下的所有历史版本与log并同步至GitHub_git如何清除历史版本.html">大数相加&amp;Git删除当前分支下的所有历史版本与log并同步至GitHub_git如何清除历史版本</a></li>
<li><a href="./SourceTree SSH密钥缓存问题解决.html">SourceTree SSH密钥缓存问题解决</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SourceTree SSH密钥缓存问题解决]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/coding/github/SourceTree SSH密钥缓存问题解决.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/coding/github/SourceTree SSH密钥缓存问题解决.html</guid>
            <pubDate>Sun, 26 Jan 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[# SourceTree SSH密钥缓存问题解决

## 问题描述
通过sourcetree连接github时，出现以下提示：

命令: 

```
git -c diff.mnemonicprefix=false -c core.quotepath=false --no-optional-locks ls-remote git@github.com:VitepressAwesome/nolebase.git
```

> 输出:
> 错误: The host key is not cached for this server:
>   github.com (port 22)
> You have no guarantee that the server is the computer you
> think it is.
> The server's ssh-ed25519 key fingerprint is:
>   ssh-ed25519 255 SHA256:+++++++指纹++++++
> If you trust this host, enter "y" to add the key to Plink's
> cache and carry on connecting.
> If you want to carry on connecting just once, without adding
> the key to the cache, enter "n".
> If you do not trust this host, press Return to abandon the
> connection.
> Store key in cache? (y/n, Return cancels connection, i for more info) fatal: Could not read from remote repository.

## 原因分析

我现在需要解决用户在使用SourceTree时遇到的SSH主机密钥未缓存的问题。用户运行了git命令来ls-remote一个GitHub仓库，但提示主机密钥未缓存，需要确认是否信任该密钥。用户现在不知道该怎么处理，所以需要一步步指导他们解决这个问题。

首先，我应该回忆一下SSH连接的基本原理。当第一次通过SSH连接到某个服务器时，客户端会检查是否已经缓存了该服务器的主机密钥。如果没有，就会提示用户是否信任该密钥。这主要是为了防止中间人攻击。用户在这里遇到了这个问题，因为他们的环境（可能是使用Plink作为SSH客户端）没有缓存GitHub的主机密钥。

接下来，用户使用的是SourceTree，而SourceTree在Windows上可能默认使用PuTTY的Plink作为SSH客户端。PuTTY和OpenSSH处理已知主机的方式不同，PuTTY会有一个单独的known_hosts文件，而OpenSSH用的是用户目录下的.ssh/known_hosts。用户遇到的问题可能是因为Plink的缓存里没有GitHub的主机密钥，所以需要手动确认添加。

用户看到的错误信息里提到了是否将密钥保存到Plink的缓存中，需要输入y或n。如果用户输入y，Plink就会把密钥保存下来，以后连接就不会再提示了。但用户可能是在SourceTree中操作，没有直接的机会输入这个y，导致连接失败。这时候需要手动确认GitHub的主机密钥，并将其添加到Plink的缓存中。

首先，我需要验证GitHub的SSH密钥指纹是否正确。用户看到的指纹是ssh-ed25519 255 SHA256:+++++++指纹++++++。根据GitHub的官方文档，他们的Ed25519指纹确实是这个SHA256值。所以用户应该信任这个密钥。

解决方案可能包括几种方法：

1. 手动使用Plink（PuTTY的组件）连接到GitHub，这样会触发保存主机密钥的提示，用户可以输入y确认。例如运行`plink git@github.com`，然后输入y，之后SourceTree就能正常连接了。

2. 将GitHub的主机密钥手动添加到Plink的known_hosts文件中，即PuTTY的缓存文件。需要找到Plink存储known hosts的位置，通常是注册表中的某个位置，或者使用Pageant来管理。不过手动操作注册表可能比较复杂，所以可能更推荐第一种方法。

3. 或者，将SourceTree的SSH客户端切换为OpenSSH而不是Plink，这样可以使用系统默认的SSH配置，可能避免这个问题。但用户可能需要配置SourceTree使用OpenSSH，并且确保known_hosts中已经有GitHub的密钥。

另外，用户可能遇到这个问题是因为之前没有通过Plink连接过GitHub，所以需要首次确认。或者可能SourceTree在后台运行Plink时没有提供交互式提示，导致无法输入y，从而失败。因此需要手动触发这个确认过程。

总结下来，步骤应该是：

- 确认GitHub的SSH指纹是否匹配官方文档，确保安全性。

- 使用Plink手动连接GitHub，触发保存密钥的提示，输入y确认。

- 之后SourceTree的命令应该就能正常执行了。

或者，如果用户更熟悉OpenSSH，可以切换SourceTree的SSH客户端为OpenSSH，这样利用系统已有的known_hosts文件，可能已经包含了GitHub的密钥。

需要详细说明每一步的操作，尤其是如何运行Plink命令，因为用户可能不熟悉命令行操作。同时提醒用户确保他们信任GitHub的主机密钥，不要随意添加未知的密钥，避免安全风险。

此外，如果用户之前配置过SSH密钥，需要确认他们的SSH私钥是否正确，是否有权限访问该仓库。但根据错误信息来看，主要问题还是主机密钥未缓存，而不是权限问题。但错误信息最后提到“请确保您有正确的访问权限”，所以可能需要检查SSH密钥是否添加到GitHub账户中。但可能这一步问题已经处理，所以主要问题还是主机密钥缓存。

可能的其他考虑：用户是否在代理或防火墙后面，导致无法连接到GitHub的22端口？但错误信息显示已经能连接到服务器，只是主机密钥未缓存，所以网络连接应该是通的，问题出在密钥确认上。

最后，需要以清晰、分步骤的方式指导用户操作，确保他们能理解并安全地解决问题。

## 要解决 SourceTree 中出现的 SSH 主机密钥未缓存的问题，请按照以下步骤操作：

]]></description>
            <content:encoded><![CDATA[<h1 id="sourcetree-ssh密钥缓存问题解决" tabindex="-1">SourceTree SSH密钥缓存问题解决 <a class="header-anchor" href="#sourcetree-ssh密钥缓存问题解决" aria-label="Permalink to “SourceTree SSH密钥缓存问题解决”">&#8203;</a></h1>
<h2 id="问题描述" tabindex="-1">问题描述 <a class="header-anchor" href="#问题描述" aria-label="Permalink to “问题描述”">&#8203;</a></h2>
<p>通过sourcetree连接github时，出现以下提示：</p>
<p>命令:</p>
<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre><!--::markdown-it-async::yfa375zcv7ju9wf7ujp15n::--><code>git -c diff.mnemonicprefix=false -c core.quotepath=false --no-optional-locks ls-remote git@github.com:VitepressAwesome/nolebase.git</code></pre>
</div><blockquote>
<p>输出:
错误: The host key is not cached for this server:
github.com (port 22)
You have no guarantee that the server is the computer you
think it is.
The server's ssh-ed25519 key fingerprint is:
ssh-ed25519 255 SHA256:+++++++指纹++++++
If you trust this host, enter &quot;y&quot; to add the key to Plink's
cache and carry on connecting.
If you want to carry on connecting just once, without adding
the key to the cache, enter &quot;n&quot;.
If you do not trust this host, press Return to abandon the
connection.
Store key in cache? (y/n, Return cancels connection, i for more info) fatal: Could not read from remote repository.</p>
</blockquote>
<h2 id="原因分析" tabindex="-1">原因分析 <a class="header-anchor" href="#原因分析" aria-label="Permalink to “原因分析”">&#8203;</a></h2>
<p>我现在需要解决用户在使用SourceTree时遇到的SSH主机密钥未缓存的问题。用户运行了git命令来ls-remote一个GitHub仓库，但提示主机密钥未缓存，需要确认是否信任该密钥。用户现在不知道该怎么处理，所以需要一步步指导他们解决这个问题。</p>
<p>首先，我应该回忆一下SSH连接的基本原理。当第一次通过SSH连接到某个服务器时，客户端会检查是否已经缓存了该服务器的主机密钥。如果没有，就会提示用户是否信任该密钥。这主要是为了防止中间人攻击。用户在这里遇到了这个问题，因为他们的环境（可能是使用Plink作为SSH客户端）没有缓存GitHub的主机密钥。</p>
<p>接下来，用户使用的是SourceTree，而SourceTree在Windows上可能默认使用PuTTY的Plink作为SSH客户端。PuTTY和OpenSSH处理已知主机的方式不同，PuTTY会有一个单独的known_hosts文件，而OpenSSH用的是用户目录下的.ssh/known_hosts。用户遇到的问题可能是因为Plink的缓存里没有GitHub的主机密钥，所以需要手动确认添加。</p>
<p>用户看到的错误信息里提到了是否将密钥保存到Plink的缓存中，需要输入y或n。如果用户输入y，Plink就会把密钥保存下来，以后连接就不会再提示了。但用户可能是在SourceTree中操作，没有直接的机会输入这个y，导致连接失败。这时候需要手动确认GitHub的主机密钥，并将其添加到Plink的缓存中。</p>
<p>首先，我需要验证GitHub的SSH密钥指纹是否正确。用户看到的指纹是ssh-ed25519 255 SHA256:+++++++指纹++++++。根据GitHub的官方文档，他们的Ed25519指纹确实是这个SHA256值。所以用户应该信任这个密钥。</p>
<p>解决方案可能包括几种方法：</p>
<ol>
<li>
<p>手动使用Plink（PuTTY的组件）连接到GitHub，这样会触发保存主机密钥的提示，用户可以输入y确认。例如运行<code>plink git@github.com</code>，然后输入y，之后SourceTree就能正常连接了。</p>
</li>
<li>
<p>将GitHub的主机密钥手动添加到Plink的known_hosts文件中，即PuTTY的缓存文件。需要找到Plink存储known hosts的位置，通常是注册表中的某个位置，或者使用Pageant来管理。不过手动操作注册表可能比较复杂，所以可能更推荐第一种方法。</p>
</li>
<li>
<p>或者，将SourceTree的SSH客户端切换为OpenSSH而不是Plink，这样可以使用系统默认的SSH配置，可能避免这个问题。但用户可能需要配置SourceTree使用OpenSSH，并且确保known_hosts中已经有GitHub的密钥。</p>
</li>
</ol>
<p>另外，用户可能遇到这个问题是因为之前没有通过Plink连接过GitHub，所以需要首次确认。或者可能SourceTree在后台运行Plink时没有提供交互式提示，导致无法输入y，从而失败。因此需要手动触发这个确认过程。</p>
<p>总结下来，步骤应该是：</p>
<ul>
<li>
<p>确认GitHub的SSH指纹是否匹配官方文档，确保安全性。</p>
</li>
<li>
<p>使用Plink手动连接GitHub，触发保存密钥的提示，输入y确认。</p>
</li>
<li>
<p>之后SourceTree的命令应该就能正常执行了。</p>
</li>
</ul>
<p>或者，如果用户更熟悉OpenSSH，可以切换SourceTree的SSH客户端为OpenSSH，这样利用系统已有的known_hosts文件，可能已经包含了GitHub的密钥。</p>
<p>需要详细说明每一步的操作，尤其是如何运行Plink命令，因为用户可能不熟悉命令行操作。同时提醒用户确保他们信任GitHub的主机密钥，不要随意添加未知的密钥，避免安全风险。</p>
<p>此外，如果用户之前配置过SSH密钥，需要确认他们的SSH私钥是否正确，是否有权限访问该仓库。但根据错误信息来看，主要问题还是主机密钥未缓存，而不是权限问题。但错误信息最后提到“请确保您有正确的访问权限”，所以可能需要检查SSH密钥是否添加到GitHub账户中。但可能这一步问题已经处理，所以主要问题还是主机密钥缓存。</p>
<p>可能的其他考虑：用户是否在代理或防火墙后面，导致无法连接到GitHub的22端口？但错误信息显示已经能连接到服务器，只是主机密钥未缓存，所以网络连接应该是通的，问题出在密钥确认上。</p>
<p>最后，需要以清晰、分步骤的方式指导用户操作，确保他们能理解并安全地解决问题。</p>
<h2 id="要解决-sourcetree-中出现的-ssh-主机密钥未缓存的问题-请按照以下步骤操作" tabindex="-1">要解决 SourceTree 中出现的 SSH 主机密钥未缓存的问题，请按照以下步骤操作： <a class="header-anchor" href="#要解决-sourcetree-中出现的-ssh-主机密钥未缓存的问题-请按照以下步骤操作" aria-label="Permalink to “要解决 SourceTree 中出现的 SSH 主机密钥未缓存的问题，请按照以下步骤操作：”">&#8203;</a></h2>
<hr>
<h3 id="_1-验证-github-的-ssh-密钥指纹" tabindex="-1"><strong>1. 验证 GitHub 的 SSH 密钥指纹</strong> <a class="header-anchor" href="#_1-验证-github-的-ssh-密钥指纹" aria-label="Permalink to “1. 验证 GitHub 的 SSH 密钥指纹”">&#8203;</a></h3>
<p>首先确认提示中的指纹是否与 GitHub 官方一致：</p>
<ul>
<li><strong>GitHub 官方 Ed25519 指纹</strong>：<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre><!--::markdown-it-async::nl0gbujajfcgpj9op1jug::--><code>SHA256:+++++++指纹++++++</code></pre>
</div>如果匹配，说明是安全的，可以信任。</li>
</ul>
<hr>
<h3 id="_2-手动缓存密钥-通过-plink" tabindex="-1"><strong>2. 手动缓存密钥（通过 Plink）</strong> <a class="header-anchor" href="#_2-手动缓存密钥-通过-plink" aria-label="Permalink to “2. 手动缓存密钥（通过 Plink）”">&#8203;</a></h3>
<p>SourceTree 可能使用 Plink（PuTTY 的 SSH 客户端），需手动触发密钥保存：</p>
<ol>
<li><strong>打开命令提示符</strong>（CMD 或 PowerShell）。</li>
<li><strong>运行以下命令</strong>：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::0tz06e1o5uxki1z22plsvda::--><code>plink git@github.com</code></pre>
</div></li>
<li><strong>输入 <code>y</code></strong> 确认保存密钥到 Plink 的缓存。</li>
<li><strong>等待连接被拒绝</strong>（正常现象，目的仅是缓存密钥）。</li>
</ol>
<hr>
<h3 id="_3-检查-sourcetree-的-ssh-配置" tabindex="-1"><strong>3. 检查 SourceTree 的 SSH 配置</strong> <a class="header-anchor" href="#_3-检查-sourcetree-的-ssh-配置" aria-label="Permalink to “3. 检查 SourceTree 的 SSH 配置”">&#8203;</a></h3>
<p>确保 SourceTree 使用正确的 SSH 客户端：</p>
<ol>
<li>打开 SourceTree，进入 <strong>工具 &gt; 选项 &gt; 一般</strong>。</li>
<li>在 <strong>SSH 客户端</strong> 中选择 <strong>OpenSSH</strong>（推荐）而非 PuTTY/Plink。
<ul>
<li>OpenSSH 使用系统 <code>known_hosts</code> 文件（通常已包含 GitHub 密钥）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="_4-验证-ssh-密钥权限" tabindex="-1"><strong>4. 验证 SSH 密钥权限</strong> <a class="header-anchor" href="#_4-验证-ssh-密钥权限" aria-label="Permalink to “4. 验证 SSH 密钥权限”">&#8203;</a></h3>
<p>确保你的 SSH 私钥已添加到 GitHub 账户：</p>
<ol>
<li>检查 <code>~/.ssh/id_ed25519.pub</code> 或 <code>~/.ssh/id_rsa.pub</code> 内容。</li>
<li>登录 GitHub，进入 <strong>Settings &gt; SSH and GPG Keys</strong>，添加公钥。</li>
</ol>
<hr>
<h3 id="_5-重新尝试操作" tabindex="-1"><strong>5. 重新尝试操作</strong> <a class="header-anchor" href="#_5-重新尝试操作" aria-label="Permalink to “5. 重新尝试操作”">&#8203;</a></h3>
<p>完成上述步骤后，重新执行 SourceTree 的拉取/推送操作。</p>
<hr>
<h3 id="附-常见问题" tabindex="-1">附：常见问题 <a class="header-anchor" href="#附-常见问题" aria-label="Permalink to “附：常见问题”">&#8203;</a></h3>
<ul>
<li><strong>如果 Plink 未安装</strong>：安装 Git 时选择“使用 OpenSSH”而非 PuTTY。</li>
<li><strong>防火墙/网络问题</strong>：确保能访问 <code>github.com:22</code> 端口。</li>
<li><strong>强制使用 OpenSSH</strong>（推荐）：<div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::pfipoh4m9c9imxi980ua::--><code>git config --global core.sshCommand &quot;ssh -o IdentitiesOnly=yes -i ~/.ssh/your_private_key&quot;</code></pre>
</div></li>
</ul>
<hr>
<p>通过以上步骤，SourceTree 应能正确缓存 GitHub 的主机密钥并正常访问仓库。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用Pagefind为VitePress文档添加离线全文搜索能力]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/vitepress-plugin-pagefind.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/vitepress-plugin-pagefind.html</guid>
            <pubDate>Fri, 17 Jan 2025 03:00:01 GMT</pubDate>
            <description><![CDATA[Pagefind是基于Rust实现的离线搜索库，检索生成后的HTML页面内容，然后自动构建索引文件，提供搜索使用的API和组件]]></description>
            <content:encoded><![CDATA[<h1 id="使用pagefind为vitepress文档添加离线全文搜索能力" tabindex="-1">使用Pagefind为VitePress文档添加离线全文搜索能力 <a class="header-anchor" href="#使用pagefind为vitepress文档添加离线全文搜索能力" aria-label="Permalink to “使用Pagefind为VitePress文档添加离线全文搜索能力”">&#8203;</a></h1>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p><a href="https://vitepress.dev/" target="_blank" rel="noreferrer">VitePress</a> 相信大家都或多或少听说过或者用过了</p>
<p>默认 UI相比 <a href="https://v2.vuepress.vuejs.org/" target="_blank" rel="noreferrer">VuePress2.x</a> 好看，启动速度也快（由Vite驱动，当然VuePress也可以切换构建引擎至Vite）</p>
<p>做内容定制也相对简单，笔者的很多静态文档站点（使用VuePress1.x），文章内容多的时候启动非常的慢，于是就从之前的 VuePress 迁移到了 VitePress，并做了一个博客主题 <a href="https://theme.sugarat.top/" target="_blank" rel="noreferrer">@sugarat/theme</a> =&gt; 之前也有过介绍<a href="https://juejin.cn/post/7196517835380293693" target="_blank" rel="noreferrer">一个简约风的VitePress博客主题</a></p>
<p>但是 VitePress 官方目前还没有内置开箱即用的搜索能力（<a href="https://github.com/vuejs/vitepress/pull/2110" target="_blank" rel="noreferrer">相关PR</a>还在施工中）</p>
<p><img src="./vitepress-plugin-pagefind/MTY3OTgzNzk5NDg2MA==679837994860.png" alt="" loading="lazy"></p>
<p>文档里首推使用 <a href="https://docsearch.algolia.com/docs/what-is-docsearch" target="_blank" rel="noreferrer">Algolia DocSearch</a>, 这个需要申请，流程相对较慢，公司内网文档也无法接入使用。</p>
<p>推荐的另一个方案是使用 <a href="https://github.com/emersonbottero/vitepress-plugin-search" target="_blank" rel="noreferrer">vitepress-plugin-search</a> 基于 <a href="https://github.com/nextapps-de/flexsearch" target="_blank" rel="noreferrer">flexsearch</a> 实现，但是默认的UI较丑（与 Algolia 的UI差距较大），对中文没有提供开箱即用的支持，需要<a href="https://github.com/emersonbottero/vitepress-plugin-search/issues/11" target="_blank" rel="noreferrer">进行一定的配置</a></p>
<p><img src="./vitepress-plugin-pagefind/MTY3OTgzODY5MzUxNQ==679838693515.png" alt="" loading="lazy"></p>
<p>目前常用的除了 <code>flexsearch</code>，还有 <a href="https://github.com/lucaong/minisearch" target="_blank" rel="noreferrer">MiniSearch</a></p>
<p>笔者之前在逛GitHub的时候还发现了一个 <a href="https://github.com/cloudcannon/pagefind" target="_blank" rel="noreferrer">Pagefind</a>（基于Rust实现，检索生成后的HTML页面内容，然后自动构建索引文件）</p>
<p>感觉挺有意思的，就研究使用了一番，然后将其做成了一个可直接使用的 VItePress 插件（也就是本文将介绍的）</p>
<p>本文主要演示下 接入步骤和效果，再简单介绍<code>Pagefind</code>，最后讲解一下插件原理</p>
<h2 id="接入后效果" tabindex="-1">接入后效果 <a class="header-anchor" href="#接入后效果" aria-label="Permalink to “接入后效果”">&#8203;</a></h2>
<p>只需要2步即可完成接入</p>
<p>① 安装 <a href="https://github.com/ripplejourney/ripplejourney.github.io/tree/master/packages/vitepress-plugin-pagefind" target="_blank" rel="noreferrer">vitepress-plugin-pagefind</a></p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::dm605o4vxtzyue0qgu2z8::--><code>npm i vitepress-plugin-pagefind
# or
yarn add vitepress-plugin-pagefind
# or
pnpm add vitepress-plugin-pagefind</code></pre>
</div><p>② 在<code>.vitepress/config.ts</code>引入使用</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::omolxezjme8t7od618yxo::--><code>import { defineConfig } from &#039;vitepress&#039;
import { pagefindPlugin } from &#039;vitepress-plugin-pagefind&#039;
export default defineConfig({
  vite:{
    plugins:[pagefindPlugin()],
  }
})</code></pre>
</div><p>UI如下（power by <a href="https://github.com/xiaoluoboding/vue-command-palette" target="_blank" rel="noreferrer">vue-command-palette</a>）</p>
<table tabindex="0">
<thead>
<tr>
<th style="text-align:center">搜索按钮</th>
<th style="text-align:center">搜索框</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="./vitepress-plugin-pagefind/MTY3OTgxOTEzNjUwMw==679819136503.png" alt="" loading="lazy"></td>
<td style="text-align:center"><img src="./vitepress-plugin-pagefind/MTY3OTgxOTE1MDQ0OA==679819150448.png" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h2 id="pagefind介绍" tabindex="-1">Pagefind介绍 <a class="header-anchor" href="#pagefind介绍" aria-label="Permalink to “Pagefind介绍”">&#8203;</a></h2>
<blockquote>
<p><code>Pagefind</code>是一个完全静态的搜索库，旨在在大型网站上表现良好，同时尽可能地减少用户带宽的使用，且不需要进行任何基础设施托管。</p>
</blockquote>
<blockquote>
<p><code>Pagefind</code>在Hugo，Eleventy，Jekyll，Next，Astro，SvelteKit或任何其他SSG之后运行。安装过程始终相同：<code>Pagefind</code>仅需要一个包含构建的静态文件的文件夹，因此在大多数情况下，无需进行配置即可开始使用。</p>
</blockquote>
<blockquote>
<p>索引后，<code>Pagefind</code>会向您的构建文件添加静态搜索包，该包公开了可以在站点任何位置使用的<code>JavaScript</code>搜索API。<code>Pagefind</code>还提供了一个可无需配置即可使用的预构建UI</p>
</blockquote>
<p>总结：框架无关，直接解析静态站点的产物，然后生成索引文件，<strong>提供开箱即用的API和组件</strong>，支持开箱即用的多语言站点，零配置</p>
<h3 id="生成内容索引" tabindex="-1">生成内容索引 <a class="header-anchor" href="#生成内容索引" aria-label="Permalink to “生成内容索引”">&#8203;</a></h3>
<p>可直接通过npx调用，指定构建后的产物目录即可</p>
<p>以 vitepress 默认产物目录为例</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::74j1wiz13l7ghsauk3pdeq::--><code>npx pagefind --source docs/.vitepress/dist</code></pre>
</div><p>一般毫秒级就完成了页面内容的分析与pagefind需要的资源转换</p>
<p><img src="./vitepress-plugin-pagefind/MTY4MDQwNzk5NzYxNw==680407997617.png" alt="" loading="lazy"></p>
<p>默认会自动扫描指定目录下所有的<code>html</code>资源，将带有<code>data-pagefind-body</code>属性的元素作为索引的位置，否则的话使用<code>&lt;body&gt;</code>作为索引位置</p>
<p>会自动识别 <code>html</code> 中的 <code>lang</code> 属性，使用对应的分词策略处理，目前已经<a href="https://pagefind.app/docs/multilingual/#language-support" target="_blank" rel="noreferrer">内置多种语言支持</a></p>
<p>生成的相关文件默认在<code>_pagefind</code>目录中，内容如下</p>
<p><img src="./vitepress-plugin-pagefind/MTY4MDQyMjc2NjQ3NQ==680422766475.png" alt="" loading="lazy"></p>
<h3 id="使用内置搜索ui" tabindex="-1">使用内置搜索UI <a class="header-anchor" href="#使用内置搜索ui" aria-label="Permalink to “使用内置搜索UI”">&#8203;</a></h3>
<p>在生成索引的过程中，pagefind也会把内置的搜索框UI相关资源放入其中</p>
<p>在页面中只需要导入相应的<code>js/css</code>资源即可</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::c65b9l7pe8mo099tf3y9o::--><code>&lt;link href=&quot;/_pagefind/pagefind-ui.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;script src=&quot;/_pagefind/pagefind-ui.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;

&lt;div id=&quot;search&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    window.addEventListener(&#039;DOMContentLoaded&#039;, (event) =&gt; {
        new PagefindUI({ element: &quot;#search&quot; });
    });
&lt;/script&gt;</code></pre>
</div><p>搜索框样式如下</p>
<p><img src="./vitepress-plugin-pagefind/MTY4MDQyMzM0OTQ2NA==680423349464.png" alt="" loading="lazy"></p>
<h3 id="使用js-api" tabindex="-1">使用JS API <a class="header-anchor" href="#使用js-api" aria-label="Permalink to “使用JS API”">&#8203;</a></h3>
<p>默认的搜索框样式不满足的话可以，自定义搜索框逻辑，通过JS API调用搜索能力</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::n46vwn0zkb53aacid6o8q::--><code>// 1. Initializing Pagefind
const pagefind = await import(&quot;/_pagefind/pagefind.js&quot;);
// 2. search docs
const search = await pagefind.search(&quot;hello&quot;);
// 3. Loading a result
const oneResult = await search.results[0].data();</code></pre>
</div><p>搜索结果格式如下</p>
<p><img src="./vitepress-plugin-pagefind/MTY4MDQyMzg0NzMxMg==680423847312.png" alt="" loading="lazy"></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::j6wxc3ba6id23anzmouenp::--><code>interface SearchResult {
  url: string;
  excerpt: string;
  filters: Record&lt;string,any&gt;;
  meta: Record&lt;string,any&gt;;
  content: string;
  word_count: number;
}</code></pre>
</div><h3 id="一些不足" tabindex="-1">一些不足 <a class="header-anchor" href="#一些不足" aria-label="Permalink to “一些不足”">&#8203;</a></h3>
<ul>
<li>仅针对构建后的产物进行索引，开发环境下无法工作</li>
<li>对中文和日语等支持相对英语会差一点（区别见下截图）
<img src="./vitepress-plugin-pagefind/MTY4MDQyNDMyMjk1MA==680424322950.png" alt="" loading="lazy"></li>
<li>不支跳转至标题</li>
</ul>
<h2 id="插件实现原理解析" tabindex="-1">插件实现原理解析 <a class="header-anchor" href="#插件实现原理解析" aria-label="Permalink to “插件实现原理解析”">&#8203;</a></h2>
<p>这部分主要介绍 <code>vitepress-plugin-pagefind</code> 的关键实现部分（细节可看<a href="https://github.com/ripplejourney/ripplejourney.github.io/tree/master/packages/vitepress-plugin-pagefind" target="_blank" rel="noreferrer">源码</a>，如读者有更好的实现思路可以评论区交流）</p>
<p>几个关键步骤:</p>
<ol>
<li>替换默认搜索组件</li>
<li>目标元素上插入检索的标识<code>data-pagefind-body</code></li>
<li>插入运行时的<code>script</code>脚本</li>
</ol>
<h3 id="替换默认搜索组件" tabindex="-1">替换默认搜索组件 <a class="header-anchor" href="#替换默认搜索组件" aria-label="Permalink to “替换默认搜索组件”">&#8203;</a></h3>
<p>通过查看默认布局组件<code>Layout.vue</code>源码其中搜索组件是被<code>VPNavBarSearch.vue</code>引入</p>
<p>咱只需要通过插件添加一个 <code>alias</code> 规则,将其指向自定义的组件即可</p>
<p>这个使用插件的 <code>config</code> 钩子即可</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::v0u4drmjuyvi54nb79kn::--><code>export function pagefindPlugin() {
  return {
    name: &#039;vitepress-plugin-pagefind&#039;,
    enforce: &#039;pre&#039;,
    config: () =&gt; ({
      resolve: {
        alias: {
          &#039;./VPNavBarSearch.vue&#039;: &#039;vitepress-plugin-pagefind/Search.vue&#039;
        }
      }
    }),
  }
}</code></pre>
</div><h3 id="添加索引标识" tabindex="-1">添加索引标识 <a class="header-anchor" href="#添加索引标识" aria-label="Permalink to “添加索引标识”">&#8203;</a></h3>
<p>由于vitepress的默认 <code>body</code>元素中包含 navBar，footer，sidebar等等等内容</p>
<p>默认情况下每个页面的代码中都会包含这些公共内容，因此会导致检索出的内容有很多重复信息</p>
<p>理论上只需要检索用户编写的 markdown内容生成的部分</p>
<p>也就是<code>VPContent.vue</code>组件渲染的内容（当然里面包含了3种情况<code>VPHome</code>，<code>VPPage</code>，<code>VPDoc</code>这里可以不做区分）</p>
<p>这个通过插件的<code>transform</code>钩子处理一下，构建时替换源码中<code>VPContent</code>的内容</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::m58m2njqd7fqo5mmzfyrs::--><code>export function pagefindPlugin() {
  return {
    // ... other code
    transform(code, id) {
      if (id.endsWith(&#039;theme-default/Layout.vue&#039;)) {
        return code.replace(&#039;&lt;VPContent&gt;&#039;, &#039;&lt;VPContent data-pagefind-body&gt;&#039;)
      }
      return code
    }
  }
}</code></pre>
</div><h3 id="运行时的脚本注入" tabindex="-1">运行时的脚本注入 <a class="header-anchor" href="#运行时的脚本注入" aria-label="Permalink to “运行时的脚本注入”">&#8203;</a></h3>
<p>因为相关资源是在Build之后才会生成，所以直接在源码中 <code>import</code> 会提示 <code>module not found</code> 导致构建失败</p>
<p>咱可以在搜索组件里写一段脚本，在页面运行后<code>append</code>到页面中，这段逻辑可以写到<code>onBeforeMount</code>周期函数中</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::fddjjo1itzm22qr87aw8wm::--><code>import { onBeforeMount } from &#039;vue&#039;

const addInlineScript = () =&gt; {
  const scriptText = `import(&#039;/_pagefind/pagefind.js&#039;)
        .then((module) =&gt; {
          window.__pagefind__ = module
        })
        .catch(() =&gt; {
          console.log(&#039;not load /_pagefind/pagefind.js&#039;)
        })`
  const inlineScript = document.createElement(&#039;script&#039;)
  inlineScript.innerHTML = scriptText
  document.head.appendChild(inlineScript)
}

onBeforeMount(() =&gt; {
  addInlineScript()
})</code></pre>
</div><p><code>pagefind</code>我这里采用<code>import(source)</code>动态导入，组件搜索直接使用<code>window.__pagefind__</code>来进行API的调用</p>
<h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>目前这一版插件主要是将pagefind做了一个简单的内置，没有对搜索结果进行优化，也不支持多级标题的跳转</p>
<p>后续是准备优化一下插件的本身实现和功能</p>
<ul>
<li>插件内部的hack实现替换为 VitePress 的 <a href="https://vitepress.dev/reference/site-config#build-hooks" target="_blank" rel="noreferrer">Build Hooks</a></li>
<li>搜索内容的输入输出支持自定义的转换</li>
<li>跳转支持标题</li>
<li>...</li>
</ul>
<p>欢迎各位在评论区交流想法</p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/vitepress-plugin-pagefind/MTY3OTgzOTgxMjU3NQ==679839812575.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[dotnet开发]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/coding/dotnet/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/coding/dotnet/</guid>
            <pubDate>Thu, 21 Nov 2024 05:28:38 GMT</pubDate>
            <description><![CDATA[dotnet开发相关
 目录
* 大数相加&nuget 修改 package存储位置]]></description>
            <content:encoded><![CDATA[<h1 id="dotnet开发" tabindex="-1">dotnet开发 <a class="header-anchor" href="#dotnet开发" aria-label="Permalink to “dotnet开发”">&#8203;</a></h1>
<p>dotnet开发相关</p>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./dotnetViaVscode.html">大数相加&amp;nuget 修改 package存储位置</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[nuget 修改 package存储位置]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/coding/dotnet/dotnetViaVscode.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/coding/dotnet/dotnetViaVscode.html</guid>
            <pubDate>Thu, 21 Nov 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[方法一：修改 NuGet 配置文件
1. 打开 NuGet 配置文件。配置文件通常位于以下位置：
   - Windows: `%AppData%\NuGet\NuGet.Config`
   - m]]></description>
            <content:encoded><![CDATA[<h1 id="要修改-nuget-包存储位置-您需要更改-nuget-配置文件或使用命令行参数。以下是如何执行此操作的步骤" tabindex="-1">要修改 NuGet 包存储位置，您需要更改 NuGet 配置文件或使用命令行参数。以下是如何执行此操作的步骤： <a class="header-anchor" href="#要修改-nuget-包存储位置-您需要更改-nuget-配置文件或使用命令行参数。以下是如何执行此操作的步骤" aria-label="Permalink to “要修改 NuGet 包存储位置，您需要更改 NuGet 配置文件或使用命令行参数。以下是如何执行此操作的步骤：”">&#8203;</a></h1>
<h3 id="方法一-修改-nuget-配置文件" tabindex="-1">方法一：修改 NuGet 配置文件 <a class="header-anchor" href="#方法一-修改-nuget-配置文件" aria-label="Permalink to “方法一：修改 NuGet 配置文件”">&#8203;</a></h3>
<ol>
<li>
<p>打开 NuGet 配置文件。配置文件通常位于以下位置：</p>
<ul>
<li>Windows: <code>%AppData%\NuGet\NuGet.Config</code></li>
<li>macOS/Linux: <code>$HOME/.config/NuGet/NuGet.Config</code></li>
</ul>
<p>如果您找不到配置文件，可以在命令行中使用 <code>nuget config -list</code> 命令查看当前的 NuGet 配置。</p>
</li>
<li>
<p>在配置文件中添加或修改 <code>&lt;packageSources&gt;</code> 部分，指定新的存储位置。例如，要将包存储位置更改为 <code>D:\NuGetPackages</code>，请添加或修改以下内容：</p>
<div class="language-xml"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre><!--::markdown-it-async::2dqt6nychhle7a4sj75jgv::--><code>&lt;configuration&gt;
  &lt;packageSources&gt;
    &lt;add key=&quot;MyCustomPackages&quot; value=&quot;D:\NuGetPackages&quot; /&gt;
  &lt;/packageSources&gt;
&lt;/configuration&gt;</code></pre>
</div><p>这里的 <code>key</code> 是您自定义的源名称，<code>value</code> 是新的存储位置。</p>
</li>
<li>
<p>保存并关闭配置文件。</p>
</li>
</ol>
<h3 id="方法二-使用命令行参数" tabindex="-1">方法二：使用命令行参数 <a class="header-anchor" href="#方法二-使用命令行参数" aria-label="Permalink to “方法二：使用命令行参数”">&#8203;</a></h3>
<p>您还可以在安装或更新 NuGet 包时使用 <code>-Source</code> 参数指定新的存储位置。例如：</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::rjkok0u2449vs0tsfzpqe::--><code>dotnet nuget install &lt;package_name&gt; -Source D:\NuGetPackages</code></pre>
</div><p>或者，在更新 NuGet 包时：</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::wvq5kkd3ngrgawp2m70xx5::--><code>dotnet nuget update &lt;package_name&gt; -Source D:\NuGetPackages</code></pre>
</div><h3 id="方法三-设置全局默认源" tabindex="-1">方法三：设置全局默认源 <a class="header-anchor" href="#方法三-设置全局默认源" aria-label="Permalink to “方法三：设置全局默认源”">&#8203;</a></h3>
<p>如果您希望将新的存储位置设置为全局默认源，可以使用以下命令：</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::gxw6vjv1ocsk6dk2hm0rqf::--><code>dotnet nuget config -set globalPackagesFolder=D:\NuGetPackages</code></pre>
</div><p>这会将全局包文件夹设置为 <code>D:\NuGetPackages</code>。</p>
<h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">&#8203;</a></h3>
<p>通过以上方法，您可以轻松地修改 NuGet 包的存储位置。根据您的需求和偏好，您可以选择修改配置文件或使用命令行参数来实现这一目标。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[NodeJS]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/node/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/node/</guid>
            <pubDate>Tue, 16 Jul 2024 14:31:36 GMT</pubDate>
            <description><![CDATA[记录Node学习与开发的一点心得
 目录
* Node侧实现内容压缩(gzip/br/deflate)介绍与实践
* 使用TS封装操作MongoDB数据库的工具方法
* 使用Node.js从终端读入内]]></description>
            <content:encoded><![CDATA[<h1 id="nodejs" tabindex="-1">NodeJS <a class="header-anchor" href="#nodejs" aria-label="Permalink to “NodeJS”">&#8203;</a></h1>
<p>记录Node学习与开发的一点心得</p>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./compress-response.html">Node侧实现内容压缩(gzip/br/deflate)介绍与实践</a></li>
<li><a href="./mongoDb.html">使用TS封装操作MongoDB数据库的工具方法</a></li>
<li><a href="./p1.html">使用Node.js从终端读入内容</a></li>
<li><a href="./phantom-dep-cli.html">实现一个幽灵依赖扫描工具</a></li>
<li><a href="./前端接口神器之 json-server 详细使用指南 - MegaSu - 博客园.html">前端接口神器之 json-server 详细使用指南</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[前端接口神器之 json-server 详细使用指南]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/node/前端接口神器之 json-server 详细使用指南 - MegaSu - 博客园.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/node/前端接口神器之 json-server 详细使用指南 - MegaSu - 博客园.html</guid>
            <pubDate>Tue, 16 Jul 2024 14:31:36 GMT</pubDate>
            <description><![CDATA[
# 前端接口神器之 json-server 详细使用指南

]]></description>
            <content:encoded><![CDATA[<h1 id="前端接口神器之-json-server-详细使用指南" tabindex="-1">前端接口神器之 json-server 详细使用指南 <a class="header-anchor" href="#前端接口神器之-json-server-详细使用指南" aria-label="Permalink to “前端接口神器之 json-server 详细使用指南”">&#8203;</a></h1>
<hr>
<h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to “简介”">&#8203;</a></h2>
<p><code>json-server</code> 是一款小巧的接口模拟工具，一分钟内就能搭建一套 Restful 风格的 API，尤其适合前端接口测试使用。🔥🔥🔥
只需指定一个 <code>json</code> 文件作为 <code>api</code> 的数据源即可，使用起来非常方便，30 秒入门，基本上有手就行。👍
进阶操作还支持分页，排序等操作，简直强大。💪</p>
<h3 id="开源地址" tabindex="-1">开源地址 <a class="header-anchor" href="#开源地址" aria-label="Permalink to “开源地址”">&#8203;</a></h3>
<p>主页地址：<a href="https://www.npmjs.com/package/json-server" target="_blank" rel="noreferrer">https://www.npmjs.com/package/json-server</a>
Github项目地址：<a href="https://github.com/typicode/json-server" target="_blank" rel="noreferrer">https://github.com/typicode/json-server</a></p>
<h2 id="_30秒入门" tabindex="-1">30秒入门 <a class="header-anchor" href="#_30秒入门" aria-label="Permalink to “30秒入门”">&#8203;</a></h2>
<h3 id="环境依赖" tabindex="-1">环境依赖 <a class="header-anchor" href="#环境依赖" aria-label="Permalink to “环境依赖”">&#8203;</a></h3>
<ul>
<li>安装 Node.js 环境即可</li>
</ul>
<h3 id="操作步骤" tabindex="-1">操作步骤 <a class="header-anchor" href="#操作步骤" aria-label="Permalink to “操作步骤”">&#8203;</a></h3>
<ol>
<li>安装 JSON 服务器</li>
</ol>
<div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre><!--::markdown-it-async::95m6y9ufrfcsv0lyoazbhd::--><code>npm install -g json-server</code></pre>
</div><ol start="2">
<li>创建一个<code>db.json</code>包含一些数据的文件</li>
</ol>
<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre><!--::markdown-it-async::8cghj4jqj7glozzakg2b3::--><code>{
  &quot;posts&quot;: [
    { &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; }
  ],
  &quot;comments&quot;: [
    { &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 }
  ],
  &quot;profile&quot;: { &quot;name&quot;: &quot;typicode&quot; }
}</code></pre>
</div><ol start="3">
<li>启动 <code>json-server</code> 接口服务器</li>
</ol>
<div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre><!--::markdown-it-async::prfsa3j576f2821egl03j::--><code># 快速创建
json-server db.json

# 配置参数
json-server db.json --watch --port 3000</code></pre>
</div><ol start="4">
<li>浏览器访问 <a href="http://localhost:3000/posts/1" target="_blank" rel="noreferrer">http://localhost:3000/posts/1</a>，你会得到</li>
</ol>
<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre><!--::markdown-it-async::cuf78p3t2trjkyy7zrjrec::--><code>{ &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; }</code></pre>
</div><ol start="5">
<li>🎉恭喜你，已经完成 <code>json-server</code> 快速搭建，熟练使用的话 30 秒即可完成服务器搭建⏰。</li>
</ol>
<h3 id="补充" tabindex="-1">补充 <a class="header-anchor" href="#补充" aria-label="Permalink to “补充”">&#8203;</a></h3>
<ul>
<li>如果您发出 POST、PUT、PATCH 或 DELETE 请求，更改将自动安全地保存到 <code>db.json</code> 文件中。</li>
</ul>
<h2 id="路由进阶" tabindex="-1">路由进阶 <a class="header-anchor" href="#路由进阶" aria-label="Permalink to “路由进阶”">&#8203;</a></h2>
<p>根据之前的<code>db.json</code>文件，这里是所有的默认路由。</p>
<h3 id="路由形式一" tabindex="-1">路由形式一 <a class="header-anchor" href="#路由形式一" aria-label="Permalink to “路由形式一”">&#8203;</a></h3>
<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre><!--::markdown-it-async::5n4kb5pkh12xjhxhtki6nc::--><code>GET    /posts
GET    /posts/1
POST   /posts
PUT    /posts/1
PATCH  /posts/1
DELETE /posts/1</code></pre>
</div><h3 id="路由形式二" tabindex="-1">路由形式二 <a class="header-anchor" href="#路由形式二" aria-label="Permalink to “路由形式二”">&#8203;</a></h3>
<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre><!--::markdown-it-async::894vbt79rxcmzsc3d3vpn::--><code>GET    /profile
POST   /profile
PUT    /profile
PATCH  /profile</code></pre>
</div><h3 id="筛选" tabindex="-1">筛选 <a class="header-anchor" href="#筛选" aria-label="Permalink to “筛选”">&#8203;</a></h3>
<p>使用 <code>.</code> 访问筛选</p>
<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre><!--::markdown-it-async::wz76uqpk19a2fy7tu2kceg::--><code>GET /posts?title=json-server&amp;amp;author=typicode
GET /posts?id=1&amp;amp;id=2
GET /comments?author.name=typicode</code></pre>
</div><h3 id="分页" tabindex="-1">分页 <a class="header-anchor" href="#分页" aria-label="Permalink to “分页”">&#8203;</a></h3>
<p>使用<code>_page</code>和可选地<code>_limit</code>对返回的数据进行分页。</p>
<p>在<code>Link</code>标题，你会得到<code>first</code>，<code>prev</code>，<code>next</code>和<code>last</code>链接。</p>
<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre><!--::markdown-it-async::og34pr1y9sdxfl3kuxu9e::--><code>GET /posts?_page=7
GET /posts?_page=7&amp;amp;_limit=20</code></pre>
</div><p><em>默认返回10项</em></p>
<h3 id="排序" tabindex="-1">排序 <a class="header-anchor" href="#排序" aria-label="Permalink to “排序”">&#8203;</a></h3>
<p>添加<code>_sort</code>和<code>_order</code>（默认升序）</p>
<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre><!--::markdown-it-async::9rh8kjev60hh7j7r63c3c9::--><code>GET /posts?_sort=views&amp;amp;_order=asc
GET /posts/1/comments?_sort=votes&amp;amp;_order=asc</code></pre>
</div><p>对于多个字段，请使用以下格式：</p>
<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre><!--::markdown-it-async::6iulat1vyy4brgp70xj8ch::--><code>GET /posts?_sort=user,views&amp;amp;_order=desc,asc</code></pre>
</div><h3 id="切片-分页" tabindex="-1">切片(分页) <a class="header-anchor" href="#切片-分页" aria-label="Permalink to “切片(分页)”">&#8203;</a></h3>
<p>添加<code>_start</code>和<code>_end</code>或<code>_limit</code></p>
<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre><!--::markdown-it-async::fsij0vx4vkegv40kntlxl::--><code>GET /posts?_start=20&amp;amp;_end=30
GET /posts/1/comments?_start=20&amp;amp;_end=30
GET /posts/1/comments?_start=20&amp;amp;_limit=10</code></pre>
</div><p><strong>与<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank" rel="noreferrer">Array.slice</a>完全一样<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank" rel="noreferrer">工作</a>（即<code>_start</code>开始<code>_end</code>结束）</strong></p>
<h3 id="特殊符号" tabindex="-1">特殊符号 <a class="header-anchor" href="#特殊符号" aria-label="Permalink to “特殊符号”">&#8203;</a></h3>
<p>添加<code>_gte</code>或<code>_lte</code>获取范围</p>
<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre><!--::markdown-it-async::w3rm7gs8t2shlwbl3n19s::--><code>GET /posts?views_gte=10&amp;amp;views_lte=20</code></pre>
</div><p>添加<code>_ne</code>以排除值</p>
<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre><!--::markdown-it-async::6hforgtlc4bkaxms2rlyb::--><code>GET /posts?id_ne=1</code></pre>
</div><p>添加<code>_like</code>到过滤器（支持正则表达式）</p>
<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre><!--::markdown-it-async::9m3z44v0x82fyq4uebjxk::--><code>GET /posts?title_like=server</code></pre>
</div><h3 id="全文搜索" tabindex="-1">全文搜索 <a class="header-anchor" href="#全文搜索" aria-label="Permalink to “全文搜索”">&#8203;</a></h3>
<p>添加 <code>q</code></p>
<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre><!--::markdown-it-async::kjpz872arabi7xubxgnvp::--><code>GET /posts?q=internet</code></pre>
</div><h3 id="关系" tabindex="-1">关系 <a class="header-anchor" href="#关系" aria-label="Permalink to “关系”">&#8203;</a></h3>
<p>要包含子资源，请添加 <code>_embed</code></p>
<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre><!--::markdown-it-async::kd9t3yo1d775gyjk46lsd::--><code>GET /posts?_embed=comments
GET /posts/1?_embed=comments</code></pre>
</div><p>要包含父资源，请添加 <code>_expand</code></p>
<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre><!--::markdown-it-async::ukygzwmfox5lfig5e54::--><code>GET /comments?_expand=post
GET /comments/1?_expand=post</code></pre>
</div><p>获取或创建嵌套资源（默认为一级）</p>
<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre><!--::markdown-it-async::avqtq3hml2fuk5k0yqjw5::--><code>GET  /posts/1/comments
POST /posts/1/comments</code></pre>
</div><h3 id="数据库" tabindex="-1">数据库 <a class="header-anchor" href="#数据库" aria-label="Permalink to “数据库”">&#8203;</a></h3>
<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre><!--::markdown-it-async::mwnza3snq0mfc6jcuyqn3s::--><code>GET /db</code></pre>
</div><h3 id="主页" tabindex="-1">主页 <a class="header-anchor" href="#主页" aria-label="Permalink to “主页”">&#8203;</a></h3>
<p>返回默认索引文件或服务<code>./public</code>目录</p>
<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre><!--::markdown-it-async::7y7i5hhc4lk4h4u6xuv0zl::--><code>GET /</code></pre>
</div><h2 id="附加功能" tabindex="-1">附加功能 <a class="header-anchor" href="#附加功能" aria-label="Permalink to “附加功能”">&#8203;</a></h2>
<h3 id="静态文件服务器" tabindex="-1">静态文件服务器 <a class="header-anchor" href="#静态文件服务器" aria-label="Permalink to “静态文件服务器”">&#8203;</a></h3>
<p>您可以使用 JSON Server 为您的 HTML、JS 和 CSS 提供服务，只需创建一个<code>./public</code>目录或用于<code>--static</code>设置不同的静态文件目录。</p>
<div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre><!--::markdown-it-async::gjgs9vvtv6bjtwewqaye5::--><code>mkdir public
echo &#039;hello world&#039; &gt; public/index.html
json-server db.json</code></pre>
</div><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre><!--::markdown-it-async::ic93t18pm0pxqv9zevmcfo::--><code>json-server db.json --static ./some-other-dir</code></pre>
</div><h3 id="替换端口" tabindex="-1">替换端口 <a class="header-anchor" href="#替换端口" aria-label="Permalink to “替换端口”">&#8203;</a></h3>
<p>您可以使用以下<code>--port</code>标志在其他端口上启动 <code>JSON Server</code> ：</p>
<div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre><!--::markdown-it-async::u0qm3avzkvseelo3p00vq::--><code>$ json-server --watch db.json --port 3004</code></pre>
</div><h3 id="支持跨域" tabindex="-1">支持跨域 <a class="header-anchor" href="#支持跨域" aria-label="Permalink to “支持跨域”">&#8203;</a></h3>
<p>您可以使用 CORS 和 JSONP 从任何地方访问您模拟的 API 接口。</p>
<h3 id="远程模式" tabindex="-1">远程模式 <a class="header-anchor" href="#远程模式" aria-label="Permalink to “远程模式”">&#8203;</a></h3>
<p>您可以加载远程模式。</p>
<div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre><!--::markdown-it-async::2xlx6eseonp5efezwwmwo::--><code>$ json-server http://example.com/file.json
$ json-server http://jsonplaceholder.typicode.com/db</code></pre>
</div><h3 id="生成随机数据" tabindex="-1">生成随机数据 <a class="header-anchor" href="#生成随机数据" aria-label="Permalink to “生成随机数据”">&#8203;</a></h3>
<p>使用 JS 而不是 JSON 文件，您可以通过编程方式创建数据。</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::63b9so77u4w97rhlw8k5s::--><code>// index.js
module.exports = () =&gt; {
  const data = { users: [] }
  // 创建 1000 个用户信息
  for (let i = 0; i &lt; 1000; i++) {
    data.users.push({ id: i, name: `user${i}` })
  }
  return data
}</code></pre>
</div><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre><!--::markdown-it-async::z8xn0dgwme07isupezu2vx::--><code>$ json-server index.js</code></pre>
</div><p><strong>提示</strong>：使用<a href="https://github.com/Marak/faker.js" target="_blank" rel="noreferrer">Faker</a>、<a href="https://github.com/boo1ean/casual" target="_blank" rel="noreferrer">Casual</a>、<a href="https://github.com/victorquinn/chancejs" target="_blank" rel="noreferrer">Chance</a>或<a href="https://github.com/json-schema-faker/json-schema-faker" target="_blank" rel="noreferrer">JSON Schema Faker 等模块</a>。</p>
<h3 id="添加自定义路由" tabindex="-1">添加自定义路由 <a class="header-anchor" href="#添加自定义路由" aria-label="Permalink to “添加自定义路由”">&#8203;</a></h3>
<p>创建一个<code>routes.json</code>文件。注意每条路线都以<code>/</code>.</p>
<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre><!--::markdown-it-async::tqzf4abgx68vfjb38qqos::--><code>{
  &quot;/api/*&quot;: &quot;/$1&quot;,
  &quot;/:resource/:id/show&quot;: &quot;/:resource/:id&quot;,
  &quot;/posts/:category&quot;: &quot;/posts?category=:category&quot;,
  &quot;/articles\\?id=:id&quot;: &quot;/posts/:id&quot;
}</code></pre>
</div><p>使用<code>--routes</code>选项启动 JSON 服务器。</p>
<div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre><!--::markdown-it-async::4d9uojeu5t4620sf8p3n::--><code>json-server db.json --routes routes.json</code></pre>
</div><p>现在您可以使用其他路线访问资源。</p>
<div class="language-http"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre><!--::markdown-it-async::3wpmi32bob5xrnocqhv56::--><code>/api/posts # → /posts
/api/posts/1  # → /posts/1
/posts/1/show # → /posts/1
/posts/javascript # → /posts?category=javascript
/articles?id=1 # → /posts/1</code></pre>
</div><h3 id="添加中间件" tabindex="-1">添加中间件 <a class="header-anchor" href="#添加中间件" aria-label="Permalink to “添加中间件”">&#8203;</a></h3>
<p>您可以使用以下<code>--middlewares</code>选项从 CLI 添加中间件：</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::6337zzub1bgmeo1lr344b::--><code>// hello.js
module.exports = (req, res, next) =&gt; {
  res.header(&#039;X-Hello&#039;, &#039;World&#039;)
  next()
}</code></pre>
</div><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre><!--::markdown-it-async::csajffxrzyib47sbrs4::--><code>json-server db.json --middlewares ./hello.js
json-server db.json --middlewares ./first.js ./second.js</code></pre>
</div><h3 id="命令行使用" tabindex="-1">命令行使用 <a class="header-anchor" href="#命令行使用" aria-label="Permalink to “命令行使用”">&#8203;</a></h3>
<div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre><!--::markdown-it-async::ai947uemur6ayt409g166s::--><code>json-server [options] &lt;source&gt;

Options:
  --config, -c       Path to config file           [default: &quot;json-server.json&quot;]
  --port, -p         Set port                                    [default: 3000]
  --host, -H         Set host                             [default: &quot;localhost&quot;]
  --watch, -w        Watch file(s)                                     [boolean]
  --routes, -r       Path to routes file
  --middlewares, -m  Paths to middleware files                           [array]
  --static, -s       Set static files directory
  --read-only, --ro  Allow only GET requests                           [boolean]
  --no-cors, --nc    Disable Cross-Origin Resource Sharing             [boolean]
  --no-gzip, --ng    Disable GZIP Content-Encoding                     [boolean]
  --snapshots, -S    Set snapshots directory                      [default: &quot;.&quot;]
  --delay, -d        Add delay to responses (ms)
  --id, -i           Set database id property (e.g. _id)         [default: &quot;id&quot;]
  --foreignKeySuffix, --fks  Set foreign key suffix, (e.g. _id as in post_id)
                                                                 [default: &quot;Id&quot;]
  --quiet, -q        Suppress log messages from output                 [boolean]
  --help, -h         Show help                                         [boolean]
  --version, -v      Show version number                               [boolean]

Examples:
  json-server db.json
  json-server file.js
  json-server http://example.com/db.json

https://github.com/typicode/json-server</code></pre>
</div><p>您还可以在<code>json-server.json</code>配置文件中设置选项。</p>
<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre><!--::markdown-it-async::03641f99h6tu25ssknmj0od::--><code>{
  &quot;port&quot;: 3000
}</code></pre>
</div><h3 id="模块" tabindex="-1">模块 <a class="header-anchor" href="#模块" aria-label="Permalink to “模块”">&#8203;</a></h3>
<p>如果您需要添加身份验证、验证或<strong>任何行为</strong>，您可以将项目作为模块与其他 Express 中间件结合使用。</p>
<h4 id="简单的例子" tabindex="-1">简单的例子 <a class="header-anchor" href="#简单的例子" aria-label="Permalink to “简单的例子”">&#8203;</a></h4>
<div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre><!--::markdown-it-async::rxfvfssvfrhxiu23g9xer::--><code>$ npm install json-server --save-dev</code></pre>
</div><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::u0kwihhbubmxhngwhapl2q::--><code>// server.js
const jsonServer = require(&#039;json-server&#039;)
const server = jsonServer.create()
const router = jsonServer.router(&#039;db.json&#039;)
const middlewares = jsonServer.defaults()

server.use(middlewares)
server.use(router)
server.listen(3000, () =&gt; {
  console.log(&#039;JSON Server is running&#039;)
})</code></pre>
</div><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre><!--::markdown-it-async::mmc2236dqec8uxuw5whcag::--><code>$ node server.js</code></pre>
</div><p>您提供给<code>jsonServer.router</code>函数的路径是相对于您启动节点进程的目录的。如果从另一个目录运行上述代码，最好使用绝对路径：</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::ttjha92kg8ni5e1yn0wbun::--><code>const path = require(&#039;path&#039;)
const router = jsonServer.router(path.join(__dirname, &#039;db.json&#039;))</code></pre>
</div><p>对于内存数据库，只需将对象传递给<code>jsonServer.router()</code>.</p>
<p>另请注意，<code>jsonServer.router()</code>它可用于现有的 Express 项目。</p>
<h4 id="自定义路由示例" tabindex="-1">自定义路由示例 <a class="header-anchor" href="#自定义路由示例" aria-label="Permalink to “自定义路由示例”">&#8203;</a></h4>
<p>假设您想要一个回显查询参数的路由和另一个在创建的每个资源上设置时间戳的路由。</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::6f3eahst7ks9rm6ffsji::--><code>const jsonServer = require(&#039;json-server&#039;)
const server = jsonServer.create()
const router = jsonServer.router(&#039;db.json&#039;)
const middlewares = jsonServer.defaults()

// 设置默认中间件（记录器、静态、cors 和无缓存）
server.use(middlewares)

// 写在自定义路由之前
server.get(&#039;/echo&#039;, (req, res) =&gt; {
  res.jsonp(req.query)
})

// 要处理 POST、PUT 和 PATCH，您需要使用 body-parser
// 您可以使用 JSON Server
server.use(jsonServer.bodyParser)
server.use((req, res, next) =&gt; {
  if (req.method === &#039;POST&#039;) {
    req.body.createdAt = Date.now()
  }
  // 继续到 JSON Server 路由器
  next()
})

// 使用默认路由器
server.use(router)
server.listen(3000, () =&gt; {
  console.log(&#039;JSON Server is running&#039;)
})</code></pre>
</div><h4 id="访问控制示例" tabindex="-1">访问控制示例 <a class="header-anchor" href="#访问控制示例" aria-label="Permalink to “访问控制示例”">&#8203;</a></h4>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::vu882vn7g5u6l43bzar9::--><code>const jsonServer = require(&#039;json-server&#039;)
const server = jsonServer.create()
const router = jsonServer.router(&#039;db.json&#039;)
const middlewares = jsonServer.defaults()

server.use(middlewares)
server.use((req, res, next) =&gt; {
  if (isAuthorized(req)) { // 在此处添加您的授权逻辑
    next() // 继续到 JSON Server 路由器
  }
  else {
    res.sendStatus(401)
  }
})
server.use(router)
server.listen(3000, () =&gt; {
  console.log(&#039;JSON Server is running&#039;)
})</code></pre>
</div><h4 id="自定义输出示例" tabindex="-1">自定义输出示例 <a class="header-anchor" href="#自定义输出示例" aria-label="Permalink to “自定义输出示例”">&#8203;</a></h4>
<p>要修改响应，请覆盖<code>router.render</code>方法：</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::8ohg6aze5ov0n466cge3ju::--><code>// 在这个例子中，返回的资源将被包装在一个 body 属性
router.render = (req, res) =&gt; {
  res.jsonp({
    body: res.locals.data
  })
}</code></pre>
</div><p>您可以为响应设置自己的状态代码：</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::5dt64erno35rle4nevjl4::--><code>// 在这个例子中，我们模拟了一个服务器端错误响应
router.render = (req, res) =&gt; {
  res.status(500).jsonp({
    error: &#039;error message here&#039;
  })
}</code></pre>
</div><h4 id="重写器示例" tabindex="-1">重写器示例 <a class="header-anchor" href="#重写器示例" aria-label="Permalink to “重写器示例”">&#8203;</a></h4>
<p>要添加重写规则，请使用<code>jsonServer.rewriter()</code>：</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::j360xjdd7avksklztinz::--><code>// 写在 server.use(router) 之前
server.use(jsonServer.rewriter({
  &#039;/api/*&#039;: &#039;/$1&#039;,
  &#039;/blog/:resource/:id/show&#039;: &#039;/:resource/:id&#039;
}))</code></pre>
</div><h4 id="在另一个端点上挂载-json-服务器示例" tabindex="-1">在另一个端点上挂载 JSON 服务器示例 <a class="header-anchor" href="#在另一个端点上挂载-json-服务器示例" aria-label="Permalink to “在另一个端点上挂载 JSON 服务器示例”">&#8203;</a></h4>
<p>或者，您也可以将路由器安装在<code>/api</code>.</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::a17hm2wx00j2e9l8o7da05::--><code>server.use(&#039;/api&#039;, router)</code></pre>
</div><h4 id="api" tabindex="-1">API <a class="header-anchor" href="#api" aria-label="Permalink to “API”">&#8203;</a></h4>
<p><strong><code>jsonServer.create()</code></strong></p>
<p>返回一个 Express 服务器。</p>
<p><strong><code>jsonServer.defaults([options])</code></strong></p>
<p>返回 JSON 服务器使用的中间件。</p>
<ul>
<li>选项
<ul>
<li><code>static</code> 静态文件的路径</li>
<li><code>logger</code> 启用记录器中间件（默认值：true）</li>
<li><code>bodyParser</code> 启用 body-parser 中间件（默认值：true）</li>
<li><code>noCors</code> 禁用 CORS（默认值：false）</li>
<li><code>readOnly</code> 只接受 GET 请求（默认值：false）</li>
</ul>
</li>
</ul>
<p><strong><code>jsonServer.router([path|object])</code></strong></p>
<p>返回 JSON 服务器路由器。</p>
<h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">&#8203;</a></h2>
<ol>
<li>json-server 入门简单，30 秒出效果，零编码实现 REST API 风格接口，实属前端接口神器。👍👍👍</li>
<li>路由进阶操作还支持分页，排序等操作，简直强大。💪</li>
<li>感谢点赞与支持💕💕💕</li>
</ol>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[译：使用 Bun 执行 Shell 脚本]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/bun/bun-shell.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/bun/bun-shell.html</guid>
            <pubDate>Tue, 09 Jul 2024 16:55:35 GMT</pubDate>
            <description><![CDATA[JavaScript 是世界上最流行的脚本语言。那么为什么在 `JavaScript` 中执行 `Shell` 脚本很困难呢？Bun 又是怎么解决这个问题的？]]></description>
            <content:encoded><![CDATA[<h1 id="译-使用-bun-执行-shell-脚本" tabindex="-1">译：使用 Bun 执行 Shell 脚本 <a class="header-anchor" href="#译-使用-bun-执行-shell-脚本" aria-label="Permalink to “译：使用 Bun 执行 Shell 脚本”">&#8203;</a></h1>
<blockquote>
<p>原文地址（Bun Blog）： <a href="https://bun.sh/blog/the-bun-shell" target="_blank" rel="noreferrer">https://bun.sh/blog/the-bun-shell</a>
<br/>作者： <a href="https://twitter.com/jarredsumner" target="_blank" rel="noreferrer">jarredsumner</a>
<br/>发布时间：2024-01-20</p>
</blockquote>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p><code>JavaScript</code> 是世界上最流行的脚本语言。</p>
<p>那么为什么在 <code>JavaScript</code> 中执行 <code>Shell</code> 脚本很困难呢？</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::9rhz7mbtiet9u9mnmyfxft::--><code>import { spawnSync } from &#039;child_process&#039;

// 代码比想象中要稍微复杂一些
const { status, stdout, stderr } = spawnSync(&#039;ls&#039;, [&#039;-l&#039;, &#039;*.js&#039;], {
  encoding: &#039;utf8&#039;,
})</code></pre>
</div><p>你也可以使用内置的 API 来执行类似的操作：</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::czyziqbvfahbezsthgjji::--><code>import { readdir } from &#039;fs/promises&#039;;

(await readdir(&#039;.&#039;, { withFileTypes: true })).filter(a =&gt;
  a.name.endsWith(&#039;.js&#039;),
)</code></pre>
</div><p>但是，还是没有 shell 脚本简单：</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::8gupg8an3t7yi59abbsvk::--><code>ls *.js</code></pre>
</div><h2 id="为什么现有的-shell-无法在-javascript-中运行" tabindex="-1">为什么现有的 shell 无法在 JavaScript 中运行 <a class="header-anchor" href="#为什么现有的-shell-无法在-javascript-中运行" aria-label="Permalink to “为什么现有的 shell 无法在 JavaScript 中运行”">&#8203;</a></h2>
<p><code>bash</code> 和 <code>sh</code> 等这些 <code>shell</code> 工具已经存在几十年了。</p>
<p>但是，为什么它们在 <code>JavaScript</code> 中不能很好的工作？</p>
<p><code>macOS (zsh)</code>、<code>Linux (bash)</code> 和 <code>Windows (cmd)</code> 的 shell 都有所不同，具有不同的语法和不同的命令。每个平台上可用的命令都不同，甚至相同的命令也可能有不同的可选参数和行为。</p>
<p>迄今为止，<code>npm</code> 的解决方案是依靠社区用 <code>JavaScript</code> 实现来填补缺失的命令。</p>
<h3 id="rm-rf-不适用于-windows" tabindex="-1">rm -rf 不适用于 Windows <a class="header-anchor" href="#rm-rf-不适用于-windows" aria-label="Permalink to “rm -rf 不适用于 Windows”">&#8203;</a></h3>
<p><a href="https://www.npmjs.com/package/rimraf" target="_blank" rel="noreferrer">rimraf</a> 是 <code>rm -rf</code> 指令的跨平台实现，每周下载 6000 万次：</p>
<p><img src="./bun-shell/4be77f54128dc01fe235bf46be65dfd0.png" alt="" loading="lazy"></p>
<h3 id="foo-bar-script-设置环境变量在-windows-上不生效" tabindex="-1"><code>FOO=bar &lt;script&gt;</code> 设置环境变量在 Windows 上不生效 <a class="header-anchor" href="#foo-bar-script-设置环境变量在-windows-上不生效" aria-label="Permalink to “FOO=bar &lt;script&gt; 设置环境变量在 Windows 上不生效”">&#8203;</a></h3>
<p>不同平台上设置环境变量的方式略有不同。如果不使用 <code>FOO=bar</code> 这种方式，那就是使用 <a href="https://www.npmjs.com/package/cross-env" target="_blank" rel="noreferrer">cross-env</a></p>
<p><img src="./bun-shell/654ccf7364bc395e6699f33dbe05bc8c.png" alt="" loading="lazy"></p>
<h3 id="which-在-windows-上是-where" tabindex="-1">which 在 Windows 上是 where <a class="header-anchor" href="#which-在-windows-上是-where" aria-label="Permalink to “which 在 Windows 上是 where”">&#8203;</a></h3>
<p>于是另一个周下载量 6000w 的包诞生了：</p>
<p><img src="./bun-shell/ba91ab9eb9713c5484c09a6bd62f96a5.png" alt="" loading="lazy"></p>
<h2 id="shell-启动时间也有一点长" tabindex="-1">shell 启动时间也有一点长 <a class="header-anchor" href="#shell-启动时间也有一点长" aria-label="Permalink to “shell 启动时间也有一点长”">&#8203;</a></h2>
<p>创建一个 <code>shell</code> 执行需要多久？</p>
<p>在 Linux x64 Hetzner Arch Linux 机器上，大约需要 7ms：</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::6nq5g69qzfhsblqyhx7b9d::--><code>$ hyperfine --warmup 3 &#039;bash -c &quot;echo hello&quot;&#039; &#039;sh -c &quot;echo hello&quot;&#039; -N

Benchmark 1: bash -c &#039;echo hello&#039;
  Time (mean ± σ):       7.3 ms ±   1.5 ms    [User: 5.1 ms, System: 1.9 ms]
  Range (min … max):     1.7 ms …   9.4 ms    529 runs

Benchmark 2: sh -c &#039;echo hello&#039;
  Time (mean ± σ):       7.2 ms ±   1.6 ms    [User: 4.8 ms, System: 2.1 ms]
  Range (min … max):     1.5 ms …   9.6 ms    327 runs</code></pre>
</div><p>如果只是想运行单个命令，但是启动 <code>shell</code> 可能比运行命令本身花费更长的时间。如果需要在循环中运行许多命令，那么成本就会升高。</p>
<p>你可以尝试嵌入 <code>shell</code>，但这样就复杂了，而且它们的许可证可能与你的项目不兼容。</p>
<h2 id="这些-polyfill-真的必要吗" tabindex="-1">这些 polyfill 真的必要吗？ <a class="header-anchor" href="#这些-polyfill-真的必要吗" aria-label="Permalink to “这些 polyfill 真的必要吗？”">&#8203;</a></h2>
<p>在 2009 - 2016 年的里，<code>JavaScript</code> 还相对较新且处于实验阶段时，依靠社区来填补缺失的功能是很合理的。但现在已经是 2024 年了。<code>JavaScript</code> 已在广泛的使用于服务端开发了。如今，<code>JavaScript</code> 生态系统对需求的理解与 2009 年时完全不同了。</p>
<p>我们其实可以做得更好。</p>
<h2 id="介绍一下-bun-shell" tabindex="-1">介绍一下 Bun Shell <a class="header-anchor" href="#介绍一下-bun-shell" aria-label="Permalink to “介绍一下 Bun Shell”">&#8203;</a></h2>
<p><code>Bun Shell</code> 是 <code>Bun</code> 提供的一种新的实验性的嵌入式语言和解释器，支持使用 <code>JavaScript</code> 和 <code>TypeScript</code> 编写跨平台运行的 <code>shell</code> 脚本。</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::n2dpfxxunkg4d303p1rgme::--><code>import { $ } from &#039;bun&#039;

// 直接在终端里输出
await $`ls *.js`

// 转为字符串变量
const text = await $`ls *.js`.text()</code></pre>
</div><p>同时允许你使用 <code>JavaScript</code> 变量：</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::6vskil42ly87jshpesdji::--><code>import { $ } from &#039;bun&#039;

const resp = await fetch(&#039;https://example.com&#039;)

const stdout = await $`gzip -c &lt; ${resp}`.arrayBuffer()</code></pre>
</div><p>出于安全问题考虑，所有模板变量都将被转义：</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::h2tjebc4qxtf2fsjfrad::--><code>const filename = &#039;foo.js; rm -rf /&#039;

// 将会执行指令 `ls &#039;foo.js; rm -rf /&#039;`
const results = await $`ls ${filename}`

console.log(results.exitCode) // 1
console.log(results.stderr.toString()) // ls: cannot access &#039;foo.js; rm -rf /&#039;: No such file or directory</code></pre>
</div><p>使用 <code>Bun Shell</code> 感觉就像普通的 <code>JavaScript</code>。允许你将标准输出放入 <code>buffers</code> 中：</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::m27ydjwc2ij9fxnaxqpgyk::--><code>import { $ } from &#039;bun&#039;

const buffer = Buffer.alloc(1024)

await $`ls *.js &gt; ${buffer}`

console.log(buffer.toString(&#039;utf8&#039;))</code></pre>
</div><p>你也可以将输出结果直接写入文件：</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::gicxboxtiw9w4u95ftu2r::--><code>import { $, file } from &#039;bun&#039;

// 当做文件输出
await $`ls *.js &gt; ${file(&#039;output.txt&#039;)}`

// 或者文件路径字符串
await $`ls *.js &gt; output.txt`
await $`ls *.js &gt; ${&#039;output.txt&#039;}`</code></pre>
</div><p>你还可以将输出结果通过管道运算符传递给其它命令：</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::psdcutvmu0cec35tlxb8vq::--><code>import { $ } from &#039;bun&#039;

await $`ls *.js | grep foo`</code></pre>
</div><p>你甚至可以使用 <code>Response</code> 作为标准输入：</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::v00iirqrhniny2g8bs1dq::--><code>import { $ } from &#039;bun&#039;

const buffer = new Response(&#039;bar\n foo\n bar\n foo\n&#039;)

await $`grep foo &lt; ${buffer}`</code></pre>
</div><p>可使用 <code>cd</code>、<code>echo</code> 和 <code>rm</code> 等内置命令：</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::fwdui4n6emhe8aw1knlmv::--><code>import { $ } from &#039;bun&#039;

await $`cd .. &amp;&amp; rm -rf node_modules/rimraf`</code></pre>
</div><p>它可在 <code>Windows</code>、<code>macOS</code> 和 <code>Linux</code> 上运行。我们实现了许多常用命令和功能，如<code>通配符</code>、<code>环境变量</code>、<code>重定向（redirection）</code>、<code>管道（piping）</code>等。</p>
<p>它被设计为简单 <code>shell</code> 脚本的替代品。在 <code>Windows</code> 版 <code>Bun</code> 中，它将为 <code>bun run</code> 中的 <code>package.json</code> “脚本”提供支持。</p>
<p>为了更有趣一点，您还可以将它用作独立的 shell 脚本解释器：</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::ednxyy7ndchmadfkl4hn::--><code>echo &quot;cat package.json&quot; &gt; script.bun.sh
bun script.bun.sh</code></pre>
</div><h2 id="如何安装" tabindex="-1">如何安装？ <a class="header-anchor" href="#如何安装" aria-label="Permalink to “如何安装？”">&#8203;</a></h2>
<p><code>Bun Shell</code> 内置于 <code>Bun</code> 中。如果已经安装了 <code>Bun v1.0.24</code> 或更高版本，那么你就可以使用它：</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::xk06602i3ymdmb83byvo26::--><code>bun --version
1.0.24</code></pre>
</div><p>如果你没有安装<code>Bun</code>，可以使用<code>curl</code>安装：</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::3qrzvovkisan9lgqkwfdl::--><code>curl -fsSL https://bun.sh/install | bash</code></pre>
</div><p>或者使用 npm :</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::voti1ipfname30cj9z86nm::--><code>npm install -g bun</code></pre>
</div><h2 id="使用实践" tabindex="-1">使用实践 <a class="header-anchor" href="#使用实践" aria-label="Permalink to “使用实践”">&#8203;</a></h2>
<p>创建 <code>test.ts</code> 文件，写入如下代码</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::wwgunlg5ta09qj54ia9a7l::--><code>import { $ } from &#039;bun&#039;

await $`echo hello world`

const files = await $`ls *.js *.mjs`.text()

console.log(files.split(&#039;\n&#039;))</code></pre>
</div><p>运行脚本</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::kyenfosoihqzx83ai00c::--><code>bun test.ts</code></pre>
</div><p><a href="https://app.warp.dev/block/VLbnk6T4x6rCSVZT2uwWs7" target="_blank" rel="noreferrer">运行结果</a> 如下</p>
<p><img src="./bun-shell/1ad4e2f3727b32803ee4ce3b458ee21f.png" alt="" loading="lazy"></p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/bun-shell/4be77f54128dc01fe235bf46be65dfd0.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[安装nvm后终端启动变慢,更快的Node版本管理工具推荐]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/node/nvm-iterm.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/node/nvm-iterm.html</guid>
            <pubDate>Tue, 09 Jul 2024 16:55:35 GMT</pubDate>
            <description><![CDATA[终端启动时总会卡顿一下，没去探究原因，看到咲奈的分享才知道是nvm在作祟]]></description>
            <content:encoded><![CDATA[<h1 id="安装nvm后终端启动变慢-更快的node版本管理工具推荐" tabindex="-1">安装nvm后终端启动变慢,更快的Node版本管理工具推荐 <a class="header-anchor" href="#安装nvm后终端启动变慢-更快的node版本管理工具推荐" aria-label="Permalink to “安装nvm后终端启动变慢,更快的Node版本管理工具推荐”">&#8203;</a></h1>
<h2 id="先看安装前后对比" tabindex="-1">先看安装前后对比 <a class="header-anchor" href="#先看安装前后对比" aria-label="Permalink to “先看安装前后对比”">&#8203;</a></h2>
<p>安装前</p>
<p><img src="./nvm-iterm/MTY3NjE4NDI1OTY0OA==676184259648.png" alt="" loading="lazy"></p>
<p>安装后</p>
<p><img src="./nvm-iterm/MTY3NjE4NDgwNjAzMA==676184806030.png" alt="" loading="lazy"></p>
<p>可以看到有明显的卡顿</p>
<h2 id="如何解决" tabindex="-1">如何解决 <a class="header-anchor" href="#如何解决" aria-label="Permalink to “如何解决”">&#8203;</a></h2>
<p>将 NVM 初始化的逻辑放入函数中，使用时才调用</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::o7xnzkbbu705r7s14vqtv7::--><code>nvm() {// [!code ++]
export NVM_DIR=&quot;$HOME/.nvm&quot;
[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm
[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion
}// [!code ++]</code></pre>
</div><p>方法来源 <a href="https://public.zsxq.com/groups/28851452458181.html" target="_blank" rel="noreferrer">咲奈的平行时空</a></p>
<p><img src="./nvm-iterm/MTY3NjE4NTM2MDkyOQ==676185360929.png" alt="" loading="lazy"></p>
<p><strong>带来的影响</strong></p>
<p>emm 用Node的话需要手动执行一下<code>nvm</code> 进行初始化，不是很优雅</p>
<p>下面介绍几个可平替 NVM 的工具，非常的赞</p>
<h2 id="使用其它更快的工具" tabindex="-1">使用其它更快的工具 <a class="header-anchor" href="#使用其它更快的工具" aria-label="Permalink to “使用其它更快的工具”">&#8203;</a></h2>
<h3 id="volta" tabindex="-1"><a href="https://volta.sh/" target="_blank" rel="noreferrer">volta</a> <a class="header-anchor" href="#volta" aria-label="Permalink to “volta”">&#8203;</a></h3>
<p>基于 Rust 实现的，除了Node版本外还支持其它的</p>
<p>安装</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::2w9ok2wymetp9lvq97okc::--><code>curl https://get.volta.sh | bash</code></pre>
</div><p>安装 Node</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::rld6wqh3zl5qhopiga1ka::--><code># install latest
volta install node
# or
volta install node@16</code></pre>
</div><h3 id="fnm" tabindex="-1"><a href="https://github.com/Schniz/fnm" target="_blank" rel="noreferrer">fnm</a> <a class="header-anchor" href="#fnm" aria-label="Permalink to “fnm”">&#8203;</a></h3>
<p>也是一个 基于 Rust的 Node 包管理工具</p>
<p>安装</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::6dcy0gk06hga6h2jod5gqw::--><code>curl -fsSL https://fnm.vercel.app/install | bash</code></pre>
</div><p>安装 Node</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::3k96dcxsd4cop86093qn3::--><code>fnm install --latest

fnm install 14</code></pre>
</div><h3 id="pnpm" tabindex="-1"><a href="https://pnpm.io/zh/cli/env" target="_blank" rel="noreferrer">pnpm</a> <a class="header-anchor" href="#pnpm" aria-label="Permalink to “pnpm”">&#8203;</a></h3>
<p>没错<code>pnpm</code> 可以安装Node包</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::27iqs5xuxqd5ptue97iw::--><code>pnpm env use --global latest</code></pre>
</div><p>安装 v16 的Node.js</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::9m30apv4al8d3o43uoxkg9::--><code>pnpm env use --global 16</code></pre>
</div><h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>笔者试用了下最后选择了<code>volta</code></p>
<p>不仅仅支持 node 版本管理，还支持其它全局包的管理</p>
<p>功能非常的多（比如 根据项目里Node版本要求，自动切换）</p>
<p><img src="./nvm-iterm/MTY3NjE4OTM5MTk2Mg==676189391962.png" alt="" loading="lazy"></p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/nvm-iterm/MTY3NjE4NTM2MDkyOQ==676185360929.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[性能优化笔记]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/performance/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/performance/</guid>
            <pubDate>Tue, 09 Jul 2024 16:55:35 GMT</pubDate>
            <description><![CDATA[:::tip 参考
掘金小册:性能优化
:::
 目录
* 网络层面优化
* CDN的缓存与回源机制
* DNS 预解析
* 图片优化
* 懒加载与执行
* 监控
* 资源预加载
* 页面预渲染
* ]]></description>
            <content:encoded><![CDATA[<h1 id="性能优化笔记" tabindex="-1">性能优化笔记 <a class="header-anchor" href="#性能优化笔记" aria-label="Permalink to “性能优化笔记”">&#8203;</a></h1>
<p><img src="./index/MTU4MzQwMTU3ODkwNw==583401578907.png" alt="图片" loading="lazy"></p>
<div  class="tip custom-block"><p class="custom-block-title">参考</p>
<p><a href="https://juejin.im/book/5b936540f265da0a9624b04b/section/5b97cd22e51d450e8f5f6375#heading-2" target="_blank" rel="noreferrer">掘金小册:性能优化</a></p>
</div>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./Internet.html">网络层面优化</a></li>
<li><a href="./cdn.html">CDN的缓存与回源机制</a></li>
<li><a href="./dnsPre.html">DNS 预解析</a></li>
<li><a href="./image.html">图片优化</a></li>
<li><a href="./lazyLoad.html">懒加载与执行</a></li>
<li><a href="./monitor.html">监控</a></li>
<li><a href="./preLoad.html">资源预加载</a></li>
<li><a href="./preRender.html">页面预渲染</a></li>
<li><a href="./ssr.html">服务端渲染</a></li>
<li><a href="./throttling.html">节流与防抖</a></li>
</ul>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/index/MTU4MzQwMTU3ODkwNw==583401578907.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[博客性能优化笔记 | 99分]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/essay/dev/2024-blog-perf.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/essay/dev/2024-blog-perf.html</guid>
            <pubDate>Tue, 09 Jul 2024 16:55:35 GMT</pubDate>
            <description><![CDATA[# 博客性能优化笔记 | 99分

闲着没事，拿 lighthouse 测了一下博客网站的性能评测，发现诊断出的问题还挺多，就顺手优化了一下。

这篇文章将记录这个优化的过程。

## 优化前后对比
lighthouse 检测结果

|                                     优化前                                      |                                     优化后                                      |
| :]]></description>
            <content:encoded><![CDATA[<h1 id="博客性能优化笔记-99分" tabindex="-1">博客性能优化笔记 | 99分 <a class="header-anchor" href="#博客性能优化笔记-99分" aria-label="Permalink to “博客性能优化笔记 | 99分”">&#8203;</a></h1>
<p>闲着没事，拿 lighthouse 测了一下博客网站的性能评测，发现诊断出的问题还挺多，就顺手优化了一下。</p>
<p>这篇文章将记录这个优化的过程。</p>
<h2 id="优化前后对比" tabindex="-1">优化前后对比 <a class="header-anchor" href="#优化前后对比" aria-label="Permalink to “优化前后对比”">&#8203;</a></h2>
<p>lighthouse 检测结果</p>
<table tabindex="0">
<thead>
<tr>
<th style="text-align:center">优化前</th>
<th style="text-align:center">优化后</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="./2024-blog-perf/4d82e4e81e499921a65b73c80034c153.png" alt="" loading="lazy"></td>
<td style="text-align:center"><img src="./2024-blog-perf/b5bae2c72f1d2aed2c09857c1b9e6b5f.png" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<p>性能面板检测结果</p>
<table tabindex="0">
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">FCP</th>
<th style="text-align:center">DOMContentLoaded</th>
<th style="text-align:center">LCP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">优化前</td>
<td style="text-align:center">764ms</td>
<td style="text-align:center">1798ms</td>
<td style="text-align:center">1864ms</td>
</tr>
<tr>
<td style="text-align:center">优化后</td>
<td style="text-align:center">496ms</td>
<td style="text-align:center">507ms</td>
<td style="text-align:center">496ms</td>
</tr>
</tbody>
</table>
<ul>
<li>FCP（First Contentful Paint）</li>
<li>LCP（Largest Contentful Paint）</li>
</ul>
<h2 id="检测工具" tabindex="-1">检测工具 <a class="header-anchor" href="#检测工具" aria-label="Permalink to “检测工具”">&#8203;</a></h2>
<p>使用 Chrome 自带的 lighthouse 和 性能面板进行测试。</p>
<table tabindex="0">
<thead>
<tr>
<th style="text-align:center">性能面板</th>
<th style="text-align:center">lighthouse</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="./2024-blog-perf/ee2e46cd895e2773a22671fe99571bd3.png" alt="" loading="lazy"></td>
<td style="text-align:center"><img src="./2024-blog-perf/c35d5a583f80ccbeae74544644fbc236.png" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h2 id="发现问题" tabindex="-1">发现问题 <a class="header-anchor" href="#发现问题" aria-label="Permalink to “发现问题”">&#8203;</a></h2>
<h3 id="性能面板-performance" tabindex="-1">性能面板 | Performance <a class="header-anchor" href="#性能面板-performance" aria-label="Permalink to “性能面板 | Performance”">&#8203;</a></h3>
<p><em>通过截图可以观察到每个时间的页面变化</em></p>
<p><img src="./2024-blog-perf/1d59bbd832442846c5e15bd05a0fb41a.png" alt="" loading="lazy"></p>
<p>发现的问题：</p>
<ol>
<li>文章列表渲染后，文章封面图加载缓慢</li>
<li>图片完成加载时间过长（封面，头像图片）</li>
<li>布局渲染期间发生明显变化</li>
</ol>
<ul>
<li>友链列表加载完成后</li>
<li>左上头像加载完成</li>
</ul>
<h3 id="lighthouse" tabindex="-1">lighthouse <a class="header-anchor" href="#lighthouse" aria-label="Permalink to “lighthouse”">&#8203;</a></h3>
<p>测试后会给到优化建议。</p>
<p><img src="./2024-blog-perf/564a5318bef5fe8f9318e205a946ed5d.png" alt="" loading="lazy"></p>
<p>这里挑一些后面用到的</p>
<ol start="4">
<li>使用新的图片格式（WebP and AVIF）</li>
<li>减少没用到的CSS文件大小</li>
<li>img 没有明确的宽高属性</li>
<li>资源传输压缩（gzip, brotli 等）</li>
<li>加载适当大小的图片（避免超过要展示的大小）</li>
<li>避免超大的资源加载阻塞网络（主要是一些超大的图片和js）</li>
</ol>
<h2 id="优化过程" tabindex="-1">优化过程 <a class="header-anchor" href="#优化过程" aria-label="Permalink to “优化过程”">&#8203;</a></h2>
<h3 id="图片优化" tabindex="-1">图片优化 <a class="header-anchor" href="#图片优化" aria-label="Permalink to “图片优化”">&#8203;</a></h3>
<p><em>解决：1，2，4，8，9</em></p>
<p>① 裁剪为渲染的大小</p>
<p>② 格式调整为WebP格式</p>
<p>我的图片都是放在图床上的（<a href="https://www.qiniu.com/" target="_blank" rel="noreferrer">七牛云</a>，<a href="https://www.upyun.com/" target="_blank" rel="noreferrer">又拍云</a>，<a href="https://www.bitiful.com/" target="_blank" rel="noreferrer">缤纷云</a>）。</p>
<p>这一步我直接使用 OSS（对象存储） 提供的图片加载裁剪功能即可。</p>
<p>配置目标：<code>宽高裁剪为 120px * 80px</code>，格式调整为 <code>WebP</code> 格式。</p>
<p>配置处理样式示例</p>
<table tabindex="0">
<thead>
<tr>
<th style="text-align:center">七牛云</th>
<th style="text-align:center">又拍云</th>
<th style="text-align:center">缤纷云</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="./2024-blog-perf/35a9ae4bce09253ec27336add6d5b113.png" alt="" loading="lazy"></td>
<td style="text-align:center"><img src="./2024-blog-perf/71b189c9662ae6ebf6c5cbba026bef9b.png" alt="" loading="lazy"></td>
<td style="text-align:center"><img src="./2024-blog-perf/61666d5257abea7242b81f73b841366b.png" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<p>使用：在原有的资源上添加对应的后置即可</p>
<ul>
<li>七牛云：url<code>~cover.webp</code></li>
<li>又拍云：url<code>-cover</code></li>
<li>缤纷云：url<code>!style:cover</code></li>
</ul>
<p>代码中的体现↓</p>
<table tabindex="0">
<thead>
<tr>
<th style="text-align:center">封面</th>
<th style="text-align:center">友链头像</th>
<th style="text-align:center">头像</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="./2024-blog-perf/bea00144a61781f8effd682a43d36af0.png" alt="" loading="lazy"></td>
<td style="text-align:center"><img src="./2024-blog-perf/aad8979fe2c73aa37c626d59cdbcb199.png" alt="" loading="lazy"></td>
<td style="text-align:center"><img src="./2024-blog-perf/a0bebb4818ac1c4dcd208871c977fd6b.png" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h3 id="oml2d模型资源优化" tabindex="-1">oml2d模型资源优化 <a class="header-anchor" href="#oml2d模型资源优化" aria-label="Permalink to “oml2d模型资源优化”">&#8203;</a></h3>
<p>博客左下角的看板娘加载优化。</p>
<p><em>解决：9</em></p>
<p>① 资源全部放在自己的 OSS 通过CDN加载（有gzip压缩，更快的访问速度）</p>
<p><img src="./2024-blog-perf/a54a6ad8b950bcd35881a91a766d9516.png" alt="" loading="lazy"></p>
<p>② 将模型用到的PNG图片压缩</p>
<p>使用之前做的<a href="https://demos.sugarat.top/pages/png-compress/" target="_blank" rel="noreferrer">图片在线压缩工具</a></p>
<p><img src="./2024-blog-perf/3a71f093eb7e6a9edd7fc5a44ea5453a.png" alt="" loading="lazy"></p>
<p>压缩后减少了 88% 的体积，视觉上看不出变化。</p>
<h3 id="网络优化" tabindex="-1">网络优化 <a class="header-anchor" href="#网络优化" aria-label="Permalink to “网络优化”">&#8203;</a></h3>
<p><em>解决：7，9</em></p>
<p>① 第三方资源使用 OSS存储 + CDN加载</p>
<p>② 访问使用 HTTP3/HTTP2</p>
<p>新的协议加载资源，用上多路复用的特性。</p>
<p>启用前提资源支持 HTTPS 访问（配置SSL证书），才能启用 HTTP2/3。</p>
<p>配置 HTTPS 时使用最新的 TLS1.3 版本，更快的加解密速度。</p>
<p>下面是在各平台开启相关配置示意。</p>
<table tabindex="0">
<thead>
<tr>
<th style="text-align:center">七牛云</th>
<th style="text-align:center">又拍云</th>
<th style="text-align:center">缤纷云</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="./2024-blog-perf/bbbd1791fb922ff5a3b93bf767da7077.png" alt="" loading="lazy"></td>
<td style="text-align:center"><img src="./2024-blog-perf/cef4e8d57160ce1e15f55a013fb5c48f.png" alt="" loading="lazy"></td>
<td style="text-align:center"><img src="./2024-blog-perf/567b27f97e7c8c6d9872d30554ff5aac.png" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<p>优化前后对比</p>
<table tabindex="0">
<thead>
<tr>
<th style="text-align:center">优化前</th>
<th style="text-align:center">优化后</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="./2024-blog-perf/2589d8a0c951eb52926265296d295300.png" alt="" loading="lazy"></td>
<td style="text-align:center"><img src="./2024-blog-perf/d2a595575fffd4894aafb90d242169ae.png" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h3 id="布局优化" tabindex="-1">布局优化 <a class="header-anchor" href="#布局优化" aria-label="Permalink to “布局优化”">&#8203;</a></h3>
<p><em>解决：3，6</em></p>
<p><strong>目标：减少触发 “页面回流重绘” 的范围和次数。</strong></p>
<p>① 针对图片，限定具体渲染的宽高，避免图片加载后布局发生变化</p>
<p><img src="./2024-blog-perf/ff09a4dbcd305b2b1fb1811934a1c7c2.png" alt="" loading="lazy"></p>
<p><img src="./2024-blog-perf/67cfbd857a8a3e7e7eefa5aac53f696e.png" alt="" loading="lazy"></p>
<p>② 针对后渲染区域，限定其容器的宽度，避免渲染后影响布局</p>
<p><img src="./2024-blog-perf/2210f6baef787ab13326a26d02e11783.png" alt="" loading="lazy"></p>
<h3 id="减少无用代码" tabindex="-1">减少无用代码 <a class="header-anchor" href="#减少无用代码" aria-label="Permalink to “减少无用代码”">&#8203;</a></h3>
<p><em>解决：5</em></p>
<p>① 移除无用的 js 脚本或者 CSS 资源</p>
<p>大概看了一下，项目里额外依赖的 element-plus 样式文件占大头。</p>
<p><img src="./2024-blog-perf/028e0cf966f7a0b067ce1f3dc26ede32.png" alt="" loading="lazy"></p>
<p>将全量引入，手动调整为按需引入。</p>
<h2 id="最终效果" tabindex="-1">最终效果 <a class="header-anchor" href="#最终效果" aria-label="Permalink to “最终效果”">&#8203;</a></h2>
<table tabindex="0">
<thead>
<tr>
<th style="text-align:center">性能面板</th>
<th style="text-align:center">lighthouse</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="./2024-blog-perf/5373e67f09e2a349074b0ab0c852d134.png" alt="" loading="lazy"></td>
<td style="text-align:center"><img src="./2024-blog-perf/b5bae2c72f1d2aed2c09857c1b9e6b5f.png" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<p>优化后的性能指标</p>
<ul>
<li>FCP（First Contentful Paint）：496ms</li>
<li>DOMContentLoaded：507ms</li>
<li>LCP（Largest Contentful Paint）：496ms</li>
</ul>
<p>访问 <a href="https://www.dmsrs.org" target="_blank" rel="noreferrer">https://www.dmsrs.org</a> 可以看到效果还是很明显的。</p>
<h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">&#8203;</a></h2>
<ol>
<li>图片：压缩，加载合适尺寸，优先使用 WebP 格式</li>
<li>网络：HTTPS + HTTP2/3，OSS + CDN</li>
<li>布局：减少回流重绘范围与次数</li>
<li>资源：移除无用代码，无用的第三方资源加载</li>
</ol>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/2024-blog-perf/4d82e4e81e499921a65b73c80034c153.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[实现自动扫描工作区npm包并同步cnpm]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/cnnc.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/cnnc.html</guid>
            <pubDate>Tue, 09 Jul 2024 16:55:35 GMT</pubDate>
            <description><![CDATA[批量且自动的做cnpm的同步，如果你是一个多npm包的项目，那么这个工具非常适合你]]></description>
            <content:encoded><![CDATA[<h1 id="实现自动扫描工作区npm包并同步cnpm" tabindex="-1">实现自动扫描工作区npm包并同步cnpm <a class="header-anchor" href="#实现自动扫描工作区npm包并同步cnpm" aria-label="Permalink to “实现自动扫描工作区npm包并同步cnpm”">&#8203;</a></h1>
<p><strong>省流版: <code>npx cnnc</code></strong></p>
<p>为避免包名重复，取了2个单词的首尾，<em><span style="color:red">cn</span>pm sy<span style="color:red">nc</span></em></p>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>在开发一个多npm包的项目时，时常会一次更新多个包的代码，再批量发布到 npm 镜像源后。</p>
<p>由于国内网络环境的原因，大部分都会使用<a href="https://npmmirror.com/" target="_blank" rel="noreferrer">淘宝的镜像源</a>进行依赖安装，为了确保发布后，通过淘宝源能够顺利的安装，通常会手动同步一下</p>
<p><code>cnpm sync vue react</code></p>
<p>但在一些大型的 monorepo 的多包工程里，手动输入包名是一件非常繁琐的事情，所以准备把输入的过程简化一下，改成自动扫描工作区的包名，然后自动同步。</p>
<p>进而有了这个工具</p>
<h2 id="工具的使用" tabindex="-1">工具的使用 <a class="header-anchor" href="#工具的使用" aria-label="Permalink to “工具的使用”">&#8203;</a></h2>
<p>直接通过 npx 运行即可，将自动扫描所有的包</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::h7dx3visn0uq1rqed7gocr::--><code>npx cnnc</code></pre>
</div><p><a href="https://app.warp.dev/block/wrTUBqnxdg65BqCTgtSgD5" target="_blank" rel="noreferrer">示例结果</a> 如下</p>
<p><img src="./cnnc/MTY5NDI0OTI5MjYwMg==694249292602.png" alt="" loading="lazy"></p>
<p>当然也同样支持手动传入要更新的包</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::ltm2f6mgyy9iia6g813m2j::--><code>npx cncc vue react</code></pre>
</div><p>如果使用频率较高，也可全局安装<code>npm i -g cnnc</code></p>
<p>这样可以直接通过<code>cnnc</code>或<code>cs</code>命令调用</p>
<p><img src="./cnnc/MTY5NDI1NDAxNTM0Nw==694254015347.png" alt="" loading="lazy"></p>
<h2 id="实现原理" tabindex="-1">实现原理 <a class="header-anchor" href="#实现原理" aria-label="Permalink to “实现原理”">&#8203;</a></h2>
<p>核心代码不到20行，下面详细的拆解一下，便于学习与理解</p>
<p>主要分为3部分</p>
<ul>
<li>工作区的包扫描</li>
<li>过滤出合法的包</li>
<li>调用 cnpm 同步</li>
</ul>
<h3 id="工作区的包扫描" tabindex="-1">工作区的包扫描 <a class="header-anchor" href="#工作区的包扫描" aria-label="Permalink to “工作区的包扫描”">&#8203;</a></h3>
<p>主要目的就是扫描工作区所有的 <code>package.json</code> 文件，然后提取出包名（不包含 node_modules，build 等目录下的文件）</p>
<p>这里可以 <code>fs.readdirSync</code> 实现一个递归的扫描，也可以用<a href="https://github.com/mrmlnc/fast-glob#readme" target="_blank" rel="noreferrer">fast-glob</a>，图方便我这里选择后者，也是目前目录扫描用得较广泛的一个包</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::kitpgvukchqp767kddi988::--><code>const fg = require(&#039;fast-glob&#039;)

const pkgNames = []

// 通过glob 取所有package.json
fg.sync(&#039;./**/package.json&#039;, {
  ignore: [
    &#039;**/node_modules&#039;,
    &#039;**/dist&#039;,
    &#039;**/build&#039;,
    &#039;**/test&#039;,
    // 省略更多的无关目录...
  ],
  absolute: true
}).forEach((file) =&gt; {
  const { name } = require(file)
  pkgNames.push(name)
})</code></pre>
</div><p>通常工作区里有很多无关的目录，比如<code>node_modules</code>、<code>build</code>、<code>dist</code>、<code>test</code>等，这些目录下的<code>package.json</code>都不需要同步，所以可以通过<code>ignore</code>参数来忽略掉，避免不必要的扫描（否则 node_modules 套 node_modules 会增加扫描时间，部分目录是软链的话也会导致扫描路径的异常）</p>
<h3 id="过滤出合法的包" tabindex="-1">过滤出合法的包 <a class="header-anchor" href="#过滤出合法的包" aria-label="Permalink to “过滤出合法的包”">&#8203;</a></h3>
<p>有些<code>package.json</code>会包含 <code>&quot;private&quot;: true</code> 内容，表明为私有的包，不会发布到npm镜像源，所以需要过滤掉</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::lrso8ou2uesu2lk3qy2zl::--><code>// 省略其它代码
globResult.forEach((file) =&gt; {
  const { name, private } = require(file)
  if (!private) {
    pkgNames.push(name)
  }
})</code></pre>
</div><h3 id="调用-cnpm-同步" tabindex="-1">调用 cnpm 同步 <a class="header-anchor" href="#调用-cnpm-同步" aria-label="Permalink to “调用 cnpm 同步”">&#8203;</a></h3>
<p>最后一步就是调用<code>cnpm sync</code>命令，这里可以通过<code>child_process</code>模块来实现</p>
<p>通过<code>spawn</code>方法，可以直接调用命令行命令，然后通过<code>stdio: 'inherit'</code>将命令行的输出直接打印到终端中</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::xxv6keacuztr330unfyr9::--><code>const { spawn } = require(&#039;child_process&#039;)
const { promisify } = require(&#039;util&#039;)
function CnpmSync(...names) {
  return promisify(spawn)(&#039;npx&#039;, [&#039;cnpm&#039;, &#039;sync&#039;, ...names], {
    cwd: __dirname,
    stdio: &#039;inherit&#039;
  })
}</code></pre>
</div><p>为防止用户没有全局安装cnpm，这里通过<code>npx cnpm sync</code>的方式来调用，这样就不需要用户自己安装了</p>
<p>同时可以将<code>cnpm</code>作为包<code>dependencies</code>依赖安装，通过<code>cwd: __dirname</code>参数，将指令运行目录指定为当前目录，这样<code>npx cnpm</code>执行时，就会去<code>cncc</code>目录的<code>node_modules</code>下找到<code>cnpm</code>命令，从而实现调用，不需要重复的在全局进行依赖的安装，大大提升指令执行速度</p>
<h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>工具原理很简单，解决的问题也非常明确，希望能够帮助读者省下几分钟的时间，提升开发的幸福度</p>
<hr>
<p>当然工具还有很多可优化的点，比如先通过对比 npm 和 cnpm 的版本号，如果一致就不需要同步了，这样可以大大加快同步的速度</p>
<p>（<em>目前由于网络原因从 npm 镜像源拉包版本信息相对较慢，所以本期没有加这个功能，读者如果有更好的建议，欢迎评论区交流</em>）</p>
<p>同时可以将这个指令放在 <code>&quot;npm postpublish&quot;</code> 钩子中，这样发布后自动触发同步，更加省心</p>
<hr>
<p>完整源码见：<a href="https://github.com/ATQQ/tools/blob/main/packages/cli/sync-cnpm/README.md" target="_blank" rel="noreferrer">GitHub</a></p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/cnnc/MTY5NDI0OTI5MjYwMg==694249292602.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[如何优雅的复制当前项目分支名]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/copy-branch.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/copy-branch.html</guid>
            <pubDate>Tue, 09 Jul 2024 16:55:35 GMT</pubDate>
            <description><![CDATA[本文简单介绍了如何通过`Shell`和`Node.js`实现复制当前分支名到剪贴板]]></description>
            <content:encoded><![CDATA[<h1 id="如何优雅的复制当前项目分支名" tabindex="-1">如何优雅的复制当前项目分支名 <a class="header-anchor" href="#如何优雅的复制当前项目分支名" aria-label="Permalink to “如何优雅的复制当前项目分支名”">&#8203;</a></h1>
<p><strong>省流版: <code>npx bcy</code></strong></p>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>在工作中，协作场景下，避免不了要告诉同事你当前的开发分支，<strong>通常情况</strong>下需要2步</p>
<p><strong>Step1 查看当前分支</strong></p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::z798jy7ty0ky0thx74tjif::--><code>git branch</code></pre>
</div><p>这里还有个case，分支多的话需要翻页查看，才能找到当前分支</p>
<p><img src="./copy-branch/MTY5MTI0NTYxOTQzMw==691245619433.png" alt="" loading="lazy"></p>
<p>要准确获取需要加上<code>--show-current</code>参数</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::h9jjm5pb57wm5ada2q2kt::--><code>git branch --show-current</code></pre>
</div><p><img src="./copy-branch/MTY5MTI0NTc5MDM2OQ==691245790369.png" alt="" loading="lazy"></p>
<p><strong>Step2 鼠标右键复制当前分支</strong></p>
<hr>
<p>本文将会介绍2种方式，实现1行代码直接复制分支</p>
<ul>
<li>Shell</li>
<li>Node CLI</li>
</ul>
<h2 id="核心步骤" tabindex="-1">核心步骤 <a class="header-anchor" href="#核心步骤" aria-label="Permalink to “核心步骤”">&#8203;</a></h2>
<h3 id="获取分支名" tabindex="-1">获取分支名 <a class="header-anchor" href="#获取分支名" aria-label="Permalink to “获取分支名”">&#8203;</a></h3>
<p>这个上面介绍了，可以通过<code>git branch --show-current</code>获取</p>
<p>在 <code>shell</code> 里，可以直接将结果存到变量里</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::stqw621wq8t94c67atbse::--><code># bcp.sh
branch=$(git branch --show-current)
echo $branch</code></pre>
</div><p><img src="./copy-branch/MTY5MTMwNDE3MDkzNg==691304170936.png" alt="" loading="lazy"></p>
<p><code>Node.js</code> 里，可以通过<code>child_process</code>模块来执行命令</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::gpz70dtlcejdthgikw7kc::--><code>const { execSync } = require(&#039;child_process&#039;);
const branch = execSync(&#039;git branch --show-current&#039;).toString().trim();
console.log(branch);</code></pre>
</div><p><img src="./copy-branch/MTY5MTMwNDU1NTQ2Nw==691304555467.png" alt="" loading="lazy"></p>
<h3 id="复制到剪贴板" tabindex="-1">复制到剪贴板 <a class="header-anchor" href="#复制到剪贴板" aria-label="Permalink to “复制到剪贴板”">&#8203;</a></h3>
<p>这一块就是调用系统指令执行了，不同操作系统的不一样</p>
<p>之前用过 <a href="https://github.com/xavi-/node-copy-paste#readme" target="_blank" rel="noreferrer">node-copy-paste</a> 这个库</p>
<p>大概介绍了一下各个操作系统所用的指令：MacOS(pbcopy)、Windows(clip)、Linux(xclip)</p>
<p><img src="./copy-branch/MTY5MTMwNDc4MTIwMQ==691304781201.png" alt="" loading="lazy"></p>
<p>这里笔者用的是<code>MacOS</code>，所以直接用<code>pbcopy</code>指令</p>
<p>只需要在上面的基础上加上<code>| pbcopy</code>即可</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::l1pw9h0w3ip2zvveagtyo::--><code>branch=$(git branch --show-current)
echo $branch | pbcopy
# 或
git branch --show-current | pbcopy</code></pre>
</div><p>运行后发现<code>git branch --show-current</code>获取的内容会有换行符，可以通过<code>tr</code>指令去掉</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::mf620m09emc3aqbhnnn8n2::--><code>git branch --show-current | tr -d &#039;\n&#039; | pbcopy</code></pre>
</div><p>Node.js 里，在<code>.trim()</code>后加上<code>.replace(/\n/g, '')</code>即可</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::qqfjnmgpvbcj5cvua0k::--><code>execSync(&#039;git branch --show-current&#039;).toString().trim().replace(/\n/g, &#039;&#039;);</code></pre>
</div><p>不过实际情况下，我们需要将这么长的指令封装起来，方便使用</p>
<p><em>谁没事敲这么多，都可以手动CV好多遍了</em></p>
<h2 id="封装实现" tabindex="-1">封装实现 <a class="header-anchor" href="#封装实现" aria-label="Permalink to “封装实现”">&#8203;</a></h2>
<h3 id="shell" tabindex="-1">Shell <a class="header-anchor" href="#shell" aria-label="Permalink to “Shell”">&#8203;</a></h3>
<p>只需要使用<code>alias</code>指令即可</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::z27g0sv84fabvp8zbutap::--><code>alias bcy=&#039;git branch --show-current | tr -d &quot;\n&quot; | pbcopy&#039;</code></pre>
</div><p>然后将这个指令加入到<code>~/.zshrc</code>或<code>~/.bashrc</code>里即可（可以使用 <code>echo $0</code>确定自己的终端默认的shell执行器）</p>
<p>可运行下面的shell脚本完成自动添加</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::wj4hivizhjdsmfahh22of::--><code>echo &#039;alias bcy=&quot;git branch --show-current | tr -d \&quot;\\n\&quot; | pbcopy&quot;&#039; &gt;&gt; ~/.zshrc</code></pre>
</div><p>重启终端，或者使用<code>source ~/.zshrc</code>使其生效</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::sodtiy276jcq04gt4dm5q::--><code>source ~/.zshrc</code></pre>
</div><p><img src="./copy-branch/MTY5MTMwNzY2OTU1MA==691307669550.png" alt="" loading="lazy"></p>
<p>当然我们也可以打印一些提示信息</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::bgnx5iv2dmf7xi665a9j8k::--><code>alias bcy=&#039;branch=$(git branch --show-current); echo &quot;当前分支：$branch&quot;; echo $branch | tr -d &quot;\n&quot; | pbcopy&#039;</code></pre>
</div><p>对应的安装脚本如下</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::a4mz10sg5281esvcr7bfgz::--><code>echo &quot;alias bcy=&#039;branch=\$(git branch --show-current); echo \&quot;当前分支：\$branch\&quot;; echo \$branch | tr -d \&quot;\\\\n\&quot; | pbcopy&#039;&quot; &gt;&gt; ~/.zshrc</code></pre>
</div><p><img src="./copy-branch/MTY5MTMwODMzMTk2NA==691308331964.png" alt="" loading="lazy"></p>
<p><img src="./copy-branch/MTY5MTMxNzA1MDQ0OA==691317050448.png" alt="" loading="lazy"></p>
<h3 id="node-cli" tabindex="-1">Node CLI <a class="header-anchor" href="#node-cli" aria-label="Permalink to “Node CLI”">&#8203;</a></h3>
<p>上面介绍的是<code>shell</code>里的实现，这里介绍下<code>Node.js</code>里的实现</p>
<p>方便有 Node 环境，但不熟悉Shell的同学使用</p>
<p>脚本也很简单</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::6xkhoxekw2mph6qzndiq4::--><code>#!/usr/bin/env node
const { execSync } = require(&#039;child_process&#039;)
const ncp = require(&#039;copy-paste&#039;)

// 获取当前仓库分支
const branch = execSync(&#039;git branch --show-current&#039;)
  .toString()
  .trim()
  .replace(/\n/g, &#039;&#039;)

console.log(&#039;当前分支:&#039;, branch)

ncp.copy(branch)</code></pre>
</div><p>这个CLI通过npm包发布了，可以直接<code>npx bcy</code>使用</p>
<p>或者 <code>npm i bcy -g</code> 全局安装</p>
<p><img src="./copy-branch/MTY5MTMyMTU1NjY2MQ==691321556661.png" alt="" loading="lazy"></p>
<p><em>包名实在是难取，简单语义化一点的都被占用了，让GPT 辅助了一下</em></p>
<p><img src="./copy-branch/MTY5MTI0NTI4NDAxNQ==691245284015.png" alt="" loading="lazy"></p>
<p>最后用了搜了一圈不重复的只有<code>bcy</code></p>
<h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">&#8203;</a></h2>
<p>本文简单介绍了如何通过<code>Shell</code>和<code>Node.js</code>实现<strong>复制当前分支名到剪贴板</strong></p>
<p>如果你有更好的实现方式，欢迎留言讨论</p>
<p>源码地址：<a href="https://github.com/ATQQ/tools/tree/main/packages/cli/bcy" target="_blank" rel="noreferrer">bcy</a></p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/copy-branch/MTY5MTMxNzA1MDQ0OA==691317050448.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[ESM中使用CJS模块特有的变量和方法]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/esm-require.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/esm-require.html</guid>
            <pubDate>Tue, 09 Jul 2024 16:55:35 GMT</pubDate>
            <description><![CDATA[前言
最近在看 VitePress 的源码时看到了一个`createRequire`方法，如下。
```ts
import { createRequire } from 'module'
const ]]></description>
            <content:encoded><![CDATA[<h1 id="esm中使用cjs模块特有的变量和方法" tabindex="-1">ESM中使用CJS模块特有的变量和方法 <a class="header-anchor" href="#esm中使用cjs模块特有的变量和方法" aria-label="Permalink to “ESM中使用CJS模块特有的变量和方法”">&#8203;</a></h1>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>最近在看 VitePress 的源码时看到了一个<code>createRequire</code>方法，如下。</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::i9vg5gitm48fga5o6r8pw::--><code>import { createRequire } from &#039;module&#039;

const require = createRequire(import.meta.url)
const pkg = require(&#039;vitepress/package.json&#039;)</code></pre>
</div><p>太妙了，ESM里居然可以通过这种方式创建require使用（是之前孤陋寡闻了），之前这种ESM和CJS混用的场景，都是通过构建工具处理的，也没有关心产物最后生成啥样。</p>
<p>下来翻了翻文档发现这个Node v12.2.0 就有了</p>
<p><img src="./esm-require/MTcwMDY2MTUwNDg1Mg==700661504852.png" alt="" loading="lazy"></p>
<p>结合最近开发 VitePress 主题需要ESM中获取 <code>__dirname</code> 的经验，这里就顺便记录一下。</p>
<p><em>毕竟最近 <a href="https://vitejs.dev/blog/announcing-vite5" target="_blank" rel="noreferrer">Vite 5</a> 也出来了，也是推荐使用 ESM 模块</em></p>
<h2 id="先来个demo" tabindex="-1">先来个demo <a class="header-anchor" href="#先来个demo" aria-label="Permalink to “先来个demo”">&#8203;</a></h2>
<p>创建一个<code>test.mjs</code>文件，内容如下</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::d9adeks6owb4wgxyrpubke::--><code>console.log(&#039;__dirname&#039;, __dirname)
console.log(&#039;__filename&#039;, __filename)
console.log(require)</code></pre>
</div><p>执行<code>node test.mjs</code>，你应该会得到如下类似的报错信息</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::j5g1z277lxdb83jnt0pc59::--><code>file:///Users/sugar/Documents/fe/sugar-blog/test.mjs:1
console.log(&#039;__dirname&#039;, __dirname)
                         ^

ReferenceError: __dirname is not defined in ES module scope
    at file:///Users/sugar/Documents/fe/sugar-blog/test.mjs:1:26
    at ModuleJob.run (node:internal/modules/esm/module_job:192:25)

Node.js v20.2.0</code></pre>
</div><p>针对 require 的报错，是下面这样的</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::mubxwkuflvp1o09lrral::--><code>ReferenceError: require is not defined in ES module scope, you can use import instead</code></pre>
</div><p><strong>！ESM 模块中是无法直接使用CJS模块里提供的这些变量的</strong></p>
<h2 id="如何正确获取" tabindex="-1">如何正确获取 <a class="header-anchor" href="#如何正确获取" aria-label="Permalink to “如何正确获取”">&#8203;</a></h2>
<h3 id="dirname和-filename" tabindex="-1"><code>__dirname</code>和<code>__filename</code> <a class="header-anchor" href="#dirname和-filename" aria-label="Permalink to “__dirname和__filename”">&#8203;</a></h3>
<p>在 ESM 中可以通过<code>import.meta.url</code> 获取到类似 <code>__filename</code> 的值</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::8q39r2e7pp8h811wnap89::--><code>console.log(import.meta.url)</code></pre>
</div><p>执行后你会得到如下结果</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::se1c91v7jdtjwdmlksvj9::--><code>file:///Users/sugar/Documents/fe/sugar-blog/test.mjs</code></pre>
</div><blockquote>
<p><em>其中 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/import.meta" target="_blank" rel="noreferrer">import.meta</a> 是一个给 JavaScript 模块暴露特定上下文的元数据属性的对象。它包含了这个模块的信息，比如说这个模块的 URL</em></p>
</blockquote>
<p>此时我们可再通过<code>url</code>模块上的<code>fileURLToPath</code>方法将其转换为<code>__filename</code>的值</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::kj2laf1z8tkkaumpge4nn::--><code>import { fileURLToPath } from &#039;url&#039;

const __filename = fileURLToPath(import.meta.url)

console.log(&#039;__filename&#039;, __filename)
// __filename /Users/sugar/Documents/fe/sugar-blog/test.mjs</code></pre>
</div><p>有了<code>__filename</code>，我们就可以通过<code>path</code>模块的<code>dirname</code>方法获取到<code>__dirname</code>的值了</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::eqeg6pisngten1z4j348w7::--><code>import { dirname } from &#039;path&#039;

const __dirname = dirname(__filename)

console.log(&#039;__dirname&#039;, __dirname)
// __dirname /Users/sugar/Documents/fe/sugar-blog</code></pre>
</div><h3 id="require" tabindex="-1">require <a class="header-anchor" href="#require" aria-label="Permalink to “require”">&#8203;</a></h3>
<p>这个就是文章开头部分使用<code>createRequire</code>的场景了，我们可以通过<code>createRequire</code>方法创建一个<code>require</code>方法，然后就可以愉快的使用<code>require</code>了。</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::jizo37xq4vxzkddhl25m::--><code>import { createRequire } from &#039;module&#039;

const require = createRequire(import.meta.url)

console.log(require(&#039;./package.json&#039;).name)</code></pre>
</div><h3 id="完整代码" tabindex="-1">完整代码 <a class="header-anchor" href="#完整代码" aria-label="Permalink to “完整代码”">&#8203;</a></h3>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::h0lmvav714hmyvj67gjtr::--><code>import { fileURLToPath } from &#039;url&#039;
import { dirname } from &#039;path&#039;
import { createRequire } from &#039;module&#039;

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

console.log(&#039;__filename&#039;, __filename)
console.log(&#039;__dirname&#039;, __dirname)

const require = createRequire(import.meta.url)
console.log(&#039;name&#039;, require(&#039;./package.json&#039;).name)</code></pre>
</div><h3 id="解决的实际问题" tabindex="-1">解决的实际问题 <a class="header-anchor" href="#解决的实际问题" aria-label="Permalink to “解决的实际问题”">&#8203;</a></h3>
<p>在编写 Vite 插件时，想动态注入一个 alias 规则，编译的产物分别有cjs和esm的，在源码中编写需要兼容这2个场景</p>
<p>于是就有了如下代码</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::87oz2lsifswu7u0mj2iu::--><code>function isESM() {
  return typeof __filename === &#039;undefined&#039; || typeof __dirname === &#039;undefined&#039;
}
function getDirname() {
  return isESM() ? path.dirname(fileURLToPath(import.meta.url)) : __dirname
}

const aliasSearchVueFile = `${getDirname()}/../src/Search.vue`

const resolveAlias = {
  &#039;./VPNavBarSearch.vue&#039;: aliasSearchVueFile,
}</code></pre>
</div><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">&#8203;</a></h2>
<p>综上，在 ESM 中也是可以优雅的使用CJS里的<code>require</code>, <code>__dirname</code>, <code>__filename</code> 的</p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/esm-require/MTcwMDY2MTUwNDg1Mg==700661504852.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[纯前端实现 JPG 图片压缩 | canvas]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/jpg-compress.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/jpg-compress.html</guid>
            <pubDate>Tue, 09 Jul 2024 16:55:35 GMT</pubDate>
            <description><![CDATA[在迭代图床应用时，需要用到图片压缩，在之前分享了使用UPNG.js 处理 PNG 图片，这里记录分享一下如何处理JPG图片，并附上完整 Demo。]]></description>
            <content:encoded><![CDATA[<h1 id="纯前端实现-jpg-图片压缩-canvas" tabindex="-1">纯前端实现 JPG 图片压缩 | canvas <a class="header-anchor" href="#纯前端实现-jpg-图片压缩-canvas" aria-label="Permalink to “纯前端实现 JPG 图片压缩 | canvas”">&#8203;</a></h1>
<blockquote>
<p><strong>在线 Demo 体验地址 →:</strong> <a href="https://demos.sugarat.top/pages/jpg-compress/" target="_blank" rel="noreferrer">https://demos.sugarat.top/pages/jpg-compress/</a></p>
</blockquote>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>在迭代图床应用时，需要用到图片压缩，在之前分享了<a href="https://juejin.cn/post/7346510823772733494" target="_blank" rel="noreferrer">使用 UPNG.js 压缩 PNG 图片</a>，这里记录分享一下如何处理 JPG 图片。</p>
<p>搜罗调研了一圈，JPG 图片的处理，基本都是围绕 canvas 展开的。</p>
<ul>
<li><a href="https://juejin.cn/post/7311633278497685544" target="_blank" rel="noreferrer">掘金：前端实现图片压缩技术调研</a></li>
<li>相关开源库（近期还有迭代维护的）：<a href="https://github.com/fengyuanchen/compressorjs" target="_blank" rel="noreferrer">Compressor.js</a>，<a href="https://github.com/Donaldcwl/browser-image-compression" target="_blank" rel="noreferrer">browser-image-compression</a>。</li>
</ul>
<h2 id="如何判断图片是-jpg" tabindex="-1">如何判断图片是 JPG <a class="header-anchor" href="#如何判断图片是-jpg" aria-label="Permalink to “如何判断图片是 JPG”">&#8203;</a></h2>
<p>同样第一步当然是判断图片类型，不然就没法正常的做后续处理了。</p>
<p>搜索了解了一下，JPG 图片的前三字节是固定的（16进制表示）：<code>FF D8 FF</code>。</p>
<p>下图是 VS Code 插件 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.hexeditor" target="_blank" rel="noreferrer">Hex Editor</a> 查看一个 JPG 图片的 16 进制表示信息。</p>
<p><img src="./jpg-compress/bcba46c1cd96ae55e93d5306796cd98c.png" alt="" loading="lazy"></p>
<p>于是可以根据这个特性判断，于是就有如下的判断代码。</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::51cfkfcuvo5ixvi0vdimk::--><code>function isJPG(file) {
  // 提取前3个字节
  const arraybuffer = await file.slice(0, 3).arrayBuffer()

  // JPG 的前3字节16进制表示
  const signature = [0xFF, 0xD8, 0xFF]
  // 转为 8位无符号整数数组 方便对比
  // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array
  const source = new Uint8Array(arraybuffer)

  // 逐个字节对比
  return source.every((value, index) =&gt; value === signature[index])
}</code></pre>
</div><p>当然社区也有现成的 <a href="https://github.com/sindresorhus/is-jpg" target="_blank" rel="noreferrer">is-jpg</a> 库可以使用。</p>
<p><img src="./jpg-compress/522312911d91522d3217c11765363f85.png" alt="" loading="lazy"></p>
<p><em>可看判断代码还是很简单的。</em></p>
<p>下面将先介绍一下上述两个开源库的简单用法与特色，最后再介绍一下直接使用 <code>canvas API</code> 压缩的方式以及注意事项。</p>
<h2 id="compressor-js" tabindex="-1"><a href="https://github.com/fengyuanchen/compressorjs" target="_blank" rel="noreferrer">Compressor.js</a> <a class="header-anchor" href="#compressor-js" aria-label="Permalink to “Compressor.js”">&#8203;</a></h2>
<h3 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to “简介”">&#8203;</a></h3>
<blockquote>
<p>JavaScript 图像压缩工具。使用浏览器原生的 <code>canvas.toBlob API</code> 实现压缩，<code>有损压缩</code>，<code>异步</code>，在不同的浏览器压缩效果有所出入。一般可以用来在上传之前在客户端预压缩图像。</p>
</blockquote>
<p>官方示例站点：<a href="https://fengyuanchen.github.io/compressorjs/" target="_blank" rel="noreferrer">Compressor.js PlayGround</a></p>
<p><img src="./jpg-compress/582a9d9e73a1274fa8e7aae2d7022aa3.png" alt="" loading="lazy"></p>
<h3 id="使用" tabindex="-1">使用 <a class="header-anchor" href="#使用" aria-label="Permalink to “使用”">&#8203;</a></h3>
<p>支持 <code>npm</code> 和 <code>cdn</code> 两种引入方式。</p>
<p><strong>npm 加载</strong></p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::dzk60tt1mnpls6qrnkyh78::--><code># 安装依赖
npm install compressorjs</code></pre>
</div><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::sbsxppsh2ly0no8rvmib::--><code>// 项目中引入使用
import Compressor from &#039;compressorjs&#039;</code></pre>
</div><p><strong>cdn 加载</strong></p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::2au6x3nwevjbqcvwueb3b9::--><code>&lt;!-- html head 中引入 --&gt;
&lt;script src=&#039;https://cdn.staticfile.net/compressorjs/1.2.1/compressor.min.js&#039;&gt;&lt;/script&gt;
&lt;!-- 项目中直接使用 Compressor 即可 --&gt;</code></pre>
</div><p>简单使用方式如下</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::tid2efjj7er79w65ls77i::--><code>// file 是待压缩图片的文件对象
new Compressor(file, {
  quality: 0.8,
  success(result) {
    // result 是压缩后的图片内容
  }
})</code></pre>
</div><p>其余的 <a href="https://github.com/fengyuanchen/compressorjs?tab=readme-ov-file#options" target="_blank" rel="noreferrer">option 选项</a>可以参考官方文档，主要是尺寸大小，压缩质量效果，图片信息的保留等细节的调节。</p>
<h3 id="简单封装" tabindex="-1">简单封装 <a class="header-anchor" href="#简单封装" aria-label="Permalink to “简单封装”">&#8203;</a></h3>
<p>可以简单用 <code>Promise</code> 封装一下，使用更加方便。</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::dzpgzfwqoujwwo6ewma1oj::--><code>async function compressJPGByCompressor(file, ops) {
  return new Promise((resolve, reject) =&gt; {
    new Compressor(file, {
      ...ops,
      success(result) {
        resolve(result)
      },
      error(err) {
        reject(err)
      }
    })
  })
}</code></pre>
</div><p>当然这种不支持 <code>Promise</code> 的回调用法函数用 <a href="https://github.com/tc39/proposal-promise-with-resolvers" target="_blank" rel="noreferrer">Promise.withResolvers</a> 包装最合适不过了。</p>
<p><em>当然浏览器不支持这个API的话 需要引入 <code>polyfill</code> 才行（可以从 <code>core-js</code> 中引入，或自己简单实现一下）。</em></p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::qnfwa8k79ryx0vrkfbl4r::--><code>function compressJPGByCompressor(file, ops) {
  const { promise, resolve, reject } = Promise.withResolvers()
  new Compressor(file, {
    ...ops,
    success(result) {
      resolve(result)
    },
    error(err) {
      reject(err)
    }
  })
  return promise
}</code></pre>
</div><h2 id="browser-image-compression" tabindex="-1"><a href="https://github.com/Donaldcwl/browser-image-compression" target="_blank" rel="noreferrer">browser-image-compression</a> <a class="header-anchor" href="#browser-image-compression" aria-label="Permalink to “browser-image-compression”">&#8203;</a></h2>
<h3 id="简介-1" tabindex="-1">简介 <a class="header-anchor" href="#简介-1" aria-label="Permalink to “简介”">&#8203;</a></h3>
<blockquote>
<p>浏览器中实现图片压缩，通过降低分辨率或大小来压缩 jpeg、png、webp 和 bmp 图像；支持使用 Web Worker 实现多线程的非阻塞压缩。</p>
</blockquote>
<p>官方示例站点：<a href="https://donaldcwl.github.io/browser-image-compression/example/basic.html" target="_blank" rel="noreferrer">compression PlayGround</a></p>
<p><img src="./jpg-compress/3619ac65a3399e4b8e1928bb4e2c28a2.png" alt="" loading="lazy"></p>
<p>其中多线程压缩使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas#browser_compatibility" target="_blank" rel="noreferrer">OffscreenCanvas</a>: 一个可以脱离屏幕渲染的 canvas 对象。在 <code>web worker</code> 环境也可工作。</p>
<h3 id="使用-1" tabindex="-1">使用 <a class="header-anchor" href="#使用-1" aria-label="Permalink to “使用”">&#8203;</a></h3>
<p>同样的也支持 <code>npm</code> 和 <code>cdn</code> 两种引入方式。</p>
<p><strong>npm 加载</strong></p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::szw6srkrrbf89dkw7jx9n4::--><code># 安装依赖
npm install browser-image-compression</code></pre>
</div><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::lqzytg6y2ue96oeqjrn58::--><code>// 项目中引入使用
import imageCompression from &#039;browser-image-compression&#039;</code></pre>
</div><p><strong>cdn 加载</strong></p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::i334s7szycpbthj9hkyp57::--><code>&lt;!-- html head 中引入 --&gt;
&lt;script src=&quot;https://cdn.staticfile.net/browser-image-compression/2.0.2/browser-image-compression.min.js&quot;&gt;&lt;/script&gt;
&lt;!-- 项目中直接使用 imageCompression 即可 --&gt;</code></pre>
</div><p>简单使用方式如下</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::z23d9uwbauqyuq4zlwio::--><code>imageCompression(file, {
  // 设置压缩后的最大大小，单位是 MB（会根据目标自动调整图片质量或者尺寸）
  maxSizeMB: 1,

  // 如果希望通过百分比控制质量，只需简单计算一下即可
  // maxSizeMB: Math.round(file.size / (1024 * 1024) * quality),

  // 也可设置压缩后最大的宽或者高 （自动应用于图片中较长的那一边）
  // maxWidthOrHeight: 1920,
}).then((result) =&gt; {
  // result 为压缩后的结果
})</code></pre>
</div><p>可以看出来使用非常简单:</p>
<ul>
<li>调整尺寸就使用 <code>maxWidthOrHeight</code>;</li>
<li>保持原尺寸就调整 <code>maxSizeMB</code> 的值。</li>
</ul>
<h3 id="简单封装-1" tabindex="-1">简单封装 <a class="header-anchor" href="#简单封装-1" aria-label="Permalink to “简单封装”">&#8203;</a></h3>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::dnpkuu7tnnr1tzhiddf6ohj::--><code>function compressImageByImageCompression(file, options = {}) {
  const { width, height, quality = 0.8, ...ops } = options
  return window.imageCompression(file, {
    maxSizeMB: Math.round(file.size / (1024 * 1024) * quality),
    maxWidthOrHeight: width || height || undefined,
    libURL: &#039;https://cdn.staticfile.net/browser-image-compression/2.0.2/browser-image-compression.js&#039;,
    ...ops
  })
}</code></pre>
</div><p>这样调用起来更加方便灵活。</p>
<h3 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to “注意事项”">&#8203;</a></h3>
<p>默认是开启的多线程压缩，会从 <code>https://cdn.jsdelivr.net</code> 拉取 worker 脚本。</p>
<p>如果存在网络原因访问不通畅，可以通过 <code>options.libURL</code> 替换为自定义的脚本位置，比如使用 <a href="https://www.staticfile.org/" target="_blank" rel="noreferrer">Staticfile CDN</a> 资源。</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::hhfdnx78k3r2rv8uurr9rv::--><code>imageCompression(file, {
  // ...省略其它配置
  libURL: &#039;https://cdn.staticfile.net/browser-image-compression/2.0.2/browser-image-compression.js&#039;
})</code></pre>
</div><h2 id="canvas-api" tabindex="-1">canvas api <a class="header-anchor" href="#canvas-api" aria-label="Permalink to “canvas api”">&#8203;</a></h2>
<p>主流的 JPG 纯前端压缩方案，基本都是借助 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" target="_blank" rel="noreferrer">canvas</a> 实现的，区别就在于边界场景是否考虑周全，配套的特性能否满足将使用的场景。</p>
<h3 id="使用-2" tabindex="-1">使用 <a class="header-anchor" href="#使用-2" aria-label="Permalink to “使用”">&#8203;</a></h3>
<p>先创建 <code>Image</code> 对象，获取图片的基本信息</p>
<p>下面是使用 <code>URL.createObjectURL</code> 创建资源链接的方式：</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::99yx7jkb3z6yt1fj75lp57::--><code>const img = new Image()
// 图片完成加载
img.onload = () =&gt; {
  // 获取图片宽高
  const { width, height } = img
  // 后续就可以使用 canvas 进行进一步的压缩处理
}

img.src = URL.createObjectURL(file)</code></pre>
</div><p>当然这里也可以用 <code>FileReader</code>，此时代码看上去多2行（hhh）</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::wz1wtk5hk8dly8d08ajfe::--><code>const reader = new FileReader()
reader.readAsDataURL(file)
reader.onload = function (event) {
  img.src = event.target.result
}</code></pre>
</div><p>紧接着就可以使用 <code>canvas</code> 进行图像的绘制（img 完成加载后）</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::xfc9og6fzdb8b7g0mlanc9::--><code>// 创建 canvas 元素
const canvas = document.createElement(&#039;canvas&#039;)
// 获取画布的2D渲染上下文
const ctx = canvas.getContext(&#039;2d&#039;)

// 设置 canvas 的宽高与图片一致
canvas.width = img.width
canvas.height = img.height

// 在 canvas 上绘制图片（待绘制的图片，画布上的起始坐标，绘制的宽高）
ctx.drawImage(img, 0, 0, canvas.width, canvas.height)

// 如果把元素插入到页面中，则可以看到 canvas 绘制的图片
// document.body.appendChild(canvas);</code></pre>
</div><p>接下来最核心的就行调用 <code>canvas.toDataURL(type, quality)</code> 进行&quot;压缩&quot;了。</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::feyfqppxefhgxgrpkcp83::--><code>// 只需要设置图片格式，与图片质量 两个参数即可
const compressedDataUrl = canvas.toDataURL(&#039;image/jpeg&#039;, 0.8)</code></pre>
</div><p>接下来就需要将 <code>compressedDataUrl</code> 转化为 <code>blob</code> 或者 <code>file</code> 对象。</p>
<p><code>DataUrl</code> 格式如下。</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::oqyxwhg5ror7c1hj8t3or9::--><code>data:image/jpeg;base64,XXXX
# 数据标识符：以&quot;data:&quot;开头
# MIME类型描述：指示数据的类型，&quot;image/jpeg&quot;表示JPEG图像
# 数据编码：以base64编码表示，&quot;XXXX&quot;是 base64 编码数据部分</code></pre>
</div><p>咱们先把<code>mimetype</code>,<code>decodedData</code> 这 2 部分提取出来</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::gsfupnhiz49ih87bz2a0vm::--><code>const [dataDescription, base64Data] = compressedDataUrl.split(&#039;,&#039;)
// 文件类型
const mimetype = dataDescription.match(/:(.*?);/)[1]

// 解码 base64 数据
const decodedData = atob(base64Data)</code></pre>
</div><p>最后将解码的 <code>base64</code> 数据转成 <code>file</code> 即可。</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::cgel6j723dweotfimhoq::--><code>let n = decodedData.length
// 创建等字节大小的 Uint8Array
const u8arr = new Uint8Array(n)

// 遍历赋值
while (n--) {
  u8arr[n] = decodedData.charCodeAt(n)
}

// 通过 Uint8Array 创建 File 对象
const result = new File([u8arr], file.name, { type: mimetype })</code></pre>
</div><h3 id="简单封装-2" tabindex="-1">简单封装 <a class="header-anchor" href="#简单封装-2" aria-label="Permalink to “简单封装”">&#8203;</a></h3>
<p>完整代码如下：</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::7ohvvbchm13tl66ldk9wgg::--><code>async function compressImageByCanvas(file, options = {}) {
  const { quality } = options
  let { width, height } = options

  let _resolve, _reject
  const promise = new Promise((resolve, reject) =&gt; {
    _resolve = resolve
    _reject = reject
  })

  const img = new Image()
  img.onload = function () {
    // 如果只指定了宽度或高度，则另一个按比例缩放
    if (width &amp;&amp; !height) {
      height = Math.round(img.height * (width / img.width))
    }
    else if (!width &amp;&amp; height) {
      width = Math.round(img.width * (height / img.height))
    }

    const canvas = document.createElement(&#039;canvas&#039;)
    const ctx = canvas.getContext(&#039;2d&#039;)
    canvas.width = width || img.width
    canvas.height = height || img.height
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height)
    const compressedDataUrl = canvas.toDataURL(&#039;image/jpeg&#039;, quality)
    _resolve(dataURItoFile(compressedDataUrl, file.name))
  }

  img.src = createObjectURL(file)
  return promise
}

function dataURItoFile(dataURI, fileName) {
  const [dataDescription, base64Data] = dataURI.split(&#039;,&#039;)
  const mimetype = dataDescription.match(/:(.*?);/)[1]
  const decodedData = atob(base64Data)

  let n = decodedData.length
  const u8arr = new Uint8Array(n)

  while (n--) {
    u8arr[n] = decodedData.charCodeAt(n)
  }

  return new File([u8arr], fileName, { type: mimetype })
}</code></pre>
</div><h3 id="兼容性问题" tabindex="-1">兼容性问题 <a class="header-anchor" href="#兼容性问题" aria-label="Permalink to “兼容性问题”">&#8203;</a></h3>
<p>笔者并没有深入测试 canvas 压缩的兼容性问题，但从社区的几个前端处理 JPG 库里的 README 描述与 issues 等可以归纳出使用 <code>canvas</code> 处理时，需考虑下面几个方面的问题：</p>
<ol>
<li>大小限制：详见 <a href="https://jhildenbiddle.github.io/canvas-size/#/?id=test-results" target="_blank" rel="noreferrer">不同浏览器和设备上 canvas 大小限制</a>；</li>
<li>信息保留：<code>EXIF</code> 信息，正确识别与处理图片方向；</li>
<li>设备兼容性：移动端设备浏览器定制内核相对多, 边界情况较多（相关 API 的支持程度，canvas 差异性表现）。</li>
</ol>
<p><em>参考：<code>browser-image-compression</code>, <code>Compressor.js</code>, <a href="https://github.com/think2011/localResizeIMG" target="_blank" rel="noreferrer">localResizeIMG</a></em></p>
<h2 id="完整-demo" tabindex="-1">完整 demo <a class="header-anchor" href="#完整-demo" aria-label="Permalink to “完整 demo”">&#8203;</a></h2>
<p>笔者将本节内容整理成了一个 Demo，可以直接在线体验。</p>
<blockquote>
<p><strong>在线 Demo 体验地址 →:</strong> <a href="https://demos.sugarat.top/pages/jpg-compress/" target="_blank" rel="noreferrer">https://demos.sugarat.top/pages/jpg-compress/</a></p>
</blockquote>
<p>大概界面如下（可修改配置切换压缩方案，对比效果）：</p>
<p><img src="./jpg-compress/736ac7e7771d2a948845e1fe0d0fa40f.png" alt="" loading="lazy"></p>
<p><em>纯血 HTML/CSS/JS，复制粘贴就能运行。</em></p>
<p>完整源码见：<a href="https://github.com/ATQQ/demos/tree/main/pages/png-compress" target="_blank" rel="noreferrer">GitHub:ATQQ/demos - jpg-compress</a></p>
<h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>后续将继续学习&amp;探索一下 <code>GIF</code>，<code>MP4 转 GIF</code> 等常用的动图前端处理实现的方式。</p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/jpg-compress/bcba46c1cd96ae55e93d5306796cd98c.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[小程序中使用 lottie 动画 | 踩坑经验分享]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/mini-lottie.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/mini-lottie.html</guid>
            <pubDate>Tue, 09 Jul 2024 16:55:35 GMT</pubDate>
            <description><![CDATA[记录分享在小程序中使用 lottie 播放AE动画的方法，以及踩坑经验。]]></description>
            <content:encoded><![CDATA[<h1 id="小程序中使用-lottie-动画-踩坑经验分享" tabindex="-1">小程序中使用 lottie 动画 | 踩坑经验分享 <a class="header-anchor" href="#小程序中使用-lottie-动画-踩坑经验分享" aria-label="Permalink to “小程序中使用 lottie 动画 | 踩坑经验分享”">&#8203;</a></h1>
<p>本周被拉去支援紧急需求（赶在五一节假日前上线的，双休需要加班😱），参与到项目中才知道，开发的项目是微信小程序技术栈的。由于是临时支援，笔者也很久没开发过微信小程序了，所以挑选了相对独立，业务属性相对轻薄的模块参与。</p>
<p>其中有个营销活动（领红包🧧😁）的弹窗动画就要用到 lottie 动画。</p>
<p>本文就分享一下在小程序中使用 lottie 过程中遇到的问题与解决办法。</p>
<h2 id="关于-lottie" tabindex="-1">关于 lottie <a class="header-anchor" href="#关于-lottie" aria-label="Permalink to “关于 lottie”">&#8203;</a></h2>
<p><a href="https://airbnb.io/lottie/#/README" target="_blank" rel="noreferrer">lottie</a> 是 Airbnb 开源的一个动画库，用于在端上直接播放 AE ( Adobe After Effects)动画。</p>
<p>通过 <a href="https://github.com/airbnb/lottie-web/tree/master/build/extension" target="_blank" rel="noreferrer">bodymovin</a> AE 插件将动画文件导出为 json 文件，lottie SDK 通过可以通过 JSON 文件直接播放动画。</p>
<p>具体 demos 效果可以上 <a href="https://lottiefiles.com/" target="_blank" rel="noreferrer">LottieFiles</a> 网站查看。</p>
<h2 id="如何使用-ae-导出动画需要的json文件" tabindex="-1">如何使用 AE 导出动画需要的JSON文件 <a class="header-anchor" href="#如何使用-ae-导出动画需要的json文件" aria-label="Permalink to “如何使用 AE 导出动画需要的JSON文件”">&#8203;</a></h2>
<p>完成 AE 软件安装后，参照 <a href="https://github.com/airbnb/lottie-web/tree/master?tab=readme-ov-file#plugin-installation" target="_blank" rel="noreferrer">Lottie Web GitHub 官方文档</a> 完成 <code>bodymovin</code> 插件的安装。</p>
<p>打开动画文件后，只需简单几步操作</p>
<p>① window 中选择 Bodymovie</p>
<p><img src="./mini-lottie/e887b3af9200905af6a3484300de1d3b.png" alt="" loading="lazy"></p>
<p>② 选择需要导出的动画资源</p>
<p><img src="./mini-lottie/ddb3ce4d7c88df65ee50cca915817fa7.png" alt="" loading="lazy"></p>
<p>③ 导出配置（小程序相关）</p>
<p>点击对应动画的设置</p>
<p><img src="./mini-lottie/e8a6dfc08dd521ccf65cf2c003c00aac.png" alt="" loading="lazy"></p>
<p>勾选 <code>Glyphs</code> 将用到的文字+字体导出为图形。</p>
<p>小程序里渲染不支持加载外部字体。</p>
<p><img src="./mini-lottie/fab7f7d9ca8aafd9f7935afdb0d91b74.png" alt="" loading="lazy"></p>
<p><em>这个就会有 tree shake的效果，如果动画里没有用到的文字，做动态替换的时候就会不显示，后面会详细介绍到</em>。</p>
<p>勾选 <code>Convert expressions to keyframes</code> 将表达式转为关键帧，因为小程序里不支持使用 <code>eval</code> 等动态执行脚本的能力。</p>
<p><img src="./mini-lottie/ca9d49f12f786b36cb1699958a56421e.png" alt="" loading="lazy"></p>
<p>修改完成后点击<code>Save</code>保存配置。</p>
<p>④ 渲染导出 JSON 文件</p>
<p>最后点击 Render 按钮，导出 JSON 文件。</p>
<p><img src="./mini-lottie/e4e147a1d4a9a79b8d19f09bfc402bc0.png" alt="" loading="lazy"></p>
<p>导出文件如下，data.json 文件就是我们需要的 JSON 文件，images 里存储的就是播放要用到的图片文件。</p>
<p><img src="./mini-lottie/58abc6bc9d72ed6d4ff078b58ab2dbaf.png" alt="" loading="lazy"></p>
<h2 id="小程序中使用" tabindex="-1">小程序中使用 <a class="header-anchor" href="#小程序中使用" aria-label="Permalink to “小程序中使用”">&#8203;</a></h2>
<p>可以使用小程序官方封装的 <a href="https://github.com/wechat-miniprogram/lottie-miniprogram" target="_blank" rel="noreferrer">lottie-miniprogram</a> 库。</p>
<blockquote>
<p>快速验证的话可以打开微信开发者工具，在点击👉🏻 <a href="https://developers.weixin.qq.com/s/2TYvm9mJ75bF" target="_blank" rel="noreferrer">demo代码片段</a> 进行创建。</p>
</blockquote>
<p>① 安装依赖</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::luuk6m0b6c8uamvlvdw8xf::--><code>npm install --save lottie-miniprogram</code></pre>
</div><p>② 使用</p>
<p><strong>tip：开发者工具中验证的话，渲染模式需要选择 webview ，<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html" target="_blank" rel="noreferrer">Skyline</a> 目前还不支持调试 canvas</strong></p>
<p>index.wxml</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::zys3k30q5387tzkewq6wj8::--><code>&lt;canvas id=&quot;lottie-canvas&quot; type=&quot;2d&quot;&gt;&lt;/canvas&gt;</code></pre>
</div><p>index.js</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::duyeo64sm4u6mljglygop8::--><code>import lottie from &#039;lottie-miniprogram&#039;

Page({
  onReady() {
    this.createSelectorQuery().select(&#039;#lottie-canvas&#039;).node((res) =&gt; {
      // 取得 canvas 节点
      const canvas = res[0].node

      // 设置 cavnas 画布尺寸
      canvas.width = 600
      canvas.height = 600

      lottie.setup(canvas)

      const context = canvas.getContext(&#039;2d&#039;)
      const lottieInstance = lottie.loadAnimation({
        loop: true, // 循环播放
        autoplay: true, // 自动播放
        // 本地使用 http-server 启动服务后，指定本地资源地址
        path: &#039;http://127.0.0.1:8080/lottie-demo-sources/data.json&#039;, // 通过http 制定json资源路径

        // 也可以用下面这种方式，直接传入 lottie json内容
        // (需要动态替换文案就需要用到这种方式)
        // animationData: {/* lottie json 格式内容 */},
        // 静态资源目录，通常与 animationData 配合使用
        // assetsPath: &#039;http://127.0.0.1:8080/lottie-demo-sources/images/&#039;,

        rendererSettings: {
          context,
        },
      })
    }).exec()
  }
})</code></pre>
</div><p>我这个 demo 的效果（网上找的动画素材）如下。</p>
<p><img src="./mini-lottie/fe89db8f5a79940b2c2167062f1b321f.png" alt="" loading="lazy"></p>
<h2 id="问题-解决" tabindex="-1">问题&amp;解决 <a class="header-anchor" href="#问题-解决" aria-label="Permalink to “问题&amp;解决”">&#8203;</a></h2>
<p>下面介绍在实际业务接入使用中遇到的一些问题和解决办法。</p>
<h3 id="expression-表达式" tabindex="-1">expression 表达式 <a class="header-anchor" href="#expression-表达式" aria-label="Permalink to “expression 表达式”">&#8203;</a></h3>
<p>报错信息如下，这是遇到的第一个问题（也是上面导出配置中有特别说明的）。</p>
<p><img src="./mini-lottie/63b1e8a0370b0ffdd017de7ceb918465.png" alt="" loading="lazy"></p>
<p>细看了一下文档，有特别说明，expression 表达式特性是不支持的，因此需要再导出 JSON 文件时禁用相关特性。</p>
<p><img src="./mini-lottie/c8f32eb3368a511c84cf1e7803687d5c.png" alt="" loading="lazy"></p>
<p>解决办法：导出JSON文件时，禁用掉表达式特性即可。</p>
<p><img src="./mini-lottie/60104c2927d61dcb75be50fbd363f45d.png" alt="" loading="lazy"></p>
<p>当然禁用后，JSON 文件大小会有所增加。</p>
<p>比如我这个 demo 从 40kb 增加到了 240kb（当然动画不一样，增长的大小会有所不同。有些前后可能只有1-2kb的变化）。</p>
<h3 id="模糊" tabindex="-1">模糊 <a class="header-anchor" href="#模糊" aria-label="Permalink to “模糊”">&#8203;</a></h3>
<p>由于需要全屏展示，动画文件的尺寸不确定，手动只设置 canvas 尺寸会有模糊的问题。</p>
<p>这个通过掘金搜索了一下就得到了 <a href="https://juejin.cn/post/7171273016762974216#heading-7" target="_blank" rel="noreferrer">lottie动画模糊问题的解决方法</a>。</p>
<p>微调一下上面的代码，就可以解决模糊问题。</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::f1syln5ig1fkp1mmdu8h1j::--><code>const canvas = res[0].node
canvas.width = 600
canvas.height = 600

// 下面是新增的代码
const dpr = wx.getSystemInfoSync().pixelRatio
canvas.width = canvas.width * dpr
canvas.height = canvas.height * dpr
context.scale(dpr, dpr)

lottie.setup(canvas)</code></pre>
</div><h3 id="全屏动画" tabindex="-1">全屏动画 <a class="header-anchor" href="#全屏动画" aria-label="Permalink to “全屏动画”">&#8203;</a></h3>
<p>弹窗的动画需要全屏展示，因此需要设置 <code>canvas</code> 宽高为页面宽高。</p>
<p>index.wxss</p>
<div class="language-css"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre><!--::markdown-it-async::vqaejaxz9zu5c776kijtl::--><code>#lottie-canvas{
    position: fixed;
    left: 0;
    top: 0;
    width: 100vw;
    height: 100vh;
}</code></pre>
</div><p>index.js，使用 <code>wx.getSystemInfoSync</code> 获取设备的信息</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::cypfokke2ncsvzm8k0gse::--><code>const { windowWidth, windowHeight, pixelRatio } = wx.getSystemInfoSync()
canvas.width = windowWidth * pixelRatio
canvas.height = windowHeight * pixelRatio</code></pre>
</div><p><img src="./mini-lottie/3dd8a0483aba8a07d9a85692197e5ce5.png" alt="" loading="lazy"></p>
<h3 id="动态文案" tabindex="-1">动态文案 <a class="header-anchor" href="#动态文案" aria-label="Permalink to “动态文案”">&#8203;</a></h3>
<p>由于是红包，需要动态展示金额（当然也可能是不固定内容的动态标题）。</p>
<p>思路可以参考这篇文章<a href="https://zhuanlan.zhihu.com/p/102334701?s_r=0" target="_blank" rel="noreferrer">知乎： 动态修改 Lottie 中的文本</a></p>
<p>可以使用固定格式的文本 <code>${文本}</code> 进行替换</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::5onnhwz0qsabnzvv50gr7k::--><code>// 伪代码
get(&#039;sourceUrl&#039;).then((res) =&gt; {
  const jsonText = res.data
  const animationData = JSON.parse(jsonText.replace(&#039;${金额}&#039;, &#039;目标金额&#039;))
})</code></pre>
</div><p>比如我在 demo 里加一个文字</p>
<ul>
<li>需要展示的文本里放入 <code>${num}</code> 用于替换匹配</li>
<li>在添加一个文本藏在看不见的地方,里面写入替换后需要用到的文字（确保和上面的文本为同一种字体）</li>
</ul>
<p><img src="./mini-lottie/f2bd93aa21e7cd2328c987948d4557a7.png" alt="" loading="lazy"></p>
<p>接着导出 JSON 文件。</p>
<p>调用方法如下</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::5q0esotnlcyosy3lr3i4d7::--><code>// 拉取JSON文件内容
const jsonData = await new Promise((resolve) =&gt; {
  wx.request({
    url: &#039;http://127.0.0.1:8080/json/text-replace/data.json&#039;,
    success: (res) =&gt; {
      resolve(res.data)
    }
  })
})

// 随机生成1-100元的数字，保留两位小数
const num = (Math.random() * 100).toFixed(2)
// 替换内容
const animationData = JSON.parse(
  JSON.stringify(jsonData)
    .replace(/\$\{num\}/g, `${num}元`)
)

lottie.loadAnimation({
  // 指定json内容
  animationData,
  // 设置依赖的图片资源位置
  assetsPath: &#039;http://127.0.0.1:8080/json/text-replace/images/&#039;,
  // ...省略其它配置
})</code></pre>
</div><p>效果如下</p>
<p><img src="./mini-lottie/290fee264246526131c5048c67125711.png" alt="" loading="lazy"></p>
<h3 id="style-引发的渲染错误" tabindex="-1">style 引发的渲染错误 <a class="header-anchor" href="#style-引发的渲染错误" aria-label="Permalink to “style 引发的渲染错误”">&#8203;</a></h3>
<p>在 canvas 标签上设置 <code>display</code>控制显隐，偶现会提示渲染层错误。</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::nz3x9qm2otn1g5qgeb31mk::--><code>&lt;canvas style=&quot;display:{{show?&#039;block&#039;:&#039;none&#039;}}&quot; id=&quot;c1&quot; type=&quot;2d&quot;&gt;&lt;/canvas&gt;</code></pre>
</div><p><img src="./mini-lottie/cedddb72f45046ca974cb594be964eeb.png" alt="" loading="lazy"></p>
<p>解决办法，给套了一层 <code>view</code>，用<code>wx:if</code>控制咯。</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::ysj6xj729d2ugrvqgybs::--><code>&lt;view  wx:if=&quot;{{show}}&quot;&gt;
  &lt;canvas id=&quot;c1&quot; type=&quot;2d&quot;&gt;&lt;/canvas&gt;
&lt;/view&gt;
</code></pre>
</div><h3 id="ios-播放闪退问题" tabindex="-1">iOS 播放闪退问题 <a class="header-anchor" href="#ios-播放闪退问题" aria-label="Permalink to “iOS 播放闪退问题”">&#8203;</a></h3>
<p>现象是，非冷启动小程序的时候，动画还没播放完毕就提前结束了。</p>
<p>看代码log，3s的动画，播放不到 1s 就触发了 <code>complete</code> 事件，看现象就是一闪而逝。</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::wclre81yjni8g2qs5zepgl::--><code>const ani = lottie.loadAnimation({
  // 3s 的动画
  animationData,
  // ...省略其它配置
})

ani.addEventListener(&#039;complete&#039;, () =&gt; {
  console.log(&#039;动画播放结束&#039;)
})</code></pre>
</div><p>问题排查：</p>
<p>① 翻看源码<a href="https://github.com/wechat-miniprogram/lottie-miniprogram/tree/master" target="_blank" rel="noreferrer">lottie-miniprogram</a></p>
<p>在 <code>src/adapter/index.js</code> 中看到<a href="https://github.com/wechat-miniprogram/lottie-miniprogram/blob/49066a6479d710b5863754613a518c65487912db/src/adapter/index.js#L89-L101" target="_blank" rel="noreferrer">下面这段代码</a></p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::h1iq4l02sqiepib8eplfqv::--><code>window.requestAnimationFrame = function requestAnimationFrame(cb) {
  let called = false
  setTimeout(() =&gt; {
    if (called) {
      return
    }
    called = true
    typeof cb === &#039;function&#039; &amp;&amp; cb(Date.now())
  }, 100)
  canvas.requestAnimationFrame((timeStamp) =&gt; {
    if (called) {
      return
    }
    called = true
    typeof cb === &#039;function&#039; &amp;&amp; cb(timeStamp)
  })
}</code></pre>
</div><p>在翻看一下小程序文档里 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/canvas/Canvas.requestAnimationFrame.html" target="_blank" rel="noreferrer">canvas.requestAnimationFrame</a> 文档说明。</p>
<p><img src="./mini-lottie/36b0cfb5ce7dca2c6916caf71aeff2ff.png" alt="" loading="lazy"></p>
<p>有点悟了上面的 <code>setTimeout</code> 代码，应该是为了兼容低版本的小程序，里面还有 <code>called</code> 变量控制，不重复执行。</p>
<p>猜测可能是在播放的时候执行了 <code>setTimeout</code> 里的逻辑导致动画提前结束。</p>
<p>于是我就加上了 <code>console.log</code> 发布到线上验证一下。</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::hr3n2uzfpcu6m52jitkufp::--><code>setTimeout(() =&gt; {
  if (called) {
    return
  }
  called = true
  console.log(&#039;setTimeout&#039;, Date.now()) // [!code ++]
  typeof cb === &#039;function&#039; &amp;&amp; cb(Date.now())
}, 100)

canvas.requestAnimationFrame((timeStamp) =&gt; {
  if (called) {
    return
  }
  console.log(&#039;canvas.requestAnimationFrame&#039;, timeStamp) // [!code ++]
  called = true
  typeof cb === &#039;function&#039; &amp;&amp; cb(timeStamp)
})</code></pre>
</div><p>vconsole 打印结果如下：</p>
<p><img src="./mini-lottie/8ee7e4cf3535cb2e4caba929abfe205c.png" alt="" loading="lazy"></p>
<p><em>一点补充，针对 <code>canvas.requestAnimationFrame</code> 回到函数的入参，小程序文档里虽没有详细介绍，但可以对标 Web 的
<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="noreferrer">Window：requestAnimationFrame() 方法</a> 看一下 MDN 上的解释。</em></p>
<p><img src="./mini-lottie/2d307758e0873a89aa4fb33602547ed7.png" alt="" loading="lazy"></p>
<p>从上面的 <code>console</code> 日志看，原因确实是执行 setTimeout 里面的逻辑导致的动画结束。</p>
<p>可以得到引发bug的原因：↓</p>
<p><strong>某种情况下，<code>setTimeout(callback, 100)</code> 比 <code>canvas.requestAnimationFrame</code> 更快执行。</strong></p>
<p><em>这个库很久没迭代了（现有版本是3年前发布的），每周还是有一些下载量，issue 里也没有提到 iOS 有这个问题！（切换渲染模式为 skyline 也没有触发这个问题，问题只在 webview 模式下有，且仅使用简单Demo也无法复现这个问题）</em></p>
<p><em>也不清楚小程序里 canvas.requestAnimationFrame 实现机制。</em></p>
<p><img src="./mini-lottie/5c5a97df02d19c6b7248b1c983b5a639.png" alt="" loading="lazy"></p>
<p>大胆揣测一下原因：</p>
<p><strong>页面实现可能过于复杂，复杂的业务逻辑执行阻塞在逻辑层，导致 setTimeout 时间到了以后回调函数入栈，接着就在逻辑层调用执行了</strong></p>
<p>解决办法：</p>
<p><img src="./mini-lottie/182858ba4f246bf28417cda3fb029b8f.png" alt="" loading="lazy"></p>
<p><strong>既然是兼容实现，就判断一下是否存在 <code>requestAnimationFrame</code> 方法，存在就不执行 <code>setTimeout</code> 相关逻辑。</strong></p>
<p>完整解决 PR 见：<a href="https://github.com/wechat-miniprogram/lottie-miniprogram/pull/50" target="_blank" rel="noreferrer">https://github.com/wechat-miniprogram/lottie-miniprogram/pull/50</a></p>
<p>将打包后的产物替换到 <code>node_modules</code> 里对应位置后，再使用 <a href="https://www.npmjs.com/package/patch-package" target="_blank" rel="noreferrer">patch-package</a> 生成 patch，以便后续安装依赖自动更新</p>
<h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>时间匆忙，介绍的不是非常的详细，感兴趣的同学可以评论区交流。</p>
<p><code>demo</code> 完整源码见 <a href="https://github.com/ATQQ/demos/tree/main/miniprogram/lottie-demo" target="_blank" rel="noreferrer">GitHub：lottie-demo</a></p>
<p><img src="./mini-lottie/c5a59914529f4b50a969ec7f1caadc36.png" alt="" loading="lazy"></p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/mini-lottie/e887b3af9200905af6a3484300de1d3b.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[【免费】Node.js 入门教程]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/nodejs-getting-started.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/nodejs-getting-started.html</guid>
            <pubDate>Tue, 09 Jul 2024 16:55:35 GMT</pubDate>
            <description><![CDATA[# 【免费】Node.js 入门教程
掘金小册「Node.js 入门教程」课程地址：[<<Node.js 入门教程>>](https://juejin.cn/book/7304230207953567755) 👍🏻

**这是一本完全免费的小册**，内容涵盖了软件的安装，环境配置，基础知识介绍，进阶知识介绍，多场景的开发实践。

![](./nodejs-getting-started/MTcwMjgwNzI2MjUwNg==702807262506.png)

## Node.js 的优势

*   高性能：基于事件驱动的非阻塞I/O模型，单线程也能够处理大量并发请求；
*   跨平台：可以运行在不同操作系统上；
*   社区完备：Node.js有一个庞大的社区，有丰富的文档和开源项目沉淀；
*   易上手：学习门槛低，环境配置简单，开发&部署迅速。

## 应用场景

*   服务端开发：[Express](https://expressjs.com/)、[Koa](https://koajs.com/#application)、[Midway](https://midwayjs.org/)、[Egg](https://www.eggjs.org/zh-CN)；
*   桌面应用：[Electron](https://www.electronjs.org/)、[NW.js](https://nwjs.io/)、线上应用 [VS Code](https://code.visualstudio.com/)、[飞书](https://www.feishu.cn/)、[新版QQ](https://im.qq.com/macqq/index.shtml)；
*   移动应用：[React Native](https://reactnative.cn/)、[Weex](https://weexapp.com/zh/)；
*   Web开发：[Vue](https://cn.vuejs.org/)、[React](https://zh-hans.react.dev/)、[Svelte](https://www.svelte.cn/)等前端框架
*   构建工具：[webpack](https://webpack.docschina.org/)、[Vite](https://cn.vitejs.dev/)、[Rollup](https://rollupjs.org/)；
*   CLI工具：前端开发者常用的各种项目脚手架和工具，如：[nodemon](https://www.npmjs.com/package/nodemon)、[whistle](https://github.com/avwo/whistle)、[http-server](https://www.npmjs.com/package/http-server)；

当然还有很多很多，等着你去探索……

![](./nodejs-getting-started/MTY4NTIwMTQwMTAzNg==685201401036.png)

本教程主要包含7个章节，涵盖了`软件的安装`、`环境配置`、`基础知识介绍`、`进阶知识介绍`、`多场景的开发实践` ღ( ´･ᴗ･\` )。

## 适合人群

*   想通过 `JavaScript` 写一些脚本处理日常工作；
*   对Web前端已经有一些了解，想自己做一个后端服务；
*   其它后端技术栈的同学，想了解一下 `JavaScript` 如何做后端服务。

]]></description>
            <content:encoded><![CDATA[<h1 id="【免费】node-js-入门教程" tabindex="-1">【免费】Node.js 入门教程 <a class="header-anchor" href="#【免费】node-js-入门教程" aria-label="Permalink to “【免费】Node.js 入门教程”">&#8203;</a></h1>
<p>掘金小册「Node.js 入门教程」课程地址：<a href="https://juejin.cn/book/7304230207953567755" target="_blank" rel="noreferrer">&lt;&lt;Node.js 入门教程&gt;&gt;</a> 👍🏻</p>
<p><strong>这是一本完全免费的小册</strong>，内容涵盖了软件的安装，环境配置，基础知识介绍，进阶知识介绍，多场景的开发实践。</p>
<p><img src="./nodejs-getting-started/MTcwMjgwNzI2MjUwNg==702807262506.png" alt="" loading="lazy"></p>
<h2 id="node-js-的优势" tabindex="-1">Node.js 的优势 <a class="header-anchor" href="#node-js-的优势" aria-label="Permalink to “Node.js 的优势”">&#8203;</a></h2>
<ul>
<li>高性能：基于事件驱动的非阻塞I/O模型，单线程也能够处理大量并发请求；</li>
<li>跨平台：可以运行在不同操作系统上；</li>
<li>社区完备：Node.js有一个庞大的社区，有丰富的文档和开源项目沉淀；</li>
<li>易上手：学习门槛低，环境配置简单，开发&amp;部署迅速。</li>
</ul>
<h2 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to “应用场景”">&#8203;</a></h2>
<ul>
<li>服务端开发：<a href="https://expressjs.com/" target="_blank" rel="noreferrer">Express</a>、<a href="https://koajs.com/#application" target="_blank" rel="noreferrer">Koa</a>、<a href="https://midwayjs.org/" target="_blank" rel="noreferrer">Midway</a>、<a href="https://www.eggjs.org/zh-CN" target="_blank" rel="noreferrer">Egg</a>；</li>
<li>桌面应用：<a href="https://www.electronjs.org/" target="_blank" rel="noreferrer">Electron</a>、<a href="https://nwjs.io/" target="_blank" rel="noreferrer">NW.js</a>、线上应用 <a href="https://code.visualstudio.com/" target="_blank" rel="noreferrer">VS Code</a>、<a href="https://www.feishu.cn/" target="_blank" rel="noreferrer">飞书</a>、<a href="https://im.qq.com/macqq/index.shtml" target="_blank" rel="noreferrer">新版QQ</a>；</li>
<li>移动应用：<a href="https://reactnative.cn/" target="_blank" rel="noreferrer">React Native</a>、<a href="https://weexapp.com/zh/" target="_blank" rel="noreferrer">Weex</a>；</li>
<li>Web开发：<a href="https://cn.vuejs.org/" target="_blank" rel="noreferrer">Vue</a>、<a href="https://zh-hans.react.dev/" target="_blank" rel="noreferrer">React</a>、<a href="https://www.svelte.cn/" target="_blank" rel="noreferrer">Svelte</a>等前端框架</li>
<li>构建工具：<a href="https://webpack.docschina.org/" target="_blank" rel="noreferrer">webpack</a>、<a href="https://cn.vitejs.dev/" target="_blank" rel="noreferrer">Vite</a>、<a href="https://rollupjs.org/" target="_blank" rel="noreferrer">Rollup</a>；</li>
<li>CLI工具：前端开发者常用的各种项目脚手架和工具，如：<a href="https://www.npmjs.com/package/nodemon" target="_blank" rel="noreferrer">nodemon</a>、<a href="https://github.com/avwo/whistle" target="_blank" rel="noreferrer">whistle</a>、<a href="https://www.npmjs.com/package/http-server" target="_blank" rel="noreferrer">http-server</a>；</li>
</ul>
<p>当然还有很多很多，等着你去探索……</p>
<p><img src="./nodejs-getting-started/MTY4NTIwMTQwMTAzNg==685201401036.png" alt="" loading="lazy"></p>
<p>本教程主要包含7个章节，涵盖了<code>软件的安装</code>、<code>环境配置</code>、<code>基础知识介绍</code>、<code>进阶知识介绍</code>、<code>多场景的开发实践</code> ღ( ´･ᴗ･` )。</p>
<h2 id="适合人群" tabindex="-1">适合人群 <a class="header-anchor" href="#适合人群" aria-label="Permalink to “适合人群”">&#8203;</a></h2>
<ul>
<li>想通过 <code>JavaScript</code> 写一些脚本处理日常工作；</li>
<li>对Web前端已经有一些了解，想自己做一个后端服务；</li>
<li>其它后端技术栈的同学，想了解一下 <code>JavaScript</code> 如何做后端服务。</li>
</ul>
<hr>
<p>当下，<code>JavaScript</code> 已经成为了前端开发的标配，并且随着 <code>Node.js</code> 的出现，<code>JavaScript</code> 也逐渐成为了全栈开发的标配，希望本教程能够帮助读者更好地理解和掌握全栈开发所需的 <code>Node.js</code> 相关的基础技术，从而更好地完成实际开发工作。</p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/nodejs-getting-started/MTY4NTIwMTQwMTAzNg==685201401036.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[纯前端实现 PNG 图片压缩 | UPNG.js]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/png-compress.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/png-compress.html</guid>
            <pubDate>Tue, 09 Jul 2024 16:55:35 GMT</pubDate>
            <description><![CDATA[最近在迭代应用的时候用到了 UPNG.js 压缩 PNG 图片，这里记录分享一下使用经验，并附上完整 Demo。]]></description>
            <content:encoded><![CDATA[<h1 id="纯前端实现-png-图片压缩-upng-js" tabindex="-1">纯前端实现 PNG 图片压缩 | UPNG.js <a class="header-anchor" href="#纯前端实现-png-图片压缩-upng-js" aria-label="Permalink to “纯前端实现 PNG 图片压缩 | UPNG.js”">&#8203;</a></h1>
<blockquote>
<p><strong>在线 Demo 体验地址 →:</strong> <a href="https://demos.sugarat.top/pages/png-compress/" target="_blank" rel="noreferrer">https://demos.sugarat.top/pages/png-compress/</a></p>
</blockquote>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>最近在迭代自己的 <a href="https://imgbed.sugarat.top/" target="_blank" rel="noreferrer">图床</a> 应用，由于使用时间的累计，存储空间占用越来越大了，在做 Web 应用的时候会随手拿 <a href="https://tinypng.com/" target="_blank" rel="noreferrer">tinypng</a> 压缩一下图片。</p>
<p>想着给咱图床也加个压缩的功能，这样上传/访问也能省点 💰。</p>
<p><img src="./png-compress/d666613614e04da1e6e135c982cfc42e.png" alt="" loading="lazy"></p>
<p>图片类型众多，常用的主要就是<code>PNG/JPG/GIF</code>。</p>
<p>个人使用频率最高的场景是截图上传，格式为<code>PNG</code>，就先拿 <code>PNG</code> 试手。调研了一圈开源里最流行的就是使用 <a href="https://github.com/photopea/UPNG.js" target="_blank" rel="noreferrer">UPNG.js</a> 进行 PNG 的压缩。</p>
<ul>
<li><a href="https://blog.photopea.com/png-minifier-inside-photopea.html#examples" target="_blank" rel="noreferrer">官方对比 tinypng 介绍</a>；</li>
<li><a href="http://upng.photopea.com/" target="_blank" rel="noreferrer">官方在线示例 Demo</a>。</li>
</ul>
<h2 id="如何判断图片是-png" tabindex="-1">如何判断图片是 PNG <a class="header-anchor" href="#如何判断图片是-png" aria-label="Permalink to “如何判断图片是 PNG”">&#8203;</a></h2>
<p>第一步当然是判断图片类型，不然 <code>UPNG.js</code> 就不能正常工作咯，通过文件后缀 .png 判断肯定是不靠谱的。</p>
<p>搜索了解了一下，可以使用 <code>魔数</code> 判断：<strong>一个PNG文件的前8个字节是固定的</strong>。</p>
<p><code>PNG</code> 的前 8 个字节是（16进制表示）：<code>89 50 4E 47 0D 0A 1A 0A</code>。</p>
<p>我们可以拿工具看一下，我这里用 VS Code 插件 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.hexeditor" target="_blank" rel="noreferrer">Hex Editor</a> 查看一个 PNG 图片的 16 进制表示信息。</p>
<p><img src="./png-compress/a10803276d251362424af66453c301ba.png" alt="" loading="lazy"></p>
<p>可以看到前八个字节和上面表示的一样。</p>
<p>于是可以根据这个特性判断，于是就有如下的判断代码。</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::dozhgs5tafqwz2h8ub29h::--><code>async function isPNG(file: File) {
  // 提取前8个字节
  const arraybuffer = await file.slice(0, 8).arrayBuffer()

  // PNG 的前8字节16进制表示
  const signature = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]
  // const signature = [137, 80, 78, 71, 13, 10, 26, 10]

  // 转为 8位无符号整数数组 方便对比
  // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array
  const source = new Uint8Array(arraybuffer)

  // 逐个字节对比
  for (let i = 0; i &lt; signature.length; i++) {
    if (source[i] !== signature[i]) {
      return false
    }
  }
  return true
}</code></pre>
</div><h2 id="upng-js" tabindex="-1">UPNG.js <a class="header-anchor" href="#upng-js" aria-label="Permalink to “UPNG.js”">&#8203;</a></h2>
<h3 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to “简介”">&#8203;</a></h3>
<blockquote>
<p>一个轻量且极速的 <code>PNG/APNG</code> 编码和解码库，<a href="https://www.photopea.com/" target="_blank" rel="noreferrer">Photopea</a> 图像编辑器的主要 <code>PNG</code> 引擎。</p>
</blockquote>
<h3 id="npm-加载" tabindex="-1">npm 加载 <a class="header-anchor" href="#npm-加载" aria-label="Permalink to “npm 加载”">&#8203;</a></h3>
<p>官方提供了 <code>npm</code> 包，简单引入即可使用。</p>
<p>安装依赖</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::dvl41it0q76yyfzla7msz::--><code>npm install upng-js</code></pre>
</div><p>核心方法就 3 个，依次调用即可</p>
<ul>
<li>UPNG.decode(buffer)</li>
<li>UPNG.toRGBA8(img)</li>
<li>UPNG.encode(imgs, w, h, cnum, [dels])
<ul>
<li>cnum：0 表示无损压缩，256表示有损，可以调整这个值来控制压缩质量。</li>
</ul>
</li>
</ul>
<p><strong>注意：压缩并不意味着一定小，对于一些已经很简单且小的图片，压缩后可能反而更大。</strong></p>
<p>下面是这个方法的最简实现。</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::akeztuf4uh4075m771ph23o::--><code>import UPNG from &#039;upng-js&#039;

async function compressPNG(file: File) {
  const arrayBuffer = await file.arrayBuffer()
  const decoded = UPNG.decode(arrayBuffer)
  const rgba8 = UPNG.toRGBA8(decoded)

  // 关键的压缩方法
  // 这里 保持宽高不变，保持80%的质量（接近于 tinypng 的压缩效果）
  const compressed = UPNG.encode(
    rgba8,
    decoded.width,
    decoded.height,
    256 * 0.8
  )
  return new File([compressed], file.name, { type: &#039;image/png&#039; })
}</code></pre>
</div><p>其中压缩后的宽高，压缩质量都是可以调整的。</p>
<h3 id="可配置封装" tabindex="-1">可配置封装 <a class="header-anchor" href="#可配置封装" aria-label="Permalink to “可配置封装”">&#8203;</a></h3>
<p>下面方法（TS 实现），提供了一些常用的配置选项。</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::f6puza5tastxme868mo2x::--><code>import UPNG from &#039;upng-js&#039;

interface CompressOptions {
  /**
   * 压缩质量（[0,1]）
   * @default 0.8
   */
  quality?: number
  /**
   * 压缩后更大是否使用原图
   * @default true
   */
  noCompressIfLarger?: boolean
  /**
   * 压缩后的新宽度
   * @default 原尺寸
   */
  width?: number
  /**
   * 压缩后新高度
   * @default 原尺寸
   */
  height?: number
}
async function compressPNGImage(file: File, ops: CompressOptions = {}) {
  const { width, height, quality = 0.8, noCompressIfLarger = true } = ops

  const arrayBuffer = await file.arrayBuffer()
  const decoded = UPNG.decode(arrayBuffer)
  const rgba8 = UPNG.toRGBA8(decoded)

  const compressed = UPNG.encode(
    rgba8,
    width || decoded.width,
    height || decoded.height,
    256 * quality
  )

  const newFile = new File([compressed], file.name, { type: &#039;image/png&#039; })

  if (!noCompressIfLarger) {
    return newFile
  }

  return file.size &gt; newFile.size ? newFile : file
}</code></pre>
</div><h3 id="cdn-加载" tabindex="-1">CDN 加载 <a class="header-anchor" href="#cdn-加载" aria-label="Permalink to “CDN 加载”">&#8203;</a></h3>
<p>不通过 npm 安装，也可以使用 <code>&lt;script&gt;</code> 标签的方式进行全局引入。</p>
<p>可以使用<a href="https://www.staticfile.org/" target="_blank" rel="noreferrer">Static file</a>提供的 CDN 资源。</p>
<p>只需在 HTML 模板顶部 head 中加入如下资源即可使用。</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::v2qyz5afo4flzfqlq5ttzd::--><code>&lt;head&gt;
  &lt;script src=&quot;https://cdn.staticfile.net/pako/1.0.5/pako.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.staticfile.net/upng-js/2.1.0/UPNG.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;</code></pre>
</div><p>PNG 格式化使用 <code>Inflate</code> 算法。这部分调用 <a href="https://github.com/nodeca/pako" target="_blank" rel="noreferrer">Pako.js</a> 实现，所以需要额外前置引入。</p>
<p>引入后，将在 window 上绑定 UPNG 变量，使用和上述 npm 给到的例子完全一致。</p>
<p><em>代码里调用方式如下</em></p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::92au5wshyi50442sxyvku::--><code>window.UPNG.encode

// 省略 window
UPNG.encode</code></pre>
</div><h2 id="完整-demo" tabindex="-1">完整 demo <a class="header-anchor" href="#完整-demo" aria-label="Permalink to “完整 demo”">&#8203;</a></h2>
<p>笔者将本节内容整理成了一个 Demo，可以直接在线体验。</p>
<blockquote>
<p><strong>在线 Demo 体验地址 →:</strong> <a href="https://demos.sugarat.top/pages/png-compress/" target="_blank" rel="noreferrer">https://demos.sugarat.top/pages/png-compress/</a></p>
</blockquote>
<p>大概界面如下：</p>
<p><img src="./png-compress/5d461c425ea18f501262017bdeca8a9a.png" alt="" loading="lazy"></p>
<p><em>纯血 HTML/CSS/JS，复制粘贴就能运行。</em></p>
<p>完整源码见：<a href="https://github.com/ATQQ/demos/tree/main/pages/png-compress" target="_blank" rel="noreferrer">GitHub:ATQQ/demos - png-compress</a></p>
<h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>后续将继续学习&amp;探索一下其它格式的<strong>纯前端压缩实现</strong>（JPG，GIF，MP4转GIF）。</p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/png-compress/d666613614e04da1e6e135c982cfc42e.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[使用又拍云极速搭建图床]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/upyun.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/upyun.html</guid>
            <pubDate>Tue, 09 Jul 2024 16:55:35 GMT</pubDate>
            <description><![CDATA[分享一下又拍云的简单用法，以及使用它搭建图床。]]></description>
            <content:encoded><![CDATA[<h1 id="使用又拍云极速搭建图床" tabindex="-1">使用又拍云极速搭建图床 <a class="header-anchor" href="#使用又拍云极速搭建图床" aria-label="Permalink to “使用又拍云极速搭建图床”">&#8203;</a></h1>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>某天在群里摸 🐟 ，聊到了图床相关的话题，群友推荐了 <a href="https://www.upyun.com/league" target="_blank" rel="noreferrer">又拍云</a>。</p>
<p>说有活动，可以白嫖存储，<code>10G + 15G（HTTP/HTTPS 流量）</code> 。笔者之前一直用的<a href="https://www.qiniu.com/prices/kodo" target="_blank" rel="noreferrer">七牛云</a> <code>10G + 10G（回源流量）</code>。</p>
<table tabindex="0">
<thead>
<tr>
<th style="text-align:center">又拍云</th>
<th style="text-align:center">七牛云</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="./upyun/96868081e49914aa6ab7ee142e064d56.png" alt="" loading="lazy"></td>
<td style="text-align:center"><img src="./upyun/4a1fb149f7dbcfa43af08f1354781d76.png" alt="" loading="lazy"></td>
</tr>
<tr>
<td style="text-align:center">注册送1个月的代金券 + 网站挂推广送1年代金券</td>
<td style="text-align:center">注册即可送每月都有</td>
</tr>
</tbody>
</table>
<p>笔者就花了点时间研究了一下又拍云的 SDK 和对象存储，能力上完全可以平替七牛云，于是就花了一点时间给<a href="https://imgbed.sugarat.top/" target="_blank" rel="noreferrer">图床应用</a>加上了又拍云的支持。</p>
<h2 id="效果" tabindex="-1">效果 <a class="header-anchor" href="#效果" aria-label="Permalink to “效果”">&#8203;</a></h2>
<p>大家可以访问 <a href="https://imgbed.sugarat.top/" target="_blank" rel="noreferrer">https://imgbed.sugarat.top/</a> 直接体验，默认已配置 又拍云 存储</p>
<p>下面将介绍 又拍云对象存储配置，关键API用法，如何接入上述图床。</p>
<h2 id="对象存储服务创建" tabindex="-1">对象存储服务创建 <a class="header-anchor" href="#对象存储服务创建" aria-label="Permalink to “对象存储服务创建”">&#8203;</a></h2>
<p>这里直接省略账号注册，参加推广活动等步骤，直接进入对象存储配置页面。</p>
<p>访问<a href="https://console.upyun.com/services/file/" target="_blank" rel="noreferrer">对象存储控制台</a>，点击创建服务</p>
<p><img src="./upyun/5c0388757ee62813255ea400b0a9907b.png" alt="" loading="lazy"></p>
<p>这个&quot;服务&quot;和其它平台的 <code>Bucket(桶)</code> 类似，可以理解为存储空间的概念。</p>
<p>填一下服务名称（<code>全平台唯一</code>），绑定账号即可</p>
<p><img src="./upyun/8358d7845041f2cfa1e9af3751eca150.png" alt="" loading="lazy"></p>
<p><strong>服务创建完，需要的东西基本都有了，是不是非常简单！</strong></p>
<ul>
<li>服务名：自定义</li>
<li>账号：自定义</li>
<li>密码：自动生成</li>
<li>域名：测试域名 <code>serviceName.test.upcdn.net</code></li>
</ul>
<h2 id="api-使用" tabindex="-1">API 使用 <a class="header-anchor" href="#api-使用" aria-label="Permalink to “API 使用”">&#8203;</a></h2>
<h3 id="token-生成" tabindex="-1">token 生成 <a class="header-anchor" href="#token-生成" aria-label="Permalink to “token 生成”">&#8203;</a></h3>
<p>这里推荐使用 token 认证 根据<a href="https://help.upyun.com/knowledge-base/object_storage_authorization/#token-e8aea4e8af81" target="_blank" rel="noreferrer">文档：认证鉴权</a>可知生成方式如下：</p>
<p><img src="./upyun/9018f184d07b38b69f53f7335aa7cd2e.png" alt="" loading="lazy"></p>
<p>看不懂？没关系 GPT 可以帮你，直接复制丢给它。</p>
<p><img src="./upyun/16cb9a0c8e480e61304a2366d3568878.png" alt="" loading="lazy"></p>
<p>这不代码就来了。</p>
<p>我们可以适当优化一下，不需要用到第三方库<code>base64-js</code>，直接使用 Node.js 的内置模块<code>crypto</code> 即可。</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::zfh1z5cjgv9fp92pqoszn::--><code>import crypto from &#039;crypto&#039;

/**
 * 生成 upyun 上传token
 * @param {*} operator 账号
 * @param {*} password 密码
 * @param {*} method 方法（PUT）
 * @param {*} uriPrefix 请求公共前缀
 * @param {*} date 过期时间
 * @returns 上传凭证
 */
function generateUpyunToken(operator, password, method, uriPrefix, date) {
  // 密码的md5值，秘钥
  const secret = crypto.createHash(&#039;md5&#039;).update(password).digest(&#039;hex&#039;)

  // 构造用于计算校验值的字符串
  const value = `${method}&amp;${uriPrefix}&amp;${date}`

  // 使用 hmac-sha1 算法生成token
  const token = crypto.createHmac(&#039;sha1&#039;, secret) // 使用密码的MD5值作为秘钥
    .update(value) // 设置用于计算校验值的字符串
    .digest() // 计算校验值
    .toString(&#039;base64&#039;) // 转换为base64 格式

  // 组合成要求的格式
  return `UPYUN ${operator}:${token}`
}</code></pre>
</div><p>代码非常简洁明了，使用方式如下</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::x2rav4v47llk1hmfgrwf8::--><code>const token = generateUpyunToken(&#039;账号&#039;,
  &#039;密码&#039;,
  &#039;PUT&#039;,
  &#039;服务名/资源公共前缀路径&#039;, // 服务名 + 公共资源前缀路径构成
  new Date().getTime() + 1000 * 60 * 60 * 24 * 90 // 计算过期时间 90天后的日期
)</code></pre>
</div><p>理论上这个 token 也可以在前端生成，调用和后端一致的算法即可。</p>
<h3 id="前端上传" tabindex="-1">前端上传 <a class="header-anchor" href="#前端上传" aria-label="Permalink to “前端上传”">&#8203;</a></h3>
<p>① 安装 upyun sdk</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::sfzc4c2308sxbdtu7xmw::--><code>npm i upyun</code></pre>
</div><p>② 上传示例</p>
<p>根据文档，可以看到客户端上传需要的参数。</p>
<p><img src="./upyun/3c68a4e45d6be0789636eefc9e8fcbbd.png" alt="" loading="lazy"></p>
<ul>
<li><code>Authorization</code>：前面通过生成的token</li>
<li><code>X-Date</code>：请求日期时间，GMT 格式字符串</li>
<li><code>X-Upyun-Uri-Prefix</code>：服务名 + 资源公共前缀路径</li>
<li><code>X-Upyun-Expire</code>：过期时间</li>
</ul>
<p>下面就是核心的上传方法。</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::4pxl84tzf3ow6rttggq19b::--><code>import upyun from &#039;upyun&#039;

const service = new upyun.Service(&#039;服务名&#039;)
const client = new upyun.Client(service, () =&gt; ({
  &#039;Authorization&#039;: &#039;前面通过生成的token&#039;,
  &#039;X-Date&#039;: new Date().toUTCString(),
  &#039;X-Upyun-Uri-Prefix&#039;: &#039;服务名/资源公共前缀路径&#039;,
  &#039;X-Upyun-Expire&#039;: date, // 前面生成 Token 时的 date 参数
}))

const sourceKey = &#039;资源公共前缀路径/资源名&#039; // &#039;test/imgs/abc.png&#039;

// 调用上传
client.putFile(sourceKey, file) // 返回值 Promise&lt;boolean&gt;</code></pre>
</div><p>③ 方法封装</p>
<p>我们可以简单封装一下，方便调用</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::pg51fpqniof644zvnvu5z::--><code>interface UPYunConfig {
  /**
   * 服务名
   */
  serviceName: string
  /**
   * 上传凭证
   */
  token: string
  /**
   * 资源公共前缀
   */
  prefix: string
  /**
   * 过期时间 new Date().getTime() + 1000 * 60 * 60 * 24 * 90
   */
  date: number
  /**
   * 域名（用于拼接最后的访问链接）
   */
  domain: string
  /**
   * 最后的资源名，建议使用 uuid 或者文件的 MD5
   */
  filename?: string
}
async function uploadFile(file: File, ops: UPYunConfig) {
  const { serviceName, prefix, token, date, domain, filename } = ops

  const service = new upyun.Service(serviceName)
  const client = new upyun.Client(service, () =&gt; ({
    &#039;Authorization&#039;: token,
    &#039;X-Date&#039;: new Date().toUTCString(),
    &#039;X-Upyun-Uri-Prefix&#039;: `${serviceName}/${prefix}`,
    &#039;X-Upyun-Expire&#039;: date,
  }))

  const key = `${prefix}/${filename || file.name}`

  const isSuccess = await client.putFile(key, file)
  // 返回最后可以用于访问的链接
  return isSuccess ? Promise.resolve(`${domain}/${key}`) : Promise.reject(new Error(&#039;上传失败&#039;))
}</code></pre>
</div><h2 id="接入纯静态图床" tabindex="-1">接入纯静态图床 <a class="header-anchor" href="#接入纯静态图床" aria-label="Permalink to “接入纯静态图床”">&#8203;</a></h2>
<p>上述逻辑我都封装在了自己的图床应用中：<a href="https://github.com/ATQQ/image-bed-qiniu/tree/master/packages/client#-%E5%9F%BA%E4%BA%8E-oss%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%BA%93-%E5%9B%BE%E5%BA%8A-" target="_blank" rel="noreferrer">GitHub: image-bed-qiniu</a></p>
<p>只需要在 <a href="https://github.com/ATQQ/image-bed-qiniu/tree/master/packages/cli" target="_blank" rel="noreferrer">cli</a> 目录下，修改 <a href="https://github.com/ATQQ/image-bed-qiniu/blob/master/packages/cli/.env" target="_blank" rel="noreferrer">.env</a> 配置文件</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::406nv1txw9ijn99ys13r2::--><code># 又拍云相关配置
UPYUN_OPERATOR=operator
UPYUN_PASSWORD=password
UPYUN_BUCKET=service-name
UPYUN_DOMAIN=http://service-name.test.upcdn.net
UPYUN_PREFIX=image
UPYUN_SCOPE=default
# token有效期，默认3个月，单位秒，你可以自行设置（60*60*24*30）
# UPYUN_EXPIRES=2592000</code></pre>
</div><p>执行 <code>node upyun-token.js</code> 即可生成需要的 token。</p>
<p>将其粘贴配置到 <a href="https://imgbed.sugarat.top/" target="_blank" rel="noreferrer">线上的图床应用</a>，或者自己部署的均可 <a href="https://github.com/ATQQ/image-bed-qiniu/tree/master/packages/client#%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE" target="_blank" rel="noreferrer">image-bed-qiniu:client</a></p>
<p><img src="./upyun/9b11917ab2a09e1bec11e8272f0f4f2c.png" alt="" loading="lazy"></p>
<h2 id="其它" tabindex="-1">其它 <a class="header-anchor" href="#其它" aria-label="Permalink to “其它”">&#8203;</a></h2>
<p>线上使用，推荐 绑定自定义域名 和 开启HTTPS 支持。</p>
<p>这两个直接在平台里根据指引操作即可，步骤也很简单。</p>
<h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>后续准备提供一个图床的 Docker 镜像，这样部署起来也更加方便。</p>
<p>大家有其它可白嫖的图床也可推荐推荐一下。</p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/upyun/96868081e49914aa6ab7ee142e064d56.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[使用http-proxy-agent出现ECONNRESET error]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/study/http-proxy-fail.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/study/http-proxy-fail.html</guid>
            <pubDate>Tue, 09 Jul 2024 16:55:35 GMT</pubDate>
            <description><![CDATA[使用http-proxy-agent出现ECONNRESET error
之前做了1个下载文件的CLI工具 efst - 原理文章: 从0-1实现文件下载CLI工具
其中支持设置 代理(proxy) ]]></description>
            <content:encoded><![CDATA[<h1 id="使用http-proxy-agent出现econnreset-error" tabindex="-1">使用http-proxy-agent出现ECONNRESET error <a class="header-anchor" href="#使用http-proxy-agent出现econnreset-error" aria-label="Permalink to “使用http-proxy-agent出现ECONNRESET error”">&#8203;</a></h1>
<p>之前做了1个下载文件的CLI工具 <a href="https://github.com/ATQQ/tools/blob/main/packages/cli/efst/README.md" target="_blank" rel="noreferrer">efst</a> - <a href="./../works/fs-cli.html">原理文章: 从0-1实现文件下载CLI工具</a></p>
<p><img src="./http-proxy-fail/MTY2ODkyMDg3NDEwNg==668920874106.png" alt="图片" loading="lazy"></p>
<p>其中支持设置 代理(proxy) 来下载网络资源</p>
<h2 id="遇到的问题" tabindex="-1">遇到的问题 <a class="header-anchor" href="#遇到的问题" aria-label="Permalink to “遇到的问题”">&#8203;</a></h2>
<p>当我准备使用代理下载<code>Telegram</code>时，总会卡在<code>99%</code></p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::xzz3c2kgxubu8c7ujcrbeq::--><code>efst https://updates.tdesktop.com/tmac/tsetup.4.5.3.dmg -o -p http://127.0.0.1:7890</code></pre>
</div><p><img src="./http-proxy-fail/MTY3NDQwNDU1NjU2Ng==674404556566.png" alt="图片" loading="lazy"></p>
<p>输出了一下错误，发现报错信息是 <code>ECONNRESET error</code></p>
<h2 id="解决办法" tabindex="-1">解决办法 <a class="header-anchor" href="#解决办法" aria-label="Permalink to “解决办法”">&#8203;</a></h2>
<p>谷歌关键词 <code>使用http-proxy code: 'ECONNRESET'</code>，找到了解决办法 <a href="https://www.jianshu.com/p/7f004a9a02f3" target="_blank" rel="noreferrer">简书：记一次本地错误排查过程：macbook Proxy error: Could not proxy request</a></p>
<p>添加请求头<code>Connection: 'keep-alive'</code>即可</p>
<p><img src="./http-proxy-fail/MTY3NDQwNDgxMjIzMA==674404812230.png" alt="图片" loading="lazy"></p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/http-proxy-fail/MTY2ODkyMDg3NDEwNg==668920874106.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[使用豆包 MarsCode IDE 搭建 VitePress博客并使用 GitHub 部署]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/ai/doubao/marscode-cn.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/ai/doubao/marscode-cn.html</guid>
            <pubDate>Fri, 05 Jul 2024 18:00:00 GMT</pubDate>
            <description><![CDATA[创建MarsCode项目
&gt;还没有注册登录的可以访问 https://www.marscode.cn/introduction-of-ide 登录并进入IDE界面
在左上角和右上角都有创建项目的]]></description>
            <content:encoded><![CDATA[<h1 id="使用豆包-marscode-ide-搭建-vitepress博客并使用-github-部署" tabindex="-1">使用豆包 MarsCode IDE 搭建 VitePress博客并使用 GitHub 部署 <a class="header-anchor" href="#使用豆包-marscode-ide-搭建-vitepress博客并使用-github-部署" aria-label="Permalink to “使用豆包 MarsCode IDE 搭建 VitePress博客并使用 GitHub 部署”">&#8203;</a></h1>
<blockquote>
<p>我正在参加<a href="https://juejin.cn/post/7384997062416252939" target="_blank" rel="noreferrer">「豆包MarsCode初体验」</a>征文活动</p>
</blockquote>
<h2 id="创建marscode项目" tabindex="-1">创建MarsCode项目 <a class="header-anchor" href="#创建marscode项目" aria-label="Permalink to “创建MarsCode项目”">&#8203;</a></h2>
<blockquote>
<p>还没有注册登录的可以访问 <a href="https://www.marscode.cn/introduction-of-ide" target="_blank" rel="noreferrer">https://www.marscode.cn/introduction-of-ide</a> 登录并进入IDE界面
<img src="https://cdn.upyun.sugarat.top/mdImg/sugar/c331c475497e3e35eb54debcb1edcb22" alt="" loading="lazy"></p>
</blockquote>
<p>在左上角和右上角都有创建项目的入口。</p>
<p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/9cb29ef6e068d57e8185b5784ec09ce2" alt="" loading="lazy"></p>
<p>选择 Node.js 项目进行创建。</p>
<p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/a6d82c0919e1ed834e47cac0965521e2" alt="" loading="lazy"></p>
<p>创建后可以看到项目列表里只是一个基础的 node.js 项目。</p>
<p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/a3ff12727f02a087c1ab2f57ca420fb5" alt="" loading="lazy"></p>
<p>接下来就可以导入我们的 VitePress 项目。</p>
<h2 id="拉取-vitepress-博客项目模板" tabindex="-1">拉取 VItePress 博客项目模板 <a class="header-anchor" href="#拉取-vitepress-博客项目模板" aria-label="Permalink to “拉取 VItePress 博客项目模板”">&#8203;</a></h2>
<p><strong>使用终端操作</strong>，删除原来的项目文件。</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::qsysahyn2g9s4f6yge4njp::--><code># 查看当前项目 目录
pwd

# 移动到上一级目录
cd ../

# 删除原来的项目文件
rm -rf VitePress-boke</code></pre>
</div><p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/4827468b7b6f7cdb991c405d20bcebad" alt="" loading="lazy"></p>
<p>接下来需要创建一个同名的 <code>VitePress</code> 项目。</p>
<p>VitePress 博客模板可以使用笔者的主题 <a href="https://theme.sugarat.top/" target="_blank" rel="noreferrer">@sugarat/theme</a></p>
<p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/42cd40b377f3dbf0654a467736b12161" alt="" loading="lazy"></p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::hl60bkpae4hxaqihstv9zl::--><code># 一键创建
npm create @sugarat/theme VitePress-boke</code></pre>
</div><p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/ba5726ac199a5f3551d7cfd67bbfb1b2" alt="" loading="lazy"></p>
<p>根据操作提示，完成前三步就可以启动。</p>
<p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/c5d34dee9f0c06198d8cd0a83241a8c1" alt="" loading="lazy"></p>
<p>点击右侧工具栏中的 <code>Webview</code> 就可以预览看到效果。</p>
<p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/3a2784328291b06d96e6d8c873c0198d" alt="" loading="lazy"></p>
<p>所有文章内容默认都在 <code>docs</code> 目录下。</p>
<p>开发模式(<code>npm run dev</code>)下，修改会立即生效，自动热更新到页面上。</p>
<p>生产模式使用 <code>npm run build</code> 打包。</p>
<p>如果你没有自己的服务器，又想部署一个站点供其它人访问，就可以使用 <code>GitHub Pages</code>，当然弊端就是访问速度不稳定，下面演示一下。</p>
<h2 id="部署到github-pages" tabindex="-1">部署到GitHub Pages <a class="header-anchor" href="#部署到github-pages" aria-label="Permalink to “部署到GitHub Pages”">&#8203;</a></h2>
<h3 id="创建-github-仓库" tabindex="-1">创建 GitHub 仓库 <a class="header-anchor" href="#创建-github-仓库" aria-label="Permalink to “创建 GitHub 仓库”">&#8203;</a></h3>
<blockquote>
<p>GitHub 地址：<a href="https://github.com" target="_blank" rel="noreferrer">https://github.com</a></p>
</blockquote>
<p><a href="https://github.com/ATQQ/marscode-blog-preview" target="_blank" rel="noreferrer">ATQQ/marscode-blog-preview</a></p>
<p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/3a2fdcf9c9f267a1d7f28c404ef5741d" alt="" loading="lazy"></p>
<h3 id="修改配置" tabindex="-1">修改配置 <a class="header-anchor" href="#修改配置" aria-label="Permalink to “修改配置”">&#8203;</a></h3>
<p>可以参考示例项目 <code>README.md</code> 中内容，轻松搞定。</p>
<p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/e0c376a13d2750fcf572b47ae00db0ab" alt="" loading="lazy"></p>
<ol>
<li>修改 GitHub 配置</li>
</ol>
<p>将 GitHub Pages 部署调整为 <code>GitHub Actions</code></p>
<p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/660008a054e5b92e44ee820b745d4105" alt="" loading="lazy"></p>
<ol start="2">
<li>修改 VitePress 配置</li>
</ol>
<p>修改 <code>docs/.vitepress/config.mts</code> 里的构建配置</p>
<p><code>base</code> 改为 <code>&quot;/仓库名/&quot;</code> 即可</p>
<p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/5d1ae11df04fe9c16d9f1d741ac86942" alt="" loading="lazy"></p>
<h3 id="推送代码" tabindex="-1">推送代码 <a class="header-anchor" href="#推送代码" aria-label="Permalink to “推送代码”">&#8203;</a></h3>
<p>只差最后一步了，将代码推送到 GitHub 仓库就完成了。</p>
<ol>
<li>创建并提交至本地仓库</li>
</ol>
<p>按顺序执行下面 3 条命令即可。</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::sx7on5zhcfms07jb3btuwq::--><code>git init

git add .

git commit -m &quot;first commit&quot;</code></pre>
</div><p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/a729823f786871ea5761b22ded9a808b" alt="" loading="lazy"></p>
<ol start="2">
<li>GitHub 授权</li>
</ol>
<p>生成SSH密钥对(一路回车就行)</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::rlct6emqu1l8g2eb8ct96p::--><code>ssh-keygen -t rsa -b 4096 -C &quot;你的github邮箱&quot;</code></pre>
</div><p>将自动生成<code>id_rsa</code>和<code>id_rsa.pub</code></p>
<p>复制生成的公钥内容</p>
<p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/03ae0217087aad0eb9613658ab1be01b" alt="" loading="lazy"></p>
<p>将其添加到 GitHub 个人设置的 SSH 秘钥中。</p>
<p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/bfa8a5044c85cd1880e60bb498b716e0" alt="" loading="lazy"></p>
<ol start="3">
<li>关联并推送到 GitHub</li>
</ol>
<p>你可以在空仓库页面看到如下的提示，咱们按顺序执行即可。</p>
<p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/2360d47775bd07f674116fe794ee276a" alt="" loading="lazy"></p>
<p><em>切换为 ssh 地址视图，截图是 https 地址</em></p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::tp4mlxi8iuk6wr8zl887xc::--><code># 添加远程仓库地址
git remote add origin git@github.com:ATQQ/marscode-blog-preview.git
# 修改分支名
git branch -M main
# 推送分支 main 到远程仓库
git push -u origin main</code></pre>
</div><p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/8e8c6ff16fd5161e7aecd8597ad8c0ff" alt="" loading="lazy"></p>
<p>访问仓库的 Actions 查看结果（<a href="https://github.com/ATQQ/marscode-blog-preview/actions/runs/9802748151" target="_blank" rel="noreferrer">示例项目 &gt; Action 执行结果</a>）。</p>
<p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/72ac8a626de255f28b45e9858ccdde5d" alt="" loading="lazy"></p>
<p>访问 <a href="https://atqq.github.io/marscode-blog-preview/" target="_blank" rel="noreferrer">https://atqq.github.io/marscode-blog-preview/</a> 即可查看到部署后的博客。</p>
<h2 id="更新内容" tabindex="-1">更新内容 <a class="header-anchor" href="#更新内容" aria-label="Permalink to “更新内容”">&#8203;</a></h2>
<p>只需修改/创建 <code>markdown</code> 文档内容即可，然后通过 git 进行推送即可，会自动触发 GitHub Actions 自动部署。</p>
<p>下面也演示一下：</p>
<p>先修改一点内容，</p>
<p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/46fc1821c980694aaad06f6e56f1046a" alt="" loading="lazy"></p>
<p>再提交推送。</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::i5hghtfegpfyvk4cbwfyqh::--><code>git add .
git commit -m &quot;docs: update index.md&quot;
git push</code></pre>
</div><p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/fd4941615d651d061040492606f8efdd" alt="" loading="lazy"></p>
<p>推送后触发日志。</p>
<p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/f299b7d870cf2df6ac78c5fab40cebaa" alt="" loading="lazy"></p>
<p>再次访问页面就是新的内容了。</p>
<p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/c37c9ca0f405eb1d0646a4753e37bbfc" alt="" loading="lazy"></p>
]]></content:encoded>
            <enclosure url="https://cdn.upyun.sugarat.top/mdImg/sugar/c331c475497e3e35eb54debcb1edcb22" length="0" type="image//mdImg/sugar/c331c475497e3e35eb54debcb1edcb22"/>
        </item>
        <item>
            <title><![CDATA[CSS足迹]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/css/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/css/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[记录开发中所遇问题及其解法与css学习笔记
 目录
* BFC
* 盒模型
* 弹性布局
* IFC
* CSS层级关系
* CSS伪元素before与after
* 表格斑马纹
* 伪类
* 伪元素]]></description>
            <content:encoded><![CDATA[<h1 id="css足迹" tabindex="-1">CSS足迹 <a class="header-anchor" href="#css足迹" aria-label="Permalink to “CSS足迹”">&#8203;</a></h1>
<p>记录开发中所遇问题及其解法与css学习笔记</p>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./bfc.html">BFC</a></li>
<li><a href="./box.html">盒模型</a></li>
<li><a href="./flex.html">弹性布局</a></li>
<li><a href="./ifc.html">IFC</a></li>
<li><a href="./level.html">CSS层级关系</a></li>
<li><a href="./p1.html">CSS伪元素before与after</a></li>
<li><a href="./p2.html">表格斑马纹</a></li>
<li><a href="./pseudo-class.html">伪类</a></li>
<li><a href="./pseudo-element.html">伪元素</a></li>
<li><a href="./reflow.html">回流与重绘</a></li>
<li><a href="./selectors.html">css选择器</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ES6 学习笔记]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/es6/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/es6/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[此笔记主要记载ES6新增且最常用的一些特性,并书写了对应的demo
借鉴了官方的文档和互联网上的一些博客与电子书，然后结合个人经验写成。由于经验有限，难免存在诸多疏漏或者理解不到位的地方，还请斧正！
]]></description>
            <content:encoded><![CDATA[<h1 id="es6-学习笔记" tabindex="-1">ES6 学习笔记 <a class="header-anchor" href="#es6-学习笔记" aria-label="Permalink to “ES6 学习笔记”">&#8203;</a></h1>
<p>此笔记主要记载ES6新增且最常用的一些特性,并书写了对应的demo</p>
<p>借鉴了官方的文档和互联网上的一些博客与电子书，然后结合个人经验写成。由于经验有限，难免存在诸多疏漏或者理解不到位的地方，还请斧正！</p>
<div  class="tip custom-block"><p class="custom-block-title">参考</p>
<p><a href="https://es6.ruanyifeng.com/" target="_blank" rel="noreferrer">1. ECMAScript6入门</a><br/>
<a href="https://wangdoc.com/javascript/" target="_blank" rel="noreferrer">2. javascript教程</a><br/>
3. 课程网站视频资料</p>
</div>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[HTML相关内容]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/html/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/html/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[目录
* 语义化标签]]></description>
            <content:encoded><![CDATA[<h1 id="html相关内容" tabindex="-1">HTML相关内容 <a class="header-anchor" href="#html相关内容" aria-label="Permalink to “HTML相关内容”">&#8203;</a></h1>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./semantic.html">语义化标签</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[javascript]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/js/index copy.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/js/index copy.html</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[记录面试所遇的与javascript相关的代码题
 目录
* 实现async/await
* 闭包调用
* 实现深拷贝
* 笔试题-数组去重
* 如何实现变量a同时等于多个值
* 实现调用就执行一次的]]></description>
            <content:encoded><![CDATA[<h1 id="javascript" tabindex="-1">javascript <a class="header-anchor" href="#javascript" aria-label="Permalink to “javascript”">&#8203;</a></h1>
<p>记录面试所遇的与javascript相关的代码题</p>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./async.html">实现async/await</a></li>
<li><a href="./closureUse.html">闭包调用</a></li>
<li><a href="./deepClone.html">实现深拷贝</a></li>
<li><a href="./duplicate.html">笔试题-数组去重</a></li>
<li><a href="./equalA.html">如何实现变量a同时等于多个值</a></li>
<li><a href="./immed-setInterval.html">实现调用就执行一次的定时器</a></li>
<li><a href="./inherit.html">继承实现</a></li>
<li><a href="./instanceof.html">实现instanceOf</a></li>
<li><a href="./judgeDate.html">判断两个时间是否在同一周</a></li>
<li><a href="./mergeRequest.html">场景题-请求合并</a></li>
<li><a href="./myApply.html">实现apply</a></li>
<li><a href="./myBind.html">实现bind</a></li>
<li><a href="./myCall.html">实现call</a></li>
<li><a href="./myNew.html">实现一下new</a></li>
<li><a href="./promiseAll.html">实现promiseAll</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[简介]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/js/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/js/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[简介
此部分记载学习与业务开发中所遇问题及解法和了解到的一些语言特性
 目录
* apply,call,bind 的异同
* 箭头函数?
* blob与file
* 定时器
* 闭包
* 浅拷贝与深拷]]></description>
            <content:encoded><![CDATA[<h1 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to “简介”">&#8203;</a></h1>
<p>此部分记载学习与业务开发中所遇问题及解法和了解到的一些语言特性</p>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./apply.html">apply,call,bind 的异同</a></li>
<li><a href="./arrowfun.html">箭头函数?</a></li>
<li><a href="./blob.html">blob与file</a></li>
<li><a href="./clock.html">定时器</a></li>
<li><a href="./closure.html">闭包</a></li>
<li><a href="./copy.html">浅拷贝与深拷贝</a></li>
<li><a href="./currying.html">柯里化(Currying)</a></li>
<li><a href="./delete.html">delete</a></li>
<li><a href="./ecmathis.html">ECMAScript规范解读this(未完待续)</a></li>
<li><a href="./es6+.html">ES6+的一些新语法糖和方法整理</a></li>
<li><a href="./eventloop.html">Event Loop</a></li>
<li><a href="./float.html">浮点数</a></li>
<li><a href="./garbage.html">垃圾回收机制</a></li>
<li><a href="./getElement.html">获取dom元素的几种方式</a></li>
<li><a href="./likearray.html">类数组与arguments</a></li>
<li><a href="./p0.html">学习过程中学到的一些取巧之法</a></li>
<li><a href="./p1.html">js获取某年某月的天数</a></li>
<li><a href="./p2.html">日期格式化</a></li>
<li><a href="./p3.html">数组扁平化的多种方案</a></li>
<li><a href="./p4.html">判断数据类型的方案</a></li>
<li><a href="./p5.html">文件上传下载</a></li>
<li><a href="./promise.html">Promise</a></li>
<li><a href="./prototype.html">原型与原型链</a></li>
<li><a href="./runStack.html">执行上下文栈</a></li>
<li><a href="./runcontext.html">执行上下文</a></li>
<li><a href="./scope.html">作用域</a></li>
<li><a href="./scopeLink.html">作用域链</a></li>
<li><a href="./symbol.html">Symbol 的用法</a></li>
<li><a href="./throttling.html">节流与防抖</a></li>
<li><a href="./typeConvert.html">JavaScript中的类型转换规则</a></li>
<li><a href="./valuePass.html">参数按值传递</a></li>
<li><a href="./variableObject.html">变量对象</a></li>
<li><a href="./asyncawait.html">async 及 await 的特点，它们的优点和缺点分别是什么？await 原理是什么？</a></li>
<li><a href="./changeArr.html">数组哪些方法会改变自身</a></li>
<li><a href="./diff-for-in-of.html">for-of与for-in的区别</a></li>
<li><a href="./equal.html">== 和 === 有什么区别</a></li>
<li><a href="./es6.html">ES6面试问题</a></li>
<li><a href="./event.html">事件的触发过程是怎么样的？知道什么是事件代理嘛？</a></li>
<li><a href="./getBool.html">将任意类型转为Boolean的方案</a></li>
<li><a href="./instanceof.html">instanceof能正确判断对象的原因是什么</a></li>
<li><a href="./judgeArr.html">如何判断数组</a></li>
<li><a href="./judgeObj.html">如何判断变量类型是对象</a></li>
<li><a href="./module.html">为什么要使用模块化？有哪几种方式可以实现模块化，各有什么特点？</a></li>
<li><a href="./nullobj.html">null是对象吗</a></li>
<li><a href="./numNotEqual.html">为什么0.1+0.2!=0.3</a></li>
<li><a href="./objDiffPrim.html">对象类型和原始类型的不同之处</a></li>
<li><a href="./objparam.html">函数参数是对象会发生什么问题</a></li>
<li><a href="./onload-ready.html">window.onload与document.ready执行顺序</a></li>
<li><a href="./primitiveType.html">原始类型有哪些</a></li>
<li><a href="./promise.html">Promise 的特点是什么，分别有什么优缺点？什么是 Promise 链？Promise 构造函数执行和 then 函数执行有什么区别？</a></li>
<li><a href="./this.html">如何正确判断 this？箭头函数的 this 是什么？</a></li>
<li><a href="./typeof.html">typeof能否正常判断类型</a></li>
<li><a href="./v8garbage.html">V8 下的垃圾回收机制是怎么样的？</a></li>
<li><a href="./async.html">实现async/await</a></li>
<li><a href="./closureUse.html">闭包调用</a></li>
<li><a href="./deepClone.html">实现深拷贝</a></li>
<li><a href="./duplicate.html">笔试题-数组去重</a></li>
<li><a href="./equalA.html">如何实现变量a同时等于多个值</a></li>
<li><a href="./immed-setInterval.html">实现调用就执行一次的定时器</a></li>
<li><a href="./inherit.html">继承实现</a></li>
<li><a href="./instanceof.html">实现instanceOf</a></li>
<li><a href="./judgeDate.html">判断两个时间是否在同一周</a></li>
<li><a href="./mergeRequest.html">场景题-请求合并</a></li>
<li><a href="./myApply.html">实现apply</a></li>
<li><a href="./myBind.html">实现bind</a></li>
<li><a href="./myCall.html">实现call</a></li>
<li><a href="./myNew.html">实现一下new</a></li>
<li><a href="./promiseAll.html">实现promiseAll</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[译：使用现代的 Node.js 构建简单的CLI工具]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/node/standard-node-cli.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/node/standard-node-cli.html</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[只使用 Node.js 的标准库，不安装任何外部依赖，写一个命令行工具]]></description>
            <content:encoded><![CDATA[<h1 id="译-使用现代的-node-js-构建简单的cli工具" tabindex="-1">译：使用现代的 Node.js 构建简单的CLI工具 <a class="header-anchor" href="#译-使用现代的-node-js-构建简单的cli工具" aria-label="Permalink to “译：使用现代的 Node.js 构建简单的CLI工具”">&#8203;</a></h1>
<blockquote>
<p>原文地址： <a href="https://evertpot.com/node-changelog-cli-tool/" target="_blank" rel="noreferrer">https://evertpot.com/node-changelog-cli-tool/</a>
<br/>作者： <a href="https://evertpot.com/" target="_blank" rel="noreferrer">Evert Pot</a>
<br/>发布时间：2023-02-13</p>
</blockquote>
<p><strong>只使用 Node.js 的标准库，不安装任何外部依赖，写一个命令行工具。</strong></p>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>作者是多个开源项目的维护者，长久以来都是手动维护项目的变更日志（<code>changelog</code>）。</p>
<p>下面是项目 <a href="https://github.com/curveball/a12n-server/" target="_blank" rel="noreferrer">a12n-server</a> 的变更日志示例：</p>
<div class="language-md"><button title="Copy Code" class="copy"></button><span class="lang">md</span><pre><!--::markdown-it-async::5pzzkuuy4irnaickc3uwn::--><code>0.22.0 (2022-09-27)
-------------------

Warning note for upgraders. This release has a database migration on the
`oauth2_tokens` table. For most users this is the largest table, some
downtime may be expected while the server runs its migrations.

* #425: Using a `client_secret` is now supported with `authorization_code`,
  and it&#039;s read from either the request body or HTTP Basic Authorization
  header.
* The service now keeps track when issuing access tokens, whether those tokens
  have used a `client_secret` or not, which `grant_type` was used to issue them
  and what scopes were requested. This work is done to better support OAuth2
  scopes in the future, and eventually OpenID Connect.
* Fixed broken &#039;principal uri&#039; in introspection endpoint response.
* OAuth2 service is almost entirely rewritten.
* The number of tokens issued is now displayed on the home page.
* Large numbers are now abbreviated with `K` and `M`.
* #426: Updated to Curveball 0.20.
* #427: Typescript types for the database schema are now auto-generated with
  `mysql-types-generator`.</code></pre>
</div><p>内容使用<code>markdown</code>编写的。你可能会想：Git不是有 <code>commit</code> 日志吗？为什么要费力手写这个呢？</p>
<p>原因是它们的受众不一样。我希望让用户关注到相对重要的变更事项，并同时注意到变化对用户带来的影响。</p>
<p>我觉得写一个命令行工具来做这些事会更方便，维护多个项目（如此多的变更）也更容易一些。所以，<a href="https://github.com/evert/changelog-tool" target="_blank" rel="noreferrer">我就做了 changelog-tool</a>！如果你想知道这背后涉及了哪些技术选择，请接着往下阅读。</p>
<h2 id="目标-特色" tabindex="-1">目标&amp;特色 <a class="header-anchor" href="#目标-特色" aria-label="Permalink to “目标&amp;特色”">&#8203;</a></h2>
<p>工具已支持的功能：</p>
<ul>
<li>重新格式化日志（有点像美化）（ <code>changelog format</code> ）;</li>
<li>通过命令行添加一行日志（ <code>changelog add --minor -m &quot;New feature&quot;</code> ）;</li>
<li>自动设置发布日期（ <code>changelog release</code> ）;</li>
<li>将特定版本的日志导入标准输出，以便其他工具可以使用（例如与GitHub发布集成）。</li>
</ul>
<p>我还有一些非功能性的需求：</p>
<ul>
<li>使用最新的 <code>Node.js</code> 特性;</li>
<li>使用最新的 <code>JavaScript</code> 标准和特性（ESM）;</li>
<li>避免非必要的外部依赖；</li>
<li>低维护成本。</li>
</ul>
<p>想立即找到这个工具吗？它是开源的，你只需访问 <a href="https://github.com/evert/changelog-tool" target="_blank" rel="noreferrer">Github</a>。</p>
<h2 id="原理解析" tabindex="-1">原理解析 <a class="header-anchor" href="#原理解析" aria-label="Permalink to “原理解析”">&#8203;</a></h2>
<h3 id="esm-typescript-esm" tabindex="-1">ESM &amp; Typescript ESM <a class="header-anchor" href="#esm-typescript-esm" aria-label="Permalink to “ESM &amp; Typescript ESM”">&#8203;</a></h3>
<p><code>ESM</code> 模块现在使用起来已经非常丝滑了。这是习惯上的一个小改变，但我一般建议是将文件保存为 <code>.mjs</code> 来使用 <code>ESM</code>。</p>
<p>下面是 <code>parse.mjs</code> 的前几行代码：</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::9ib1bji7zzi7v9drlcjj::--><code>import { readFile } from &#039;node:fs/promises&#039;
import { Changelog, VersionLog } from &#039;./changelog.mjs&#039;

/**
 * @param {string} filename
 * @returns {Promise&lt;Changelog&gt;}
 */
export async function parseFile(filename) {
  return parse(
    await readFile(filename, &#039;utf-8&#039;)
  )
}</code></pre>
</div><p>CommonJS -&gt; ESM 的过渡并非没有痛苦，但对于像这样的新项目来说，它是非常理想的选择。（顶层 <code>await</code> 🎉）</p>
<p>我还选择不使用 <code>Typescript</code> 编写代码，取而代之的是使用 <code>JSDoc</code> 注释（上面是 <code>@param</code> 和 <code>@returns</code> 注释）。</p>
<p>当然不是每个人都知道不写 <code>.ts</code> 文件也可获得和 <code>Typescript</code> 一样的体验。 Typescript 也可以严格地检查 <code>Javascript</code> 文件。</p>
<p>这样做的好处是项目不需要构建步骤了。甚至在开发过程中不需要用到 <code>Typescript</code>，降低了上手门槛。</p>
<p>这是我的简化后的 <code>tsconfig.json</code> 配置文件：</p>
<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre><!--::markdown-it-async::g5ryc5duyzhh2pg5s3d4n::--><code>{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;es2022&quot;,
    &quot;module&quot;: &quot;esnext&quot;,
    &quot;rootDir&quot;: &quot;./&quot;,
    &quot;allowJs&quot;: true,
    &quot;checkJs&quot;: true,

    &quot;moduleResolution&quot;: &quot;node&quot;,

    &quot;noEmit&quot;: true,
    &quot;strict&quot;: true,
    &quot;useUnknownInCatchVariables&quot;: false

  }
}</code></pre>
</div><p>如果您想了解更多信息，<code>Typescript</code> 文档有一个页面详细介绍了<a href="https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html" target="_blank" rel="noreferrer">支持的 JSDoc 注释</a>。</p>
<h3 id="命令行参数解析" tabindex="-1">命令行参数解析 <a class="header-anchor" href="#命令行参数解析" aria-label="Permalink to “命令行参数解析”">&#8203;</a></h3>
<p>CLI 工具需要支持解析命令行选项参数(option)。从 Node 18.3（向后移植到了 Node 16.17）开始，Node 内置了一个参数解析的方法。</p>
<p>下面是代码示例：</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::70wu4zbjpzljk6ovt9vjc::--><code>import { parseArgs } from &#039;node:util&#039;

const { positionals, values } = parseArgs({
  options: {
    help: {
      type: &#039;boolean&#039;,
      short: &#039;h&#039;,
      default: false,
    },
    all: {
      type: &#039;boolean&#039;,
      default: false,
    },
    message: {
      type: &#039;string&#039;,
      short: &#039;m&#039;
    },
    patch: { type: &#039;boolean&#039; },
    minor: { type: &#039;boolean&#039; },
    major: { type: &#039;boolean&#039; },
  },
  allowPositionals: true,
})</code></pre>
</div><p>这段配置代码添加了诸如 <code>--major</code> 这些参数的解析支持，这样就可以使用 <code>--message &quot;hello!&quot;</code> 指定消息，也可以使用 <code>-m &quot;Hi&quot;</code> 简写的方式替代。</p>
<p>它能完成所有工作吗？不！在一些复杂的工具中，还会用到彩色打印，自动创建帮助信息等，但这样就需要引入许多额外的第三方依赖。</p>
<p>就我而言，已经够用了。</p>
<p>可以查看 <a href="https://nodejs.org/api/util.html#utilparseargsconfig" target="_blank" rel="noreferrer">Node.js 对应文档</a>了解更详细的内容。</p>
<h3 id="测试" tabindex="-1">测试 <a class="header-anchor" href="#测试" aria-label="Permalink to “测试”">&#8203;</a></h3>
<p>大多数人可能会使用 <code>Jest</code> 或 <code>Mocha</code> 作为测试框架，但从 Node 18（也向后移植到 16）开始，Node 内置了运行测试用例的能力。</p>
<p>它的API类似于 <code>Mocha</code> 和 <code>Jest</code> ，包含 <code>it</code> 、 <code>test</code> 、 <code>describe</code> 、 <code>before</code> 等关键字。</p>
<p>下面是一个单侧的示例：</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::j89ycxz59hqy8mjr419gb::--><code>// @ts-check
import * as assert from &#039;node:assert&#039;
import { test } from &#039;node:test&#039;
import { parse } from &#039;../parse.mjs&#039;

test(&#039;Parsing changelog metadata&#039;, async () =&gt; {
  const input = `Time for a change
=========

0.2.0 (????-??-??)
------------------

* Implemented the &#039;list&#039; command.
* Added testing framework.

0.1.0 (2023-02-08)
------------------

* Implemented the &#039;help&#039; and &#039;init&#039; commands.
*
`

  const result = await parse(input)

  assert.equal(&#039;Time for a change&#039;, result.title)
  assert.equal(2, result.versions.length)

  assert.equal(null, result.versions[0].date)
  assert.equal(&#039;0.2.0&#039;, result.versions[0].version)
  assert.equal(&#039;2023-02-08&#039;, result.versions[1].date)
  assert.equal(&#039;0.1.0&#039;, result.versions[1].version)
})</code></pre>
</div><p>要执行测试，只需运行 <code>node --test</code> 指令即可。无需额外配置，它将自动扫描遵循规范的目录和单测文件。</p>
<p>Node 18 测试输出有点简陋，它是 <code>TAP</code> 格式，如下所示：</p>
<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre><!--::markdown-it-async::kvo3q2bmjvodo3zjc3dmsv::--><code>TAP version 13
# Subtest: /home/evert/src/changelog-tool/test/parse.mjs
    # Subtest: Parsing changelog metadata
    ok 1 - Parsing changelog metadata
      ---
      duration_ms: 1.713409
      ...
    # Subtest: Parsing changelog entries
    ok 2 - Parsing changelog entries
      ---
      duration_ms: 0.2595
      ...
    # Subtest: Preface and postface
    ok 3 - Preface and postface
      ---
      duration_ms: 0.193591
      ...
    1..3
ok 1 - /home/evert/src/changelog-tool/test/parse.mjs
  ---
  duration_ms: 70.901055
  ...
1..1
# tests 1
# pass 1
# fail 0
# cancelled 0
# skipped 0
# todo 0
# duration_ms 81.481441</code></pre>
</div><p>坦白说，用了这个之后我不确定是否还会继续再使用 <code>Mocha</code>。毕竟我已经用了十多年了，还是有许多不错的功能，我认为除了 Node 已经支持的外 <code>Mocha</code> 里还有一些我需要的功能。</p>
<p>一些链接:</p>
<ul>
<li><a href="https://nodejs.org/api/test.html" target="_blank" rel="noreferrer">node:test package</a>;</li>
<li><a href="https://nodejs.org/api/assert.html" target="_blank" rel="noreferrer">node:assert package</a>;</li>
<li><a href="https://nodejs.org/api/test.html#mocking" target="_blank" rel="noreferrer">Mocking in node</a>.</li>
</ul>
<h3 id="带注释的-package-json" tabindex="-1">带注释的 package.json <a class="header-anchor" href="#带注释的-package-json" aria-label="Permalink to “带注释的 package.json”">&#8203;</a></h3>
<p>我想以我配置的 <code>package.json</code> 来结束这篇文章，这样你就可以看到前面内容是如何联系到一起的。（如果 npm 支持 JSON5，​​这样我就可以将我的注释保留在包中 😭）。</p>
<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre><!--::markdown-it-async::y68av8ud7jezg147f8zp::--><code>{
  // 包的名称
  &quot;name&quot;: &quot;changelog-tool&quot;,

  // 包的版本号
  &quot;version&quot;: &quot;0.5.0&quot;,

  // 这将显示在NPM搜索结果中
  &quot;description&quot;: &quot;A CLI tool for manipulating changelogs&quot;,

  // 这告诉Node这是一个ESM包
  // 当然不是严格需要的，如果我们在每个地方都是使用 .mjs
  &quot;type&quot;: &quot;module&quot;,

  // 如果需要在编码的时候使用此包中的方法（不是 CLI 中），则需要在这里指定导出的模块入口文件
  &quot;main&quot;: &quot;index.mjs&quot;,

  &quot;scripts&quot;: {
    // 运行测试用例
    &quot;test&quot;: &quot;node --test&quot;,

    // 我喜欢让 Typescript 在终端中运行，以便有任何问题即时的警告我
    &quot;watch&quot;: &quot;tsc --watch&quot;
  },

  // 方便更好的在 npmjs.org 上发现此包
  &quot;keywords&quot;: [
    &quot;changelog&quot;,
    &quot;markdown&quot;
  ],

  // 作者信息
  &quot;author&quot;: &quot;Evert Pot (https://evertpot.com/)&quot;,

  // 做任何你想做的事（MIT协议基本没有约束）
  &quot;license&quot;: &quot;MIT&quot;,

  &quot;engine&quot;: {
    // 警告尚未升级的用户
    &quot;node&quot;: &quot;&gt;16&quot;
  },

  &quot;bin&quot;: {
    // 当人们安装这个包时，可以通过 `npx changelog` 执行。
    // 如果全局安装了这个包，就会有一个 `changelog` 命令
    &quot;changelog&quot;: &quot;./cli.mjs&quot;
  },
  &quot;devDependencies&quot;: {
    // 唯一的 2 个依赖项。如果你想？甚至不需要这些包
    &quot;@types/node&quot;: &quot;^18.11.19&quot;,
    &quot;typescript&quot;: &quot;^4.9.5&quot;
  }
}</code></pre>
</div><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">&#8203;</a></h2>
<p>我喜欢创造新事物并深思熟虑地做出每一个决定。</p>
<p>结果是我更有可能最终得到一些简约、维护成本低的东西，并且让我对所使用的工具有更深入的理解。</p>
<p>未来我可能会再次做出这些选择。Node 的测试工具快速又简单，ESM 也非常Nice，还不需要引入构建，对于我这种规模的项目来说，感觉非常合适。</p>
<p><strong>我希望这能鼓励将来的人从空目录来开始他们的下一个项目，而不是复制大型项目模板。</strong></p>
<p><a href="https://github.com/evert/changelog-tool" target="_blank" rel="noreferrer">Github 上的 changelog-tool 项目</a>。</p>
<p><em>最后一句话确实挺值得思考的，现在好像无论做什么项目，都想先找个模板然后才开始🤔</em></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[正则表达式]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/regexp/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/regexp/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[# 正则表达式

记录业务开发中所遇到的一些问题及解法
## 常用关键字
|     符号     |            作用             |   用法示例    |           解释           |
| :]]></description>
            <content:encoded><![CDATA[<h1 id="正则表达式" tabindex="-1">正则表达式 <a class="header-anchor" href="#正则表达式" aria-label="Permalink to “正则表达式”">&#8203;</a></h1>
<p>记录业务开发中所遇到的一些问题及解法</p>
<h2 id="常用关键字" tabindex="-1">常用关键字 <a class="header-anchor" href="#常用关键字" aria-label="Permalink to “常用关键字”">&#8203;</a></h2>
<table tabindex="0">
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">用法示例</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">|</td>
<td style="text-align:center">或者(OR)</td>
<td style="text-align:center">/yes|no/</td>
<td style="text-align:center">匹配yes或者no</td>
</tr>
<tr>
<td style="text-align:center">i</td>
<td style="text-align:center">忽略字母大小写</td>
<td style="text-align:center">/h/i</td>
<td style="text-align:center">匹配h或者H</td>
</tr>
<tr>
<td style="text-align:center">g</td>
<td style="text-align:center">查询整个字符串</td>
<td style="text-align:center">/ab/gi</td>
<td style="text-align:center">匹配所有的ab不区分大小写</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">匹配任意字符</td>
<td style="text-align:center">/.un/</td>
<td style="text-align:center">匹配run,gun,fun等</td>
</tr>
<tr>
<td style="text-align:center">[]</td>
<td style="text-align:center">匹配中括号中的一个字符</td>
<td style="text-align:center">/a[sdf]b/</td>
<td style="text-align:center">匹配asb,adb,afb</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">[]中限定一个范围</td>
<td style="text-align:center">/[a-z]/</td>
<td style="text-align:center">匹配任意小写字母</td>
</tr>
<tr>
<td style="text-align:center">[^]</td>
<td style="text-align:center">不匹配指定的内容</td>
<td style="text-align:center">/[^0-9]ab/</td>
<td style="text-align:center">不包括数字母开头的*ab</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">匹配1个或多个</td>
<td style="text-align:center">/a+/</td>
<td style="text-align:center">匹配a,aa,aaa等</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">匹配0个或多个</td>
<td style="text-align:center">/ab*/</td>
<td style="text-align:center">匹配a,ab,abbb等</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">匹配0个或1个</td>
<td style="text-align:center">/ab?/</td>
<td style="text-align:center">匹配a,ab</td>
</tr>
<tr>
<td style="text-align:center">.*?</td>
<td style="text-align:center">惰性匹配(非贪婪)</td>
<td style="text-align:center">/&lt;.*?&gt;/</td>
<td style="text-align:center">匹配&lt;xxx&gt;或者&lt;/xxx&gt;等</td>
</tr>
<tr>
<td style="text-align:center">.*</td>
<td style="text-align:center">匹配(贪婪)</td>
<td style="text-align:center">/&lt;.*&gt;/</td>
<td style="text-align:center">匹配&lt;xx&gt;absada&lt;/xx&gt;</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">匹配开头</td>
<td style="text-align:center">/^ab/</td>
<td style="text-align:center">匹配开头是ab的字符串:abc</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">匹配结尾</td>
<td style="text-align:center">/ab$/</td>
<td style="text-align:center">匹配结尾是ab的字符串:dab</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td style="text-align:center">等价于[a-zA-Z0-9_]</td>
<td style="text-align:center">/\w/</td>
<td style="text-align:center">匹配数字,字母,下划线</td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td style="text-align:center">等价于[^a-zA-Z0-9_]</td>
<td style="text-align:center">/\W/</td>
<td style="text-align:center">匹配非数字,字母,下划线</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td style="text-align:center">等价于[0-9]</td>
<td style="text-align:center">/\d/</td>
<td style="text-align:center">匹配数字</td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td style="text-align:center">等价于[^0-9]</td>
<td style="text-align:center">/\D/</td>
<td style="text-align:center">匹配非数字</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td style="text-align:center">等价于[ \r\t\f\n\v]</td>
<td style="text-align:center">/\s/</td>
<td style="text-align:center">匹配空格,换行,tab等</td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td style="text-align:center">等价于[^ \r\t\f\n\v]</td>
<td style="text-align:center">/\S/</td>
<td style="text-align:center">匹配非空格,换行,tab等</td>
</tr>
<tr>
<td style="text-align:center">{x,y}</td>
<td style="text-align:center">限定个数</td>
<td style="text-align:center">/a{1,2}/</td>
<td style="text-align:center">匹配1-2个a</td>
</tr>
<tr>
<td style="text-align:center">{x,}</td>
<td style="text-align:center">限定个数</td>
<td style="text-align:center">/a{1,}/</td>
<td style="text-align:center">匹配1-n个a</td>
</tr>
<tr>
<td style="text-align:center">{x}</td>
<td style="text-align:center">限定个数</td>
<td style="text-align:center">/a{1}/</td>
<td style="text-align:center">匹配1个a</td>
</tr>
<tr>
<td style="text-align:center">(?:pattern)</td>
<td style="text-align:center">匹配pattern但不获取匹配结果</td>
<td style="text-align:center">/a(?:b|c)/</td>
<td style="text-align:center">等价于ab|ac</td>
</tr>
<tr>
<td style="text-align:center">(?=pattern)</td>
<td style="text-align:center">正向肯定预查</td>
<td style="text-align:center">/a(?=b|c)/</td>
<td style="text-align:center">匹配ab,ac中的a</td>
</tr>
<tr>
<td style="text-align:center">(?!pattern)</td>
<td style="text-align:center">正向否定预查</td>
<td style="text-align:center">/a(!=b|c)/</td>
<td style="text-align:center">匹配ad中的a</td>
</tr>
<tr>
<td style="text-align:center">(?&lt;=pattern)</td>
<td style="text-align:center">正向肯定预查</td>
<td style="text-align:center">/(?&lt;=a|b&gt;)c/</td>
<td style="text-align:center">匹配ac,bc中的c</td>
</tr>
<tr>
<td style="text-align:center">(?&lt;!pattern)</td>
<td style="text-align:center">反向否定预查</td>
<td style="text-align:center">/(?&lt;!a|b&gt;)c/</td>
<td style="text-align:center">匹配cc,dc中的c</td>
</tr>
</tbody>
</table>
<p><strong>综合示例1</strong></p>
<ul>
<li>用户名由数字和字母组成</li>
<li>不能以数字开头,但可以以数字结尾</li>
<li>字母可以大写也可以小写</li>
<li>用户名必须至少两个字符长,两个字符的用户名只能使用字母作为字符</li>
</ul>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::66cmyf973gxl57k90o6ny::--><code>/^[a-zA-Z]([a-zA-Z]+|\d{2,})\d*$/</code></pre>
</div><h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./p1.html">提取样式表中url()中的内容</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vue知识点记录]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/vue/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/vue/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[:::tip 参考
掘金小册:剖析 Vue.js 内部运行机制
:::
 目录
* 组件通信
* 编译template的过程
* computed 与 watch
* 响应式系统的依赖收集追踪原理
*]]></description>
            <content:encoded><![CDATA[<h1 id="vue知识点记录" tabindex="-1">Vue知识点记录 <a class="header-anchor" href="#vue知识点记录" aria-label="Permalink to “Vue知识点记录”">&#8203;</a></h1>
<div  class="tip custom-block"><p class="custom-block-title">参考</p>
<p><a href="https://juejin.im/book/5a36661851882538e2259c0f" target="_blank" rel="noreferrer">掘金小册:剖析 Vue.js 内部运行机制</a></p>
</div>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./communicate.html">组件通信</a></li>
<li><a href="./compile.html">编译template的过程</a></li>
<li><a href="./computed.html">computed 与 watch</a></li>
<li><a href="./dep.html">响应式系统的依赖收集追踪原理</a></li>
<li><a href="./diff.html">数据状态更新时的差异 diff 及 patch 机制</a></li>
<li><a href="./extend.html">extend API</a></li>
<li><a href="./hook.html">生命周期钩子</a></li>
<li><a href="./keep-alive.html">keep-alive</a></li>
<li><a href="./mechanism.html">运行机制概述</a></li>
<li><a href="./mixin.html">mixin 与 mixins</a></li>
<li><a href="./responsive.html">响应式的基本原理</a></li>
<li><a href="./routing.html">路由原理</a></li>
<li><a href="./showif.html">v-show 与 v-if</a></li>
<li><a href="./vnode.html">实现 VNode 节点</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vue源码学习]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/vueResource/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/vueResource/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[记录Vue源码学习历程,目标是手写一份源码加上注释:smile:
:::参考
Github:ustbhuangyi
::
 目录]]></description>
            <content:encoded><![CDATA[<h1 id="vue源码学习" tabindex="-1">Vue源码学习 <a class="header-anchor" href="#vue源码学习" aria-label="Permalink to “Vue源码学习”">&#8203;</a></h1>
<p>记录Vue源码学习历程,目标是手写一份源码加上注释😄
:::参考
<a href="https://github.com/ustbhuangyi/vue-analysis" target="_blank" rel="noreferrer">Github:ustbhuangyi</a>
::</p>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[算法与数据结构]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/coding/algorithm/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/coding/algorithm/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[整理面试所遇到的相关算法题
 目录
* 大数相加&数字字符串相加
* 斐波拉契数列I
* 斐波拉契数列II
* 堆排序
* 判断是否为对称二叉树
* 单链表转置
* 归并排序
* 最长公共子序列长]]></description>
            <content:encoded><![CDATA[<h1 id="算法与数据结构" tabindex="-1">算法与数据结构 <a class="header-anchor" href="#算法与数据结构" aria-label="Permalink to “算法与数据结构”">&#8203;</a></h1>
<p>整理面试所遇到的相关算法题</p>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./addString.html">大数相加&amp;数字字符串相加</a></li>
<li><a href="./feibo1.html">斐波拉契数列I</a></li>
<li><a href="./feibo2.html">斐波拉契数列II</a></li>
<li><a href="./headSort.html">堆排序</a></li>
<li><a href="./judgeSymmetryTree.html">判断是否为对称二叉树</a></li>
<li><a href="./linkReserve.html">单链表转置</a></li>
<li><a href="./mergeSort.html">归并排序</a></li>
<li><a href="./publicString.html">最长公共子序列长度</a></li>
<li><a href="./publicStringLen.html">最长公共子串</a></li>
<li><a href="./quickSort.html">快速排序</a></li>
<li><a href="./treeLevelTraverse.html">层序遍历二叉树</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[网络相关问题]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/computerBase/Internet/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/computerBase/Internet/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[目录
* Content-Length
* http协议
* TCP与UDP的区别
* TCP协议
* UDP协议]]></description>
            <content:encoded><![CDATA[<h1 id="网络相关问题" tabindex="-1">网络相关问题 <a class="header-anchor" href="#网络相关问题" aria-label="Permalink to “网络相关问题”">&#8203;</a></h1>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./clength.html">Content-Length</a></li>
<li><a href="./http.html">http协议</a></li>
<li><a href="./tcp-udp.html">TCP与UDP的区别</a></li>
<li><a href="./tcp.html">TCP协议</a></li>
<li><a href="./udp.html">UDP协议</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[算法与数据结构]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/computerBase/algorithm/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/computerBase/algorithm/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[目录
* 排序算法是否稳定]]></description>
            <content:encoded><![CDATA[<h1 id="算法与数据结构" tabindex="-1">算法与数据结构 <a class="header-anchor" href="#算法与数据结构" aria-label="Permalink to “算法与数据结构”">&#8203;</a></h1>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./sort.html">排序算法是否稳定</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[简介]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/computerBase/design/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/computerBase/design/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[学习/记录前端经常用到的一些设计模式
:::tip 参考
* 掘进小册:JavaScript 设计模式核⼼原理与应⽤实践
* 书栈网:JavaScript中的设计模式
:::
 目录
* 抽象工厂模式]]></description>
            <content:encoded><![CDATA[<h1 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to “简介”">&#8203;</a></h1>
<p>学习/记录前端经常用到的一些设计模式</p>
<div  class="tip custom-block"><p class="custom-block-title">参考</p>
<ul>
<li><a href="https://juejin.im/book/5c70fc83518825428d7f9dfb/section/5c7163256fb9a049d132c3ed" target="_blank" rel="noreferrer">掘进小册:JavaScript 设计模式核⼼原理与应⽤实践</a></li>
<li><a href="https://www.bookstack.cn/read/design-pattern-in-javascript/README.md" target="_blank" rel="noreferrer">书栈网:JavaScript中的设计模式</a></li>
</ul>
</div>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./abstractfactory.html">抽象工厂模式</a></li>
<li><a href="./factory.html">简单工厂模式</a></li>
<li><a href="./single.html">单例模式</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[记录操作系统相关知识]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/computerBase/os/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/computerBase/os/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[目录
* 进程和线程怎么通信
* 死锁
* 进程与线程的区别
* 进程
* 线程]]></description>
            <content:encoded><![CDATA[<h1 id="记录操作系统相关知识" tabindex="-1">记录操作系统相关知识 <a class="header-anchor" href="#记录操作系统相关知识" aria-label="Permalink to “记录操作系统相关知识”">&#8203;</a></h1>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./communicate.html">进程和线程怎么通信</a></li>
<li><a href="./deadlock.html">死锁</a></li>
<li><a href="./difprothr.html">进程与线程的区别</a></li>
<li><a href="./process.html">进程</a></li>
<li><a href="./thread.html">线程</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[手撕代码]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/interview/code/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/interview/code/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[记录面试中常遇的手撕代码题目
 目录
* 防抖与节流实现
* 模式串匹配
* 居中
* 定时器实现
* 任意进制转换
* 二叉树的遍历]]></description>
            <content:encoded><![CDATA[<h1 id="手撕代码" tabindex="-1">手撕代码 <a class="header-anchor" href="#手撕代码" aria-label="Permalink to “手撕代码”">&#8203;</a></h1>
<p>记录面试中常遇的手撕代码题目</p>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./debounce-throttle.html">防抖与节流实现</a></li>
<li><a href="./kmp.html">模式串匹配</a></li>
<li><a href="./middle-center.html">居中</a></li>
<li><a href="./myClock.html">定时器实现</a></li>
<li><a href="./transfer.html">任意进制转换</a></li>
<li><a href="./treeTraverse.html">二叉树的遍历</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[网络相关问题]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/interview/internet/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/interview/internet/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[目录]]></description>
            <content:encoded><![CDATA[<h1 id="网络相关问题" tabindex="-1">网络相关问题 <a class="header-anchor" href="#网络相关问题" aria-label="Permalink to “网络相关问题”">&#8203;</a></h1>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[小程序相关面试问题]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/interview/mini/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/interview/mini/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[目录
* 与传统移动web的异同
* 小程序特点
* 小程序的原理?]]></description>
            <content:encoded><![CDATA[<h1 id="小程序相关面试问题" tabindex="-1">小程序相关面试问题 <a class="header-anchor" href="#小程序相关面试问题" aria-label="Permalink to “小程序相关面试问题”">&#8203;</a></h1>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./differentweb.html">与传统移动web的异同</a></li>
<li><a href="./feature.html">小程序特点</a></li>
<li><a href="./principle.html">小程序的原理?</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[剑指Offer刷题记录]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/interview/offer/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/interview/offer/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[目录
* 面试题50 第一个只出现一次的字符
* 面试题53 - II. 0～n-1中缺失的数字
* 面试题54. 二叉搜索树的第k大节点
* 面试题55 - I. 二叉树的深度
* 面试题55 - ]]></description>
            <content:encoded><![CDATA[<h1 id="剑指offer刷题记录" tabindex="-1">剑指Offer刷题记录 <a class="header-anchor" href="#剑指offer刷题记录" aria-label="Permalink to “剑指Offer刷题记录”">&#8203;</a></h1>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./p50.html">面试题50 第一个只出现一次的字符</a></li>
<li><a href="./p53-2.html">面试题53 - II. 0～n-1中缺失的数字</a></li>
<li><a href="./p54.html">面试题54. 二叉搜索树的第k大节点</a></li>
<li><a href="./p55-1.html">面试题55 - I. 二叉树的深度</a></li>
<li><a href="./p55.html">面试题55 - II. 平衡二叉树</a></li>
<li><a href="./p58.html">面试题58 - II. 左旋转字符串</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[记录操作系统相关知识]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/interview/os/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/interview/os/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[目录]]></description>
            <content:encoded><![CDATA[<h1 id="记录操作系统相关知识" tabindex="-1">记录操作系统相关知识 <a class="header-anchor" href="#记录操作系统相关知识" aria-label="Permalink to “记录操作系统相关知识”">&#8203;</a></h1>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[关于前端一些综合知识]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/interview/other/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/interview/other/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[目录
* 前端工程化
* 在浏览器中输入URL到页面渲染的整个过程
* typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？
* 对象类型和原始类型的不同之处？函数参数]]></description>
            <content:encoded><![CDATA[<h1 id="关于前端一些综合知识" tabindex="-1">关于前端一些综合知识 <a class="header-anchor" href="#关于前端一些综合知识" aria-label="Permalink to “关于前端一些综合知识”">&#8203;</a></h1>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./engineering.html">前端工程化</a></li>
<li><a href="./inputurl.html">在浏览器中输入URL到页面渲染的整个过程</a></li>
<li><a href="./judgeType.html">typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？</a></li>
<li><a href="./object.html">对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？</a></li>
<li><a href="./promote.html">什么是提升？什么是暂时性死区？var、let 及 const 区别？</a></li>
<li><a href="./prototype.html">如何理解原型？如何理解原型链？</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[性能优化面试题]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/interview/performance/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/interview/performance/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[目录
* 如何加快首屏渲染?]]></description>
            <content:encoded><![CDATA[<h1 id="性能优化面试题" tabindex="-1">性能优化面试题 <a class="header-anchor" href="#性能优化面试题" aria-label="Permalink to “性能优化面试题”">&#8203;</a></h1>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./firstScreenRender.html">如何加快首屏渲染?</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vue面试题]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/interview/vue/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/interview/vue/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[目录]]></description>
            <content:encoded><![CDATA[<h1 id="vue面试题" tabindex="-1">Vue面试题 <a class="header-anchor" href="#vue面试题" aria-label="Permalink to “Vue面试题”">&#8203;</a></h1>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[精准爆头]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/stocks/PrecisionHeadshot/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/stocks/PrecisionHeadshot/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[目录]]></description>
            <content:encoded><![CDATA[<h1 id="精准爆头" tabindex="-1">精准爆头 <a class="header-anchor" href="#精准爆头" aria-label="Permalink to “精准爆头”">&#8203;</a></h1>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[情绪核心]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/stocks/SentimentCore/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/stocks/SentimentCore/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[目录]]></description>
            <content:encoded><![CDATA[<h1 id="情绪核心" tabindex="-1">情绪核心 <a class="header-anchor" href="#情绪核心" aria-label="Permalink to “情绪核心”">&#8203;</a></h1>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[技术杂文集]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[记录一些开发过程中遇到的一些小问题以及解决方案
记录一些开发实践
 目录
* pnpm install 在github actions中运行的问题
* 在提交pr请求后自动部署preview gith]]></description>
            <content:encoded><![CDATA[<h1 id="技术杂文集" tabindex="-1">技术杂文集 <a class="header-anchor" href="#技术杂文集" aria-label="Permalink to “技术杂文集”">&#8203;</a></h1>
<p>记录一些开发过程中遇到的一些小问题以及解决方案</p>
<p>记录一些开发实践</p>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./pnpm-issue-githubactions.html">pnpm install 在github actions中运行的问题</a></li>
<li><a href="./deploy-preview-pr.html">在提交pr请求后自动部署preview github pages</a></li>
<li><a href="./array-buffer.html">实践：利用ArrayBuffer实现预览指定目录下的所有文件的内容</a></li>
<li><a href="./deepin-wemeet.html">在linux-deepin上使用deepin-wine5完美运行腾讯会议/QQ/微信等此类应用</a></li>
<li><a href="./eslint-plugin.html">eslint插件开发教程</a></li>
<li><a href="./faas.html">ServerLess之云函数实践-天气API</a></li>
<li><a href="./fixed-page.html">移动端阻止弹窗下层页面被滑动</a></li>
<li><a href="./forof-idx.html">小技巧：for of中获取index</a></li>
<li><a href="./git-base.html">Git常用的一些基本操作</a></li>
<li><a href="./js-cover.html">向页面注入js实现为图片和文字元素添加透明蒙层</a></li>
<li><a href="./jsencrypt.html">实践：使用jsencrypt配合axios实现非对称加密传输的数据</a></li>
<li><a href="./loadEnv.html">封装dotenv库实现类似Vite加载环境变量的行为</a></li>
<li><a href="./mergefile.html">30行代码实现合并指定目录下的所有文件的内容</a></li>
<li><a href="./mid-autumn-festival.html">马上中秋了，把鼠标指针变为小玉兔</a></li>
<li><a href="./node-require-json.html">Node中require与fs.readFile读取JSON文件的对比</a></li>
<li><a href="./qiniu-imgbed.html">使用免费的七牛云OSS(10G)搭建个人的在线图床</a></li>
<li><a href="./qiniu-oss.html">分享封装的一些七牛云OSS操作方法</a></li>
<li><a href="./ssh-no-pwd-login.html">本地配置SSH免密远程登录服务器</a></li>
<li><a href="./tool-methods.html">工具方法汇总</a></li>
<li><a href="./tx-serverless-node.html">腾讯云Serverless实践-Node.js服务部署</a></li>
<li><a href="./tx-serverless-static.html">腾讯云Serverless实践-静态网站托管</a></li>
<li><a href="./ux.html">为什么'\x1B'.length === 1？\x与\u知识延伸</a></li>
<li><a href="./vite-plugin-monitor1.html">Vite插件开发纪实：vite-plugin-monitor（上）</a></li>
<li><a href="./vite-plugin-monitor2.html">Vite插件开发纪实：vite-plugin-monitor（中）</a></li>
<li><a href="./vite-plugin-monitor3.html">Vite插件开发纪实：vite-plugin-monitor（下）</a></li>
<li><a href="./vite-react-js.html">解决Vite-React项目中js使用jsx语法报错的问题</a></li>
<li><a href="./webapck2vite.html">webpack 项目接入Vite的通用方案介绍</a></li>
<li><a href="./webapck2vite2.html">webpack 项目接入Vite的通用方案介绍-草稿</a></li>
<li><a href="./window-var.html">优雅的处理挂载window上的函数可能不存在的情况</a></li>
<li><a href="./yanglegeyang.html">Mac上抓包秒通关羊了个羊</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[源码学习笔记]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/source/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/source/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[记录一些源码学习笔记
 目录
* 优秀装饰器源码学习（一）：time
* 优秀装饰器源码学习（二）
* 优秀装饰器源码学习（三）
* FileSaver.js源码学习，纯前端实现文件下载，防止浏览器直]]></description>
            <content:encoded><![CDATA[<h1 id="源码学习笔记" tabindex="-1">源码学习笔记 <a class="header-anchor" href="#源码学习笔记" aria-label="Permalink to “源码学习笔记”">&#8203;</a></h1>
<p>记录一些源码学习笔记</p>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./core-decorators-1.html">优秀装饰器源码学习（一）：time</a></li>
<li><a href="./core-decorators-2.html">优秀装饰器源码学习（二）</a></li>
<li><a href="./core-decorators-3.html">优秀装饰器源码学习（三）</a></li>
<li><a href="./file-saver-source.html">FileSaver.js源码学习，纯前端实现文件下载，防止浏览器直接打开预览</a></li>
<li><a href="./objectId.html">源码学习：MongoDB-ObjectId生成原理</a></li>
<li><a href="./vite-loadEnv.html">源码学习：Vite中加载环境变量（loadEnv）的实现</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[学习新知识-分享干货]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/study/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/study/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[买了一大推课程/书籍,收藏了一大推好文,是时候拿出来品一品了
~~摒弃 收藏===学会~~
此部分记录学习新知识过程中的精辟内容与记录笔记
 掘金小册
* x] 你不知道的 Chrome 调试技巧 -]]></description>
            <content:encoded><![CDATA[<h1 id="学习新知识-分享干货" tabindex="-1">学习新知识-分享干货 <a class="header-anchor" href="#学习新知识-分享干货" aria-label="Permalink to “学习新知识-分享干货”">&#8203;</a></h1>
<p>买了一大推课程/书籍,收藏了一大推好文,是时候拿出来品一品了</p>
<p><s>摒弃 收藏===学会</s></p>
<p>此部分记录学习新知识过程中的精辟内容与记录笔记</p>
<h2 id="掘金小册" tabindex="-1">掘金小册 <a class="header-anchor" href="#掘金小册" aria-label="Permalink to “掘金小册”">&#8203;</a></h2>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" id="cbx_0" checked="true" disabled="true"><label for="cbx_0"> <strong>你不知道的 Chrome 调试技巧</strong> - <a href="https://www.frontendwingman.com/Chrome/" target="_blank" rel="noreferrer">开源免费版链接</a> -  Chrome-DevTools 的使用技巧</label></li>
<li class="task-list-item"><input type="checkbox" id="cbx_1" disabled="true"><label for="cbx_1"> <strong>JavaScript 设计模式核⼼原理与应⽤实践</strong> - <a href="https://juejin.cn/book/6844733790204461070" target="_blank" rel="noreferrer">链接</a></label></li>
<li>...稍后整理</li>
</ul>
<h2 id="极客时间" tabindex="-1">极客时间 <a class="header-anchor" href="#极客时间" aria-label="Permalink to “极客时间”">&#8203;</a></h2>
<h2 id="拉钩课程" tabindex="-1">拉钩课程 <a class="header-anchor" href="#拉钩课程" aria-label="Permalink to “拉钩课程”">&#8203;</a></h2>
<h2 id="杂七杂八电子书" tabindex="-1">杂七杂八电子书 <a class="header-anchor" href="#杂七杂八电子书" aria-label="Permalink to “杂七杂八电子书”">&#8203;</a></h2>
<h2 id="小网站" tabindex="-1">小网站 <a class="header-anchor" href="#小网站" aria-label="Permalink to “小网站”">&#8203;</a></h2>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" id="cbx_2" disabled="true"><label for="cbx_2"> <a href="https://www.bookstack.cn/books/design-pattern-in-javascript" target="_blank" rel="noreferrer">书栈网：JavaScript中的设计模式</a></label></li>
</ul>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./chrome-debug1.html">Chrome 调试技巧-基础</a></li>
<li><a href="./chrome-debug2.html">Chrome 调试技巧-Console</a></li>
<li><a href="./chrome-debug3.html">Chrome 调试技巧-Network</a></li>
<li><a href="./chrome-debug4.html">Chrome 调试技巧-Elements</a></li>
<li><a href="./chrome-debug5.html">Chrome 调试技巧-Drawer</a></li>
<li><a href="./chrome-debug6.html">Chrome 调试技巧-workspace</a></li>
<li><a href="./design-patterns0.html">设计模式-设计原则</a></li>
<li><a href="./design-patterns1.html">设计模式-创建型模式</a></li>
<li><a href="./design-patterns2.html">设计模式-结构型模式</a></li>
<li><a href="./ts-decorators.html">学习笔记：TypeScript装饰器</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[nvm ls-remote 只有iojs列表]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/study/nvm-ls-remote.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/study/nvm-ls-remote.html</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[nvm 镜像地址的问题，修改对应环境变量`NVM_NODEJS_ORG_MIRROR`即可
可以使用 淘宝源(`https://npmmirror.com/mirrors/node/`)
查看当前设置]]></description>
            <content:encoded><![CDATA[<h1 id="nvm-ls-remote-只有iojs列表" tabindex="-1">nvm ls-remote 只有iojs列表 <a class="header-anchor" href="#nvm-ls-remote-只有iojs列表" aria-label="Permalink to “nvm ls-remote 只有iojs列表”">&#8203;</a></h1>
<p>nvm 镜像地址的问题，修改对应环境变量<code>NVM_NODEJS_ORG_MIRROR</code>即可</p>
<p>可以使用 淘宝源(<code>https://npmmirror.com/mirrors/node/</code>)</p>
<p>查看当前设置的值</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::zk05cntvuaga82kqfzvgr::--><code>echo $NVM_NODEJS_ORG_MIRROR</code></pre>
</div><h2 id="运行时修改" tabindex="-1">运行时修改 <a class="header-anchor" href="#运行时修改" aria-label="Permalink to “运行时修改”">&#8203;</a></h2>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::kv6l8w7owcsu7kjdd958f7::--><code>NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node nvm ls-remote</code></pre>
</div><h2 id="临时修改环境变量" tabindex="-1">临时修改环境变量 <a class="header-anchor" href="#临时修改环境变量" aria-label="Permalink to “临时修改环境变量”">&#8203;</a></h2>
<p>①</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::lkbsjv93bmm03dmlm2guhks::--><code>export NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node</code></pre>
</div><p>②</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::vpjcb7vtggroadjreiq87::--><code>nvm ls-remote</code></pre>
</div><h2 id="长期修改环境变量" tabindex="-1">长期修改环境变量 <a class="header-anchor" href="#长期修改环境变量" aria-label="Permalink to “长期修改环境变量”">&#8203;</a></h2>
<p>在 <code>~/.zshrc</code> 添加环境变量（使用 bash 可以，修改 .bashrc）</p>
<p>① 使用 vi 修改</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::6cs4ahvwv3a7vgtalj574m::--><code>vi ~/.zshrc</code></pre>
</div><p>② 追加如下值</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::3ahalhi2ndb299tu4svgaz::--><code>export NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node</code></pre>
</div><p>③ vi保存</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::mu9aui4ggg936w1ystzyo::--><code>ESC
:wq</code></pre>
</div><p>④ 重启终端</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[概念知识-理论干货]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/theory/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/theory/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[记录一些大前端发展过程中的一些知识
* 过去
* 现在
* 未来
 目录
* Serverless]]></description>
            <content:encoded><![CDATA[<h1 id="概念知识-理论干货" tabindex="-1">概念知识-理论干货 <a class="header-anchor" href="#概念知识-理论干货" aria-label="Permalink to “概念知识-理论干货”">&#8203;</a></h1>
<p>记录一些大前端发展过程中的一些知识</p>
<ul>
<li>过去</li>
<li>现在</li>
<li>未来</li>
</ul>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./serverless.html">Serverless</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[工程模板搭建]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/tpl/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/tpl/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[记录从0-1的工程模板搭建教程
 目录
* 模板工程搭建：Vue-Cli搭建Vue3/TS/uni-app小程序工程(上)
* 模板工程搭建：Vue-Cli搭建Vue3/TS/uni-app小程序工程]]></description>
            <content:encoded><![CDATA[<h1 id="工程模板搭建" tabindex="-1">工程模板搭建 <a class="header-anchor" href="#工程模板搭建" aria-label="Permalink to “工程模板搭建”">&#8203;</a></h1>
<p>记录从0-1的工程模板搭建教程</p>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./uni-vue3-cli_1.html">模板工程搭建：Vue-Cli搭建Vue3/TS/uni-app小程序工程(上)</a></li>
<li><a href="./uni-vue3-cli_2.html">模板工程搭建：Vue-Cli搭建Vue3/TS/uni-app小程序工程(中)</a></li>
<li><a href="./uni-vue3-cli_3.html">模板工程搭建：Vue-Cli搭建Vue3/TS/uni-app小程序工程(下)</a></li>
<li><a href="./vite-vue3-template.html">开箱即用的Vite-Vue3工程化模板</a></li>
<li><a href="./web-sdk-tpl.html">模板工程搭建：Web-SDK/Library</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[个人作品]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[为我造过的轮子与写过的项目,书写传记
个人精力有限,感兴趣有能力的朋友可以帮忙迭代维护
 目录
* 组装个支持记笔记的CodePen
* ESCheck工具原理解析及增强实现
* 一款检测代码中TOD]]></description>
            <content:encoded><![CDATA[<h1 id="个人作品" tabindex="-1">个人作品 <a class="header-anchor" href="#个人作品" aria-label="Permalink to “个人作品”">&#8203;</a></h1>
<p>为我造过的轮子与写过的项目,书写传记</p>
<p>个人精力有限,感兴趣有能力的朋友可以帮忙迭代维护</p>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./codeNote.html">组装个支持记笔记的CodePen</a></li>
<li><a href="./escheck.html">ESCheck工具原理解析及增强实现</a></li>
<li><a href="./eslint-plugin-todo-ddl.html">一款检测代码中TODO的eslint插件</a></li>
<li><a href="./ewuit.html">实现一个Web UI检测(视觉走查)工具ing</a></li>
<li><a href="./fs-cli.html">从0-1实现文件下载CLI工具</a></li>
<li><a href="./html-inline-js-transform.html">内联JS处理(ES语法降级&amp;内容压缩)</a></li>
<li><a href="./node-cli.html">Node CLI工具原理解析</a></li>
<li><a href="./online-resume.html">我打造的在线简历生成应用</a></li>
<li><a href="./share-snippets.html">助你轻松编写与分享snippet的VsCode插件</a></li>
<li><a href="./sm-cli.html">SourceMap解析CLI工具实现</a></li>
<li><a href="./snippets.html">一个通过NPM包共(分)享代码块的解决方案</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[时光恋人]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/works/time-lover/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/works/time-lover/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[* 实践：给女朋友个性化定制应用-体重记录（一）
* 实践：给女朋友个性化定制应用-体重记录（二）
* 实践：给女朋友个性化定制应用-体重记录（三）]]></description>
            <content:encoded><![CDATA[<h1 id="时光恋人" tabindex="-1">时光恋人 <a class="header-anchor" href="#时光恋人" aria-label="Permalink to “时光恋人”">&#8203;</a></h1>
<ul>
<li><a href="./timeLover-1.html">实践：给女朋友个性化定制应用-体重记录（一）</a></li>
<li><a href="./timeLover-2.html">实践：给女朋友个性化定制应用-体重记录（二）</a></li>
<li><a href="./timeLover-3.html">实践：给女朋友个性化定制应用-体重记录（三）</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[时间管理CLI工具]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/works/time-tools/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/works/time-tools/</guid>
            <pubDate>Tue, 25 Jun 2024 06:37:12 GMT</pubDate>
            <description><![CDATA[目录
* 做一个CLI版的时间管理工具（一）
* 做一个CLI版的时间管理工具（十）
* 做一个CLI版的时间管理工具（11）
* 做一个CLI版的时间管理工具（12）
* 做一个CLI版的时间管理工]]></description>
            <content:encoded><![CDATA[<h1 id="时间管理cli工具" tabindex="-1">时间管理CLI工具 <a class="header-anchor" href="#时间管理cli工具" aria-label="Permalink to “时间管理CLI工具”">&#8203;</a></h1>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./time-tools-1.html">做一个CLI版的时间管理工具（一）</a></li>
<li><a href="./time-tools-10.html">做一个CLI版的时间管理工具（十）</a></li>
<li><a href="./time-tools-11.html">做一个CLI版的时间管理工具（11）</a></li>
<li><a href="./time-tools-12.html">做一个CLI版的时间管理工具（12）</a></li>
<li><a href="./time-tools-13.html">做一个CLI版的时间管理工具（13）</a></li>
<li><a href="./time-tools-14.html">做一个CLI版的时间管理工具（14）</a></li>
<li><a href="./time-tools-15.html">做一个CLI版的时间管理工具（15）</a></li>
<li><a href="./time-tools-2.html">做一个CLI版的时间管理工具（二）</a></li>
<li><a href="./time-tools-3.html">做一个CLI版的时间管理工具（三）</a></li>
<li><a href="./time-tools-4.html">做一个CLI版的时间管理工具（四）</a></li>
<li><a href="./time-tools-5.html">做一个CLI版的时间管理工具（五）</a></li>
<li><a href="./time-tools-6.html">做一个CLI版的时间管理工具（六）</a></li>
<li><a href="./time-tools-7.html">做一个CLI版的时间管理工具（七）</a></li>
<li><a href="./time-tools-8.html">做一个CLI版的时间管理工具（八）</a></li>
<li><a href="./time-tools-9.html">做一个CLI版的时间管理工具（九）</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[git如何清除历史版本]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/coding/github/Git删除当前分支下的所有历史版本与log并同步至GitHub_git如何清除历史版本.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/coding/github/Git删除当前分支下的所有历史版本与log并同步至GitHub_git如何清除历史版本.html</guid>
            <pubDate>Fri, 21 Jun 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[1. Git删除当前分支下的所有历史版本与log并同步至GitHub_git如何清除历史版本-CSDN博客

&gt; 文章目录1. 按2. 方法一2.1. 切换到latest_branch分支下2.]]></description>
            <content:encoded><![CDATA[<h1 id="_1-git删除当前分支下的所有历史版本与log并同步至github-git如何清除历史版本-csdn博客" tabindex="-1">1. Git删除当前分支下的所有历史版本与log并同步至GitHub_git如何清除历史版本-CSDN博客 <a class="header-anchor" href="#_1-git删除当前分支下的所有历史版本与log并同步至github-git如何清除历史版本-csdn博客" aria-label="Permalink to “1. Git删除当前分支下的所有历史版本与log并同步至GitHub_git如何清除历史版本-CSDN博客”">&#8203;</a></h1>
<blockquote>
<h2 id="excerpt" tabindex="-1">Excerpt <a class="header-anchor" href="#excerpt" aria-label="Permalink to “Excerpt”">&#8203;</a></h2>
<p>文章目录1. 按2. 方法一2.1. 切换到latest_branch分支下2.2. 添加所有文件2.3. 提交更改2.4. 删除分支2.5. 将当前分支重命名2.6. 最后，强制更新存储库2.7. 技巧3. 方法二3.1. 先删除.git文件夹3.2. 然后初始化Git（user为你的用户名，repo为你的仓库名）3.3. 提交当前版本的代码1. 按保留大量的历史版本会给存储设施增加负荷，有时候我们需要删除之前的所有历史版本与log，仅保留当前版本的文件。删除master分支下的所有历史版本与log_git如何清除历史版本</p>
</blockquote>
<h4 id="_1-0-0-1-文章目录" tabindex="-1">1.0.0.1. 文章目录 <a class="header-anchor" href="#_1-0-0-1-文章目录" aria-label="Permalink to “1.0.0.1. 文章目录”">&#8203;</a></h4>
<ul>
<li><a href="#git删除当前分支下的所有历史版本与log并同步至github-git如何清除历史版本-csdn博客">Git删除当前分支下的所有历史版本与log并同步至GitHub_git如何清除历史版本-CSDN博客</a>
- <a href="#文章目录">文章目录</a>
<ul>
<li>[1. 按](# -按)</li>
<li>[2. 方法一](# -方法一)
<ul>
<li>[2.1. 切换到latest_branch分支下](# -切换到latest_branch分支下)</li>
<li>[2.2. 添加所有文件](# -添加所有文件)</li>
<li>[2.3. 提交更改](# -提交更改)</li>
<li>[2.4. 删除分支](# -删除分支)</li>
<li>[2.5. 将当前分支重命名](# -将当前分支重命名)</li>
<li>[2.6. 最后，强制更新存储库](# -最后强制更新存储库)</li>
<li>[2.7. 技巧](# -技巧)</li>
</ul>
</li>
<li>[3. 方法二](# -方法二)
<ul>
<li>[3.1. 先删除.git文件夹](# -先删除git文件夹)</li>
<li>[3.2. 然后初始化Git（user为你的用户名，repo为你的仓库名）](# -然后初始化gituser为你的用户名repo为你的仓库名)</li>
<li>[3.3. 提交当前版本的代码](# -提交当前版本的代码)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="_1-1-按" tabindex="-1">1.1. 按 <a class="header-anchor" href="#_1-1-按" aria-label="Permalink to “1.1. 按”">&#8203;</a></h2>
<p>保留大量的历史版本会给存储设施增加负荷，有时候我们需要删除之前的所有历史版本与log，仅保留当前版本的文件。</p>
<p>删除master分支下的所有历史版本与log，只保留当前的版本，并同步至<a href="https://github.com/ripplejourney/ripplejourney.github.io" target="_blank" rel="noreferrer">GitHub</a></p>
<h2 id="_1-2-方法一" tabindex="-1">1.2. 方法一 <a class="header-anchor" href="#_1-2-方法一" aria-label="Permalink to “1.2. 方法一”">&#8203;</a></h2>
<p>先新建一个名为latest_branch的分支，然后将当前master分支中的所有文件添加到latest_branch分支中，接着等待移动完毕后删除master分支，最后把latest_branch这个分支的分支名改为master。</p>
<p>以下是具体实现：</p>
<h3 id="_1-2-1-切换到latest-branch分支下" tabindex="-1">1.2.1. 切换到latest_branch分支下 <a class="header-anchor" href="#_1-2-1-切换到latest-branch分支下" aria-label="Permalink to “1.2.1. 切换到latest_branch分支下”">&#8203;</a></h3>
<div class="language-powershell"><button title="Copy Code" class="copy"></button><span class="lang">powershell</span><pre><!--::markdown-it-async::qpb0f8ocxwemmngsyry1gg::--><code>
git checkout --orphan latest_branch
</code></pre>
</div><h3 id="_1-2-2-添加所有文件" tabindex="-1">1.2.2. 添加所有文件 <a class="header-anchor" href="#_1-2-2-添加所有文件" aria-label="Permalink to “1.2.2. 添加所有文件”">&#8203;</a></h3>
<div class="language-powershell"><button title="Copy Code" class="copy"></button><span class="lang">powershell</span><pre><!--::markdown-it-async::4cgyirjhcwe2dpd0b2az::--><code>git add -A
</code></pre>
</div><h3 id="_1-2-3-提交更改" tabindex="-1">1.2.3. 提交更改 <a class="header-anchor" href="#_1-2-3-提交更改" aria-label="Permalink to “1.2.3. 提交更改”">&#8203;</a></h3>
<div class="language-powershell"><button title="Copy Code" class="copy"></button><span class="lang">powershell</span><pre><!--::markdown-it-async::bphzjtjdg3qm1q9y97zh2b::--><code>git commit -am &quot;清除所有历史版本以减少仓库大小，请重新从远程拷贝此仓库&quot;
</code></pre>
</div><h3 id="_1-2-4-删除分支" tabindex="-1">1.2.4. 删除分支 <a class="header-anchor" href="#_1-2-4-删除分支" aria-label="Permalink to “1.2.4. 删除分支”">&#8203;</a></h3>
<div class="language-powershell"><button title="Copy Code" class="copy"></button><span class="lang">powershell</span><pre><!--::markdown-it-async::pd15wh0jbamsrno87s08ab::--><code>git branch -D master
</code></pre>
</div><h3 id="_1-2-5-将当前分支重命名" tabindex="-1">1.2.5. 将当前分支重命名 <a class="header-anchor" href="#_1-2-5-将当前分支重命名" aria-label="Permalink to “1.2.5. 将当前分支重命名”">&#8203;</a></h3>
<div class="language-powershell"><button title="Copy Code" class="copy"></button><span class="lang">powershell</span><pre><!--::markdown-it-async::qxw1o6lv9gra0en99z61y6::--><code>git branch -m master
</code></pre>
</div><h3 id="_1-2-6-最后-强制更新存储库" tabindex="-1">1.2.6. 最后，强制更新存储库 <a class="header-anchor" href="#_1-2-6-最后-强制更新存储库" aria-label="Permalink to “1.2.6. 最后，强制更新存储库”">&#8203;</a></h3>
<div class="language-powershell"><button title="Copy Code" class="copy"></button><span class="lang">powershell</span><pre><!--::markdown-it-async::htras4m5xtno4ufqapi3nh::--><code>git push -f origin master
</code></pre>
</div><h3 id="_1-2-7-技巧" tabindex="-1">1.2.7. 技巧 <a class="header-anchor" href="#_1-2-7-技巧" aria-label="Permalink to “1.2.7. 技巧”">&#8203;</a></h3>
<p>将如下代码保存在一个bat文件里，然后双击运行即可。</p>
<div class="language-powershell"><button title="Copy Code" class="copy"></button><span class="lang">powershell</span><pre><!--::markdown-it-async::fv006cp394rf4hbszzlzs::--><code>git checkout --orphan latest_branch
git add -A
git commit -am &quot;清除所有历史版本以减少仓库大小，请重新从远程拷贝此仓库&quot;
git branch -D master
git branch -m master
git push -f origin master
</code></pre>
</div><p><img src="./Git删除当前分支下的所有历史版本与log并同步至GitHub_git如何清除历史版本/20190709062953681.png" alt="在这里插入图片描述" loading="lazy">
<img src="./Git删除当前分支下的所有历史版本与log并同步至GitHub_git如何清除历史版本/x-oss-process=image.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="_1-3-方法二" tabindex="-1">1.3. 方法二 <a class="header-anchor" href="#_1-3-方法二" aria-label="Permalink to “1.3. 方法二”">&#8203;</a></h2>
<p>不推荐使用，可能导致git存储库出现问题。思路：直接删除.git文件再初始化仓库</p>
<h3 id="_1-3-1-先删除-git文件夹" tabindex="-1">1.3.1. 先删除.git文件夹 <a class="header-anchor" href="#_1-3-1-先删除-git文件夹" aria-label="Permalink to “1.3.1. 先删除.git文件夹”">&#8203;</a></h3>
<h3 id="_1-3-2-然后初始化git-user为你的用户名-repo为你的仓库名" tabindex="-1">1.3.2. 然后初始化Git（user为你的用户名，repo为你的仓库名） <a class="header-anchor" href="#_1-3-2-然后初始化git-user为你的用户名-repo为你的仓库名" aria-label="Permalink to “1.3.2. 然后初始化Git（user为你的用户名，repo为你的仓库名）”">&#8203;</a></h3>
<div class="language-powershell"><button title="Copy Code" class="copy"></button><span class="lang">powershell</span><pre><!--::markdown-it-async::x0sdr6qbxqekho5tijz7c::--><code>
git init git remote add origin git@github.com:user/repo
</code></pre>
</div><h3 id="_1-3-3-提交当前版本的代码" tabindex="-1">1.3.3. 提交当前版本的代码 <a class="header-anchor" href="#_1-3-3-提交当前版本的代码" aria-label="Permalink to “1.3.3. 提交当前版本的代码”">&#8203;</a></h3>
<div class="language-powershell"><button title="Copy Code" class="copy"></button><span class="lang">powershell</span><pre><!--::markdown-it-async::wivgtl7bx99ebwsdzmnvr::--><code>
git add * git commit -am &#039;message&#039;
</code></pre>
</div><p>最后，强制更新到GitHub：</p>
<div class="language-powershell"><button title="Copy Code" class="copy"></button><span class="lang">powershell</span><pre><!--::markdown-it-async::bllpm6ad88sft7i3qehjnq::--><code>
git push -f origin master
</code></pre>
</div>]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/Git%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E4%B8%8Elog%E5%B9%B6%E5%90%8C%E6%AD%A5%E8%87%B3GitHub_git%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/20190709062953681.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[在提交pr请求后自动部署preview github pages]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/deploy-preview-pr.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/deploy-preview-pr.html</guid>
            <pubDate>Tue, 18 Jun 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[# 在提交pr请求后自动部署preview github pages

> ## Excerpt
> :octocat: 一个GitHub Action，用于为拉取请求（PR）和分支创建GitHub Pages预览 —— EndBug/pages-preview

# Pages Preview

## Table of contents

- [What does it do?](#what-does-it-do)
- [Setup](#setup)
- [Inputs](#inputs)

## What does it do?

A lot of third-party services allow you create preview deployments of branches and pull requests, so that you can use them to review and test your changes. This action allows you to do the same thing, but directly with GitHub Pages.

In particular, this action deploys your website to a different repo, which will contain the previews of all the repos you choose to use this on.

If you're interested in the logic behind this action, you can check out the [flow diagram](docs/flow_diagram.md).

## Setup

### Preview repo

#### Using my template

1. Go to [this template](https://github.com/EndBug/preview-template) and generate your repo from there: click "Use this template", fill in name and description, check that "Include all branches" is ticked, and create the repo.
  It doesn't matter whether you create it as public or private, but remember that the Pages website will always be public.

2. Go into your repo settings, in the Pages tab (Repo settings > Pages) and set "GitHub Actions" as the source.

#### Manually

1. Create a new repo that will host your previews.
  This repo will be used for the previews from all your repositories, so you'll need to set this up only once.

2. Make sure that this repo has two branches: `main` and `gh-pages` (you can also choose different names).
    - `main` should be your default branch, and it will only hold a workflow (and any additional files you want to add, liKE a README, a license, etc.).
    - `gh-pages` will be the branch that will contain the actual previews, and it should be empty.

3. Create a new file in the `main` branch, and name it `.github/workflows/preview.yml`. Then copy the contents of [`dependents/preview-repo.yml`](dependents/preview_repo.yml) into it.
  You shouldn't need to change anything in this file, the config options will all be in the source repo workflow.
  This file might need to be updated if you update the action to a different major version.

4. Go into your repo settings, in the Pages tab (Repo settings > Pages) and set "GitHub Actions" as the source.

### Personal Access Token (PAT)

In order for the action to be able to trigger the deployment in the preview repo from the source repo, you'll need to create a Personal Access Token (PAT).

There are currently two types of PATs: fine-grained, which are more secure but still in beta, and classic. I'd suggest to use fine-grained PATs, but if you can't, you can also use classic PATs.

#### Fine-grained PAT

1. If you're using a GitHub organization, you may have to first enable _Personal Access Tokens_ (PAT) on the Organization's (not yours') Settings at `.../settings/personal-access-tokens-onboarding
1. Go to [Account settings > Developer settings > Fine-grained tokens](https://github.com/settings/tokens?type=beta). For an Org, you must use YOUR (not the Org's) Setttings, and change the _Resource owner_ from you to the Org on this screen.
2. Click on "Generate new token".
3. Give it a recognizable name and set an appropriate expiration date.
4. Make sure that the "Resource owner" is the same user/org that owns the preview repo.
5. Set the "Repository access" to "Only selected repositories" and then select the preview repo.
6. In the "Repository permissions" sections, set "Actions" and "Content" to "Read and write". "Metadata" will also be granted as "Read-only", as it is required for the other two.
7. Click on "Generate token", copy the token and save it somewhere for later.

#### Classic PAT

1. Go to [Account settings > Developer settings > Tokens (classic)](https://github.com/settings/tokens).
2. Click on "Generate new token" > "Generate new token (classic)"
3. Give it a recognizable name and set an appropriate expiration date.
4. Select the `repo` scope.
5. Click on "Generate token", copy the token and save it somewhere for later.

### Source repo

This steps need to be repeated for each repo you want to use this action on.

1. Go to the repo that contains the source code of your website.
2. Go to Repo settings > Secrets and variables > Actions.
3. Create a new repository secret called `PREVIEW_TOKEN` and paste the PAT you created in the previous step.
4. Go back to the repo contents and add the deployment workflow: you can either create a new one or add the same steps to your existing one. Use the [`dependents/source-repo.yml`](dependents/source_repo.yml) file as a template/example.
  Make sure to change the `PREVIEW_REPO` and `PAGES_BASE` env variable, along with the commands needed to build your website.
  Also, make sure to change `EndBug/pages-preview`'s inputs to match your needs: more info on that in the ["Inputs"](#inputs) section of this file.

All done! You're now ready to use the action 🎉

## Inputs

```yaml
- uses: EndBug/pages-preview@v1
  with:
    # The directory in which the website has been built, in the a/b/c format
    build_dir: build

    # The GitHub Pages base URL of the preview repo
    preview_base_url: https://octocat.github.io/preview

    # The repository to push previews to, in the Owner/Name format
    preview_repo: octocat/preview

    # The token to access the preview repo, that you created during setup
    preview_token: ${{ secrets.PREVIEW_TOKEN }}

    # ]]></description>
            <content:encoded><![CDATA[<h1 id="在提交pr请求后自动部署preview-github-pages" tabindex="-1">在提交pr请求后自动部署preview github pages <a class="header-anchor" href="#在提交pr请求后自动部署preview-github-pages" aria-label="Permalink to “在提交pr请求后自动部署preview github pages”">&#8203;</a></h1>
<blockquote>
<h2 id="excerpt" tabindex="-1">Excerpt <a class="header-anchor" href="#excerpt" aria-label="Permalink to “Excerpt”">&#8203;</a></h2>
<p>:octocat: 一个GitHub Action，用于为拉取请求（PR）和分支创建GitHub Pages预览 —— EndBug/pages-preview</p>
</blockquote>
<h1 id="pages-preview" tabindex="-1">Pages Preview <a class="header-anchor" href="#pages-preview" aria-label="Permalink to “Pages Preview”">&#8203;</a></h1>
<h2 id="table-of-contents" tabindex="-1">Table of contents <a class="header-anchor" href="#table-of-contents" aria-label="Permalink to “Table of contents”">&#8203;</a></h2>
<ul>
<li><a href="#what-does-it-do">What does it do?</a></li>
<li><a href="#setup">Setup</a></li>
<li><a href="#inputs">Inputs</a></li>
</ul>
<h2 id="what-does-it-do" tabindex="-1">What does it do? <a class="header-anchor" href="#what-does-it-do" aria-label="Permalink to “What does it do?”">&#8203;</a></h2>
<p>A lot of third-party services allow you create preview deployments of branches and pull requests, so that you can use them to review and test your changes. This action allows you to do the same thing, but directly with GitHub Pages.</p>
<p>In particular, this action deploys your website to a different repo, which will contain the previews of all the repos you choose to use this on.</p>
<p>If you're interested in the logic behind this action, you can check out the <a href="./docs/flow_diagram.html">flow diagram</a>.</p>
<h2 id="setup" tabindex="-1">Setup <a class="header-anchor" href="#setup" aria-label="Permalink to “Setup”">&#8203;</a></h2>
<h3 id="preview-repo" tabindex="-1">Preview repo <a class="header-anchor" href="#preview-repo" aria-label="Permalink to “Preview repo”">&#8203;</a></h3>
<h4 id="using-my-template" tabindex="-1">Using my template <a class="header-anchor" href="#using-my-template" aria-label="Permalink to “Using my template”">&#8203;</a></h4>
<ol>
<li>
<p>Go to <a href="https://github.com/EndBug/preview-template" target="_blank" rel="noreferrer">this template</a> and generate your repo from there: click &quot;Use this template&quot;, fill in name and description, check that &quot;Include all branches&quot; is ticked, and create the repo.
It doesn't matter whether you create it as public or private, but remember that the Pages website will always be public.</p>
</li>
<li>
<p>Go into your repo settings, in the Pages tab (Repo settings &gt; Pages) and set &quot;GitHub Actions&quot; as the source.</p>
</li>
</ol>
<h4 id="manually" tabindex="-1">Manually <a class="header-anchor" href="#manually" aria-label="Permalink to “Manually”">&#8203;</a></h4>
<ol>
<li>
<p>Create a new repo that will host your previews.
This repo will be used for the previews from all your repositories, so you'll need to set this up only once.</p>
</li>
<li>
<p>Make sure that this repo has two branches: <code>main</code> and <code>gh-pages</code> (you can also choose different names).</p>
<ul>
<li><code>main</code> should be your default branch, and it will only hold a workflow (and any additional files you want to add, liKE a README, a license, etc.).</li>
<li><code>gh-pages</code> will be the branch that will contain the actual previews, and it should be empty.</li>
</ul>
</li>
<li>
<p>Create a new file in the <code>main</code> branch, and name it <code>.github/workflows/preview.yml</code>. Then copy the contents of <a href="dependents/preview_repo.yml"><code>dependents/preview-repo.yml</code></a> into it.
You shouldn't need to change anything in this file, the config options will all be in the source repo workflow.
This file might need to be updated if you update the action to a different major version.</p>
</li>
<li>
<p>Go into your repo settings, in the Pages tab (Repo settings &gt; Pages) and set &quot;GitHub Actions&quot; as the source.</p>
</li>
</ol>
<h3 id="personal-access-token-pat" tabindex="-1">Personal Access Token (PAT) <a class="header-anchor" href="#personal-access-token-pat" aria-label="Permalink to “Personal Access Token (PAT)”">&#8203;</a></h3>
<p>In order for the action to be able to trigger the deployment in the preview repo from the source repo, you'll need to create a Personal Access Token (PAT).</p>
<p>There are currently two types of PATs: fine-grained, which are more secure but still in beta, and classic. I'd suggest to use fine-grained PATs, but if you can't, you can also use classic PATs.</p>
<h4 id="fine-grained-pat" tabindex="-1">Fine-grained PAT <a class="header-anchor" href="#fine-grained-pat" aria-label="Permalink to “Fine-grained PAT”">&#8203;</a></h4>
<ol>
<li>If you're using a GitHub organization, you may have to first enable <em>Personal Access Tokens</em> (PAT) on the Organization's (not yours') Settings at `.../settings/personal-access-tokens-onboarding</li>
<li>Go to <a href="https://github.com/settings/tokens?type=beta" target="_blank" rel="noreferrer">Account settings &gt; Developer settings &gt; Fine-grained tokens</a>. For an Org, you must use YOUR (not the Org's) Setttings, and change the <em>Resource owner</em> from you to the Org on this screen.</li>
<li>Click on &quot;Generate new token&quot;.</li>
<li>Give it a recognizable name and set an appropriate expiration date.</li>
<li>Make sure that the &quot;Resource owner&quot; is the same user/org that owns the preview repo.</li>
<li>Set the &quot;Repository access&quot; to &quot;Only selected repositories&quot; and then select the preview repo.</li>
<li>In the &quot;Repository permissions&quot; sections, set &quot;Actions&quot; and &quot;Content&quot; to &quot;Read and write&quot;. &quot;Metadata&quot; will also be granted as &quot;Read-only&quot;, as it is required for the other two.</li>
<li>Click on &quot;Generate token&quot;, copy the token and save it somewhere for later.</li>
</ol>
<h4 id="classic-pat" tabindex="-1">Classic PAT <a class="header-anchor" href="#classic-pat" aria-label="Permalink to “Classic PAT”">&#8203;</a></h4>
<ol>
<li>Go to <a href="https://github.com/settings/tokens" target="_blank" rel="noreferrer">Account settings &gt; Developer settings &gt; Tokens (classic)</a>.</li>
<li>Click on &quot;Generate new token&quot; &gt; &quot;Generate new token (classic)&quot;</li>
<li>Give it a recognizable name and set an appropriate expiration date.</li>
<li>Select the <code>repo</code> scope.</li>
<li>Click on &quot;Generate token&quot;, copy the token and save it somewhere for later.</li>
</ol>
<h3 id="source-repo" tabindex="-1">Source repo <a class="header-anchor" href="#source-repo" aria-label="Permalink to “Source repo”">&#8203;</a></h3>
<p>This steps need to be repeated for each repo you want to use this action on.</p>
<ol>
<li>Go to the repo that contains the source code of your website.</li>
<li>Go to Repo settings &gt; Secrets and variables &gt; Actions.</li>
<li>Create a new repository secret called <code>PREVIEW_TOKEN</code> and paste the PAT you created in the previous step.</li>
<li>Go back to the repo contents and add the deployment workflow: you can either create a new one or add the same steps to your existing one. Use the <a href="dependents/source_repo.yml"><code>dependents/source-repo.yml</code></a> file as a template/example.
Make sure to change the <code>PREVIEW_REPO</code> and <code>PAGES_BASE</code> env variable, along with the commands needed to build your website.
Also, make sure to change <code>EndBug/pages-preview</code>'s inputs to match your needs: more info on that in the <a href="#inputs">&quot;Inputs&quot;</a> section of this file.</li>
</ol>
<p>All done! You're now ready to use the action 🎉</p>
<h2 id="inputs" tabindex="-1">Inputs <a class="header-anchor" href="#inputs" aria-label="Permalink to “Inputs”">&#8203;</a></h2>
<div class="language-yaml"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre><!--::markdown-it-async::vk2h853b1bl3tnxkppkykf::--><code>- uses: EndBug/pages-preview@v1
  with:
    # The directory in which the website has been built, in the a/b/c format
    build_dir: build

    # The GitHub Pages base URL of the preview repo
    preview_base_url: https://octocat.github.io/preview

    # The repository to push previews to, in the Owner/Name format
    preview_repo: octocat/preview

    # The token to access the preview repo, that you created during setup
    preview_token: ${{ secrets.PREVIEW_TOKEN }}

    # --- OPTIONAL ---
    # The name of the environment to use for the deployment
    # Default: &#039;preview&#039;
    deployment_env: development

    # Whether to use the deployments API
    # Default: &#039;true&#039;
    deployments: false

    # The name of the author of the resulting commit
    # Default: the GitHub Actor
    git_author_name: Mona

    # The email of the author of the resulting commit
    # Default: the GitHub Actor&#039;s
    git_author_email: mona@users.noreply.github.com

    # The committer of the resulting commit
    # Default: copies git_author_name
    git_committer_name: GitHub Actions

    # The email of the committer of the resulting commit
    # Default: copies git_author_email
    git_committer_email: 41898282+github-actions[bot]@users.noreply.github.com

    # Whether to comment on PRs
    # Default: &#039;true&#039;
    pr_comment: &#039;false&#039;

    # The name of the branch that hosts the previews
    # Default: gh-pages
    preview_branch: custom-pages-branch

    # The name of the workflow file that contains the comment workflow in the preview repo
    # Default: preview.yml
    preview_workflow_file_name: custom_workflow.yml</code></pre>
</div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[pnpm install 在github actions中运行的问题]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/pnpm-issue-githubactions.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/pnpm-issue-githubactions.html</guid>
            <pubDate>Tue, 18 Jun 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[&gt; :octocat: pnpm install在CI环境中 `GitHub Action` 的默认参数，用于为拉取请求（PR）和分支创建GitHub Pages预览 —— EndBug/pag]]></description>
            <content:encoded><![CDATA[<h1 id="pnpm-install-在github-actions中运行的问题" tabindex="-1">pnpm install 在github actions中运行的问题 <a class="header-anchor" href="#pnpm-install-在github-actions中运行的问题" aria-label="Permalink to “pnpm install 在github actions中运行的问题”">&#8203;</a></h1>
<blockquote>
<h2 id="excerpt" tabindex="-1">Excerpt <a class="header-anchor" href="#excerpt" aria-label="Permalink to “Excerpt”">&#8203;</a></h2>
<p>:octocat: pnpm install在CI环境中 <code>GitHub Action</code> 的默认参数，用于为拉取请求（PR）和分支创建GitHub Pages预览 —— EndBug/pages-preview</p>
</blockquote>
<h2 id="table-of-contents" tabindex="-1">Table of contents <a class="header-anchor" href="#table-of-contents" aria-label="Permalink to “Table of contents”">&#8203;</a></h2>
<ul>
<li><a href="#what-does-it-do">What does it do?</a></li>
<li><a href="#setup">Setup</a></li>
<li><a href="#inputs">Inputs</a></li>
</ul>
<h2 id="what-does-it-do" tabindex="-1">What does it do? <a class="header-anchor" href="#what-does-it-do" aria-label="Permalink to “What does it do?”">&#8203;</a></h2>
<p>pnpm 在workspace monorepo的环境下，一定要使用 <code>pnpm install -wr</code> 来确保工作空间内所有项目的package.json都递归进行了安装，否则仅仅会安装根目录下的package.json</p>
<p>pnpm 在个人开发时 pnpm install 是没有默认参数的，但在 github actions中运行时，由于是CI环境下运行会带上不同平常给的默认行为，比如
<code>pnpm install -wr</code> 会与 <code>pnpm install -wr --frozen-lockfile</code> 等同，如果希望全新安装，则需要指定参数  <code>pnpm install -wr  --ignore-scripts --no-frozen-lockfile</code>.
<code>--ignore-scripts</code>参数为忽略安装本地脚本，加快安装速度</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[我如何使用Coze来分析掘金热榜数据 | Coze插件开发]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/ai/coze/juejin-hot-rank-bot.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/ai/coze/juejin-hot-rank-bot.html</guid>
            <pubDate>Tue, 27 Feb 2024 13:51:00 GMT</pubDate>
            <description><![CDATA[# 我如何使用Coze来分析掘金热榜数据 | Coze插件开发

## 前言
[掘金热榜](https://juejin.cn/hot/collected-articles)想必大家会偶尔扫一扫，看看感兴趣的进行进一步阅读。

![](./juejin-hot-rank-bot/e873781d6738026921ae38111f8a4019.png)

文章相关的榜单主要就是`掘金文章榜`，`文章收藏榜`这两个。

>[扣子（coze.cn）](https://www.coze.cn/)是一款用来开发新一代 AI Chat Bot 的应用编辑平台。

![](./juejin-hot-rank-bot/6c959d43f030a07fb0dfaca615052cfb.png)

可以理解是 `对话机器人` 定制工厂。

![](./juejin-hot-rank-bot/f380f324533336c360e8fb25b595a430.png)

`Coze` 上开放的定制能力主要有 4 个`Bots`，`插件`，`工作流`，`知识库`。

咱们这里要想让机器人读取掘金热榜的数据就要借助插件的能力咯。

**下面进入正题，看看如何把这两者结合起来？**

*想要体验最后效果的可以直接访问这个已经搭建好的机器人：[掘金热榜分析](https://www.coze.cn/store/bot/7339921359969108031?from=bots_card)。*

|                                     页面                                      |                                     效果                                      |
| :]]></description>
            <content:encoded><![CDATA[<h1 id="我如何使用coze来分析掘金热榜数据-coze插件开发" tabindex="-1">我如何使用Coze来分析掘金热榜数据 | Coze插件开发 <a class="header-anchor" href="#我如何使用coze来分析掘金热榜数据-coze插件开发" aria-label="Permalink to “我如何使用Coze来分析掘金热榜数据 | Coze插件开发”">&#8203;</a></h1>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p><a href="https://juejin.cn/hot/collected-articles" target="_blank" rel="noreferrer">掘金热榜</a>想必大家会偶尔扫一扫，看看感兴趣的进行进一步阅读。</p>
<p><img src="./juejin-hot-rank-bot/e873781d6738026921ae38111f8a4019.png" alt="" loading="lazy"></p>
<p>文章相关的榜单主要就是<code>掘金文章榜</code>，<code>文章收藏榜</code>这两个。</p>
<blockquote>
<p><a href="https://www.coze.cn/" target="_blank" rel="noreferrer">扣子（coze.cn）</a>是一款用来开发新一代 AI Chat Bot 的应用编辑平台。</p>
</blockquote>
<p><img src="./juejin-hot-rank-bot/6c959d43f030a07fb0dfaca615052cfb.png" alt="" loading="lazy"></p>
<p>可以理解是 <code>对话机器人</code> 定制工厂。</p>
<p><img src="./juejin-hot-rank-bot/f380f324533336c360e8fb25b595a430.png" alt="" loading="lazy"></p>
<p><code>Coze</code> 上开放的定制能力主要有 4 个<code>Bots</code>，<code>插件</code>，<code>工作流</code>，<code>知识库</code>。</p>
<p>咱们这里要想让机器人读取掘金热榜的数据就要借助插件的能力咯。</p>
<p><strong>下面进入正题，看看如何把这两者结合起来？</strong></p>
<p><em>想要体验最后效果的可以直接访问这个已经搭建好的机器人：<a href="https://www.coze.cn/store/bot/7339921359969108031?from=bots_card" target="_blank" rel="noreferrer">掘金热榜分析</a>。</em></p>
<table tabindex="0">
<thead>
<tr>
<th style="text-align:center">页面</th>
<th style="text-align:center">效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="./juejin-hot-rank-bot/1bd1e494dd695ac020eb46ef555696e5.png" alt="" loading="lazy"></td>
<td style="text-align:center"><img src="./juejin-hot-rank-bot/1d5ee81c4478932399eeb7bcad204a7e.png" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h2 id="开发插件" tabindex="-1">开发插件 <a class="header-anchor" href="#开发插件" aria-label="Permalink to “开发插件”">&#8203;</a></h2>
<h3 id="创建插件" tabindex="-1">创建插件 <a class="header-anchor" href="#创建插件" aria-label="Permalink to “创建插件”">&#8203;</a></h3>
<p>切换到 <code>个人空间</code> -&gt; <code>插件</code> 目录下，点击创建插件。</p>
<p><img src="./juejin-hot-rank-bot/ef51089c3a2486fdd34151f39a47cf74.png" alt="" loading="lazy"></p>
<p>录入 API 信息</p>
<p><img src="./juejin-hot-rank-bot/679de7e34a46396ea04777eb55e1c9ba.png" alt="" loading="lazy"></p>
<p>从填的<code>插件URL</code>，<code>Header 列表</code>，<code>授权方式</code>这几项配置我相信大家就能看出 &quot;插件&quot; 本质是什么了。</p>
<p><strong>没错插件就是一个支持调用的服务端接口</strong></p>
<p>这里相当于是配置接口调用的 <code>base 路径</code> 和 <code>公共鉴权</code> 参数</p>
<p>由此咱们可以把一些开放的公共查询接口都可以录入到插件中，比如 <a href="https://apifox.com/apihub/" target="_blank" rel="noreferrer">API Hub</a> 上收集的公共API。</p>
<p><img src="./juejin-hot-rank-bot/73fc2cc273c1f5c22d358f0d02232029.png" alt="" loading="lazy"></p>
<p>这里的 <code>api.juejin.cn</code> 就是我在 devTools 中看到（ba）的🤭。</p>
<h3 id="创建工具" tabindex="-1">创建工具 <a class="header-anchor" href="#创建工具" aria-label="Permalink to “创建工具”">&#8203;</a></h3>
<p>进入创建的插件后，就可以创建工具了。</p>
<p><img src="./juejin-hot-rank-bot/a2265ab81ab50cc5f921fb266080d666.png" alt="" loading="lazy"></p>
<p><em>乍一看怎么又有一个新概念，“工具”？打开配置窗口一看就悟了！</em></p>
<p><img src="./juejin-hot-rank-bot/4dba81d401be69b5fda62c5603daf8e7.png" alt="" loading="lazy"></p>
<p>哦😯，这个<strong>工具就是录入具体的功能API，配置一下具体API的<code>请求路径，方法，参数</code></strong></p>
<p>下面是配置过程截图</p>
<table tabindex="0">
<thead>
<tr>
<th style="text-align:center">输入参数</th>
<th style="text-align:center">输出参数（支持自动解析）</th>
<th style="text-align:center">调试校验</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="./juejin-hot-rank-bot/83ca062018f61c26201b5be01d9e8d29.png" alt="" loading="lazy"></td>
<td style="text-align:center"><img src="./juejin-hot-rank-bot/031e3432096d19c9f1f8e903991e16cd.png" alt="" loading="lazy"></td>
<td style="text-align:center"><img src="./juejin-hot-rank-bot/6c0c2526984304d8aa66714691768345.png" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
<h3 id="发布" tabindex="-1">发布 <a class="header-anchor" href="#发布" aria-label="Permalink to “发布”">&#8203;</a></h3>
<p>先发布工具</p>
<p><img src="./juejin-hot-rank-bot/a90fa856a60df0cb64a80d5395a3591a.png" alt="" loading="lazy"></p>
<p>再上架插件，就大工告成了，过程中填写的表单都可以AI自动生成辅助填写（美滋滋）。</p>
<p><img src="./juejin-hot-rank-bot/01f487c484c8d6e316e7a479a81640fe.png" alt="" loading="lazy"></p>
<p>插件上架后，大家就可以公开使用咯，使用的机器人也能公开。</p>
<h2 id="开发bot" tabindex="-1">开发bot <a class="header-anchor" href="#开发bot" aria-label="Permalink to “开发bot”">&#8203;</a></h2>
<h3 id="创建bot" tabindex="-1">创建bot <a class="header-anchor" href="#创建bot" aria-label="Permalink to “创建bot”">&#8203;</a></h3>
<p>这个就很简单了，主要就是写 &quot;魔法咒语&quot;，过程也有AI辅助。</p>
<p>在创建入口，填写一下机器人的 <code>名字</code> 和 <code>介绍</code> 即可，<code>logo</code> 直接用自动生成。</p>
<p><img src="./juejin-hot-rank-bot/8099d2f705be95b1e20c737cd94599ad.png" alt="" loading="lazy"></p>
<h3 id="编辑bot" tabindex="-1">编辑bot <a class="header-anchor" href="#编辑bot" aria-label="Permalink to “编辑bot”">&#8203;</a></h3>
<p>编辑页面长下面这样子，咱们这里主要关注<code>人设</code>与<code>插件</code>部分即可。</p>
<p><img src="./juejin-hot-rank-bot/e260c84cb2c6180072c9866a4fc55c20.png" alt="" loading="lazy"></p>
<p>可以先添加插件，直接搜索咱们开发的插件名即可。</p>
<p>将咱们录入的工具（API） 添加进去即可
<img src="./juejin-hot-rank-bot/86832534b77d6ba3204477638ed78db7.png" alt="" loading="lazy"></p>
<p>接下来就是写“咒语”，比如我只简单写了下面这一句话：</p>
<div class="language-txt"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre><!--::markdown-it-async::59y094eww7656u2l9pvg1m::--><code>你是一个资深的互联网资讯分析师，可以根据用户的需求从掘金热榜中筛选数据，并按要求格式分析输出。</code></pre>
</div><p>然后用<code>AI优化</code>功能，就给我扩展完善了。</p>
<p><img src="./juejin-hot-rank-bot/e24f2f6488dbf4038a45b13ef802bb70.png" alt="" loading="lazy"></p>
<div class="language-txt"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre><!--::markdown-it-async::3ptvn6w0zigw62tzf47yh::--><code># 角色
你是一个资深的互联网资讯分析师，可以根据用户的需求从掘金热榜中筛选数据，并按要求格式分析输出。

## 技能
- 从掘金热榜中筛选出符合用户需求的数据
- 对筛选出的数据进行分析
- 按照要求格式输出分析结果

## 限制
- 只能从掘金热榜中筛选数据
- 输出结果必须符合要求格式</code></pre>
</div><p>至此核心部分就完成了，下面可以简单测试一下。</p>
<p><img src="./juejin-hot-rank-bot/524097eb12ea5438b7f8b98b334b61d3.png" alt="" loading="lazy"></p>
<p><img src="./juejin-hot-rank-bot/c55b1b104e4e5341cbae7cc2df01b0d1.png" alt="" loading="lazy"></p>
<h2 id="优化" tabindex="-1">优化 <a class="header-anchor" href="#优化" aria-label="Permalink to “优化”">&#8203;</a></h2>
<h3 id="提示词优化" tabindex="-1">提示词优化 <a class="header-anchor" href="#提示词优化" aria-label="Permalink to “提示词优化”">&#8203;</a></h3>
<p>咱们咒语里没有体现查询哪个榜单的数据，默认调用 API 时都是查的综合榜单。</p>
<p>用户在提问的时候可以说查询 后端/Android 等榜单，此时咱们就需要将这些榜单对应的查询参数写到 提示词 里。</p>
<p>向下面这样，这样查询结果更加符合用户需要的榜单数据。</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::h59tb17joygwgrvm05wgl::--><code>### 掘金热榜插件参数对照
* 综合：1
* 后端：6809637767543259144
* 安卓：6809635626879549454</code></pre>
</div><h3 id="插件优化" tabindex="-1">插件优化 <a class="header-anchor" href="#插件优化" aria-label="Permalink to “插件优化”">&#8203;</a></h3>
<p>API 查询结果中有很多不需要的无关参数，咱们可以使用一层服务对传入参数过滤后再配置到平台上，避免导致结果过大，超出对话上下文限制的 tokens 数量。</p>
<h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>欢迎大家踊跃<a href="https://www.coze.cn/store/plugin" target="_blank" rel="noreferrer">贡献插件</a>，理论上配合自定义API，机器人就有无限的可能。</p>
<p>体验文章搭建的<a href="https://www.coze.cn/store/bot/7339921359969108031?from=bots_card" target="_blank" rel="noreferrer">掘金热榜分析机器人</a></p>
<p>bot ID；7339921359969108031</p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/juejin-hot-rank-bot/e873781d6738026921ae38111f8a4019.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[stable-diffusion 学习笔记]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/ai/stable-diffusion/</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/ai/stable-diffusion/</guid>
            <pubDate>Sun, 02 Jul 2023 23:26:00 GMT</pubDate>
            <description><![CDATA[前言
笔者不会python，也不会机器学习，但是对于SD一直很感兴趣，最近有空闲时间，所以在这里记录一下 stable-diffusion 学习笔记。
 目录
* Mac 安装 stable-diff]]></description>
            <content:encoded><![CDATA[<h1 id="stable-diffusion-学习笔记" tabindex="-1">stable-diffusion 学习笔记 <a class="header-anchor" href="#stable-diffusion-学习笔记" aria-label="Permalink to “stable-diffusion 学习笔记”">&#8203;</a></h1>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>笔者不会python，也不会机器学习，但是对于SD一直很感兴趣，最近有空闲时间，所以在这里记录一下 stable-diffusion 学习笔记。</p>
<h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to “目录”">&#8203;</a></h2>
<ul>
<li><a href="./mac-install.html">Mac 安装 stable-diffusion</a></li>
</ul>
<h2 id="参考学习资料" tabindex="-1">参考学习资料 <a class="header-anchor" href="#参考学习资料" aria-label="Permalink to “参考学习资料”">&#8203;</a></h2>
<p>文字：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/eFi-xoVDQomzCBr5kO9nHA" target="_blank" rel="noreferrer">耗时80小时！超详细的胎教级Stable Diffusion使用教程，看这一篇就够！</a></li>
<li><a href="https://tob-design.yuque.com/kxcufk/sd" target="_blank" rel="noreferrer">Stable Diffusion 知识库</a></li>
</ul>
<p>YouTube 视频：</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=CHYiiVK8V6o" target="_blank" rel="noreferrer">Stable Diffusion Webui扫盲+Mac M1/M2 安装，中文版，无需GPU</a></li>
<li><a href="https://www.youtube.com/watch?v=EYEmdz7ez0M&amp;t=361s" target="_blank" rel="noreferrer">🐼Stable Diffusion 腾讯云安装部署教程之模型与插件 知识点：原生SD大模型和lora下载 | SD插件下载 | controlnet模型缺失下载和删除（独家脚本）</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Mac 安装 stable-diffusion]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/ai/stable-diffusion/mac-install.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/ai/stable-diffusion/mac-install.html</guid>
            <pubDate>Sun, 02 Jul 2023 23:26:00 GMT</pubDate>
            <description><![CDATA[Mac 实操安装 stable-diffusion，包含环境配置，sd插件安装，模型安装等内容]]></description>
            <content:encoded><![CDATA[<h1 id="mac-安装-stable-diffusion" tabindex="-1">Mac 安装 stable-diffusion <a class="header-anchor" href="#mac-安装-stable-diffusion" aria-label="Permalink to “Mac 安装 stable-diffusion”">&#8203;</a></h1>
<p>笔者所使用设备 Mac mini（macOS Ventura），如读者你是 window 请自行谷歌 window 安装 stable-diffusion 教程。</p>
<p>笔者不会python，也不会机器学习，安装过程可能不是最佳的方式，但是能跑起来（hh）。</p>
<blockquote>
<nav class="table-of-contents"><ul><li><a href="#环境准备">环境准备</a><ul><li><a href="#安装python">安装python</a></li><li><a href="#安装-stable-diffusion-webui">安装 stable-diffusion-webui</a></li></ul></li><li><a href="#配置-stable-diffusion-webui">配置 stable-diffusion-webui</a><ul><li><a href="#汉化">汉化</a></li><li><a href="#安装插件">安装插件</a></li></ul></li><li><a href="#安装模型">安装模型</a></li><li><a href="#简单使用">简单使用</a></li></ul></nav>
</blockquote>
<h2 id="环境准备" tabindex="-1">环境准备 <a class="header-anchor" href="#环境准备" aria-label="Permalink to “环境准备”">&#8203;</a></h2>
<ul>
<li>科学上网工具：确保安装过程网络通畅</li>
<li><a href="https://www.python.org/downloads/release/python-3106/" target="_blank" rel="noreferrer">python 3.16.0</a> ：确保大部分依赖库能顺利运行</li>
<li><a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui" target="_blank" rel="noreferrer">stable-diffusion-webui</a>：sd 网页应用</li>
</ul>
<h3 id="安装python" tabindex="-1">安装python <a class="header-anchor" href="#安装python" aria-label="Permalink to “安装python”">&#8203;</a></h3>
<blockquote>
<p>笔者的操作不一定是最佳实践</p>
</blockquote>
<p>我这里使用安装包傻瓜式的一键安装，从官网下载 <a href="https://www.python.org/downloads/release/python-3106/" target="_blank" rel="noreferrer">python 3.16.0</a> 安装包</p>
<p><img src="./mac-install/MTY4ODMwMDc3OTM2Mg==688300779362.png" alt="" loading="lazy"></p>
<p>打开下载好的安装包，无脑选择下一步即可</p>
<p><img src="./mac-install/MTY4ODMwMDgyMDQyMw==688300820423.png" alt="" loading="lazy"></p>
<p>安装完后打开终端输入，<a href="https://app.warp.dev/block/s9LVoqUBc12tgLXmwl1sQO" target="_blank" rel="noreferrer">查看 python 版本</a></p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::q4iucfuxk29ckar90h6i3u::--><code>python3 --version</code></pre>
</div><p><img src="./mac-install/MTY4ODMwMTAyODI2Nw==688301028267.png" alt="" loading="lazy"></p>
<p>这里可以在<code>~/.zshrc</code>中设置一个别名<code>python</code>，方便后续使用</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::hz079r52pgisvdq9zohrdc::--><code>alias python=python3</code></pre>
</div><p><img src="./mac-install/MTY4ODMwMTEwMTgzNw==688301101837.png" alt="" loading="lazy"></p>
<p><img src="./mac-install/MTY4ODMwMTEzMjgzNQ==688301132835.png" alt="" loading="lazy"></p>
<h3 id="安装-stable-diffusion-webui" tabindex="-1">安装 stable-diffusion-webui <a class="header-anchor" href="#安装-stable-diffusion-webui" aria-label="Permalink to “安装 stable-diffusion-webui”">&#8203;</a></h3>
<p>clone 项目到本地</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::x3uk127eqjlldoo27t70l::--><code>git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git</code></pre>
</div><p>克隆完成后进入项目目录</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::wpvhniwr92b0b5qw9f1yk::--><code>cd stable-diffusion-webui</code></pre>
</div><p>安装项目依赖(此过程会持续一段时间)</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::6xs48at2n0by0pyx6jrlq::--><code>pip install -r requirements.txt</code></pre>
</div><p>启动项目</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::y67xosdsea5q8zwx59u3t::--><code>./webui.sh</code></pre>
</div><p><img src="./mac-install/MTY4ODMwMTU4NTA0Mw==688301585043.png" alt="" loading="lazy"></p>
<p>访问 <code>http://127.0.0.1:7860/</code> 即可应用的内容</p>
<p><img src="./mac-install/MTY4ODMwMTY2MTk5MA==688301661990.png" alt="" loading="lazy"></p>
<h2 id="配置-stable-diffusion-webui" tabindex="-1">配置 stable-diffusion-webui <a class="header-anchor" href="#配置-stable-diffusion-webui" aria-label="Permalink to “配置 stable-diffusion-webui”">&#8203;</a></h2>
<h3 id="汉化" tabindex="-1">汉化 <a class="header-anchor" href="#汉化" aria-label="Permalink to “汉化”">&#8203;</a></h3>
<p>为了方便后续的使用我们可以将 stable-diffusion-webui 汉化一下</p>
<p>使用插件<a href="https://github.com/VinsonLaro/stable-diffusion-webui-chinese" target="_blank" rel="noreferrer">stable-diffusion-webui-chinese</a></p>
<p>安装操作路径: <code>Extensions</code> =&gt; <code>URL for extension's git repository</code> =&gt; <code>Install</code></p>
<p><img src="./mac-install/MTY4ODMwMTc1ODg0MQ==688301758841.png" alt="" loading="lazy"></p>
<p>输入插件地址：<code>https://github.com/VinsonLaro/stable-diffusion-webui-chinese</code>,点击<code>Install</code>即可</p>
<p>紧接着应用插件：<code>Installed</code> =&gt; <code>Apply and restart UI</code></p>
<p><img src="./mac-install/MTY4ODMwMTk0NTg4Nw==688301945887.png" alt="" loading="lazy"></p>
<p>设置汉化：<code>Settings</code> =&gt; <code>User Interface</code> =&gt; <code>Localization</code> =&gt; <code>Apply Settings</code> =&gt; <code>Reload UI</code></p>
<p><img src="./mac-install/MTY4ODMwMjA5NjAwMQ==688302096001.png" alt="" loading="lazy"></p>
<p>推荐使用中英对照，方便观看部分英文教程</p>
<p><img src="./mac-install/MTY4ODMwMjM3MTAwNw==688302371007.png" alt="" loading="lazy"></p>
<p>再次访问即可看到英文汉化的内容</p>
<h3 id="安装插件" tabindex="-1">安装插件 <a class="header-anchor" href="#安装插件" aria-label="Permalink to “安装插件”">&#8203;</a></h3>
<p>由于网络问题可能会出现访问失败的情况，如下图所示</p>
<p><img src="./mac-install/MTY4ODMwMjQ0NDUwNg==688302444506.png" alt="" loading="lazy"></p>
<p>这里可以使用笔者的CV下来的配置<code>https://script.sugarat.top/json/sd.json</code></p>
<p>或者浏览器访问<a href="https://raw.githubusercontent.com/AUTOMATIC1111/stable-diffusion-webui-extensions/master/index.json" target="_blank" rel="noreferrer">链接资源</a>，将其下载到本地，本地启动一个服务（比如使用<a href="https://www.npmjs.com/package/http-server" target="_blank" rel="noreferrer">http-server</a>）</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::zgxxdgielj9adb2lhudxfv::--><code>npx http-server</code></pre>
</div><p><img src="./mac-install/MTY4ODMwMjc3ODEzNg==688302778136.png" alt="" loading="lazy"></p>
<p>url设置为<code>http://127.0.0.1:8080/sd.json</code>即可，点击 加载 即可看到插件列表</p>
<p><img src="./mac-install/MTY4ODMwMzI4NTY5Mg==688303285692.png" alt="" loading="lazy"></p>
<p>例如 安装 <code>sd-webui-controlnet</code> 和 <code>3D Openpose Editor</code></p>
<p>搜索<code>controlnet</code>，找到相应的插件，点击 <code>Installed</code> 即可</p>
<p><img src="./mac-install/MTY4ODMwNTU2NjA0Mw==688305566043.png" alt="" loading="lazy"></p>
<p>在已安装列表即可看到安装的插件</p>
<p><img src="./mac-install/MTY4ODMwNjIyOTMxNg==688306229316.png" alt="" loading="lazy"></p>
<p>重启后即可看到刚安装的插件生效了</p>
<p><img src="./mac-install/MTY4ODMwNjc4MzcxMg==688306783712.png" alt="" loading="lazy"></p>
<h2 id="安装模型" tabindex="-1">安装模型 <a class="header-anchor" href="#安装模型" aria-label="Permalink to “安装模型”">&#8203;</a></h2>
<blockquote>
<p>从 <a href="https://civitai.com/" target="_blank" rel="noreferrer">C 站</a>：<a href="https://civitai.com/" target="_blank" rel="noreferrer">https://civitai.com/</a> 下载（需要科学上网工具才能访问）</p>
</blockquote>
<p><img src="./mac-install/MTY4ODMwOTEzMzUzNA==688309133534.png" alt="" loading="lazy"></p>
<p>比如 <a href="https://civitai.com/models/6424?modelVersionId=11745" target="_blank" rel="noreferrer">ChilloutMix</a> 模型</p>
<p>点击下载</p>
<p><img src="./mac-install/MTY4ODMwOTI2NTU3Mg==688309265572.png" alt="" loading="lazy"></p>
<p>导入下载的模型到目录 <code>models/Stable-diffusion</code></p>
<p><img src="./mac-install/MTY4ODMwOTUyMDk4MA==688309520980.png" alt="" loading="lazy"></p>
<p>然后重启服务或者点击刷新</p>
<p><img src="./mac-install/MTY4ODU3MDA2NDczNA==688570064734.png" alt="" loading="lazy"></p>
<p><img src="./mac-install/MTY4ODMwOTYxMDkyOA==688309610928.png" alt="" loading="lazy"></p>
<h2 id="简单使用" tabindex="-1">简单使用 <a class="header-anchor" href="#简单使用" aria-label="Permalink to “简单使用”">&#8203;</a></h2>
<p>可以直接 Copy 其它用户分享到C站上的提示词</p>
<p>比如下面<a href="https://civitai.com/images/312507?period=AllTime&amp;periodMode=published&amp;sort=Newest&amp;view=categories&amp;modelVersionId=27828&amp;modelId=23302&amp;postId=79817" target="_blank" rel="noreferrer">这个例子</a></p>
<p>查看大图时滑到右下角</p>
<p><img src="./mac-install/MTY4ODMwOTg3ODUxOA==688309878518.png" alt="" loading="lazy"></p>
<p>或者缩略图右下角的 “i”</p>
<p><img src="./mac-install/MTY4ODMwOTkwMzgwOA==688309903808.png" alt="" loading="lazy"></p>
<p>下面实操使用一下上面的提示词</p>
<p>我这里把步数调成了30</p>
<div class="vp-code-group"><div class="tabs"><input type="radio" name="group-249" id="tab-250" checked><label data-title="① 提示词" for="tab-250">① 提示词</label><input type="radio" name="group-249" id="tab-251" ><label data-title="② 反向提示词" for="tab-251">② 反向提示词</label><input type="radio" name="group-249" id="tab-252" ><label data-title="③ 采样器" for="tab-252">③ 采样器</label><input type="radio" name="group-249" id="tab-253" ><label data-title="④ 步数" for="tab-253">④ 步数</label><input type="radio" name="group-249" id="tab-254" ><label data-title="⑤ 引导系数" for="tab-254">⑤ 引导系数</label></div><div class="blocks">
<div class="language-txt active"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre><!--::markdown-it-async::zbu7qtpbzfaq5316a7sd::--><code>extremely detailed CG uniform 8k illustrations, high color substitution, sketches graffiti art, illustrations photo, masterpiece, hyper detailed, best quality, ultra high res, high resolution, (intricate details), perfect lighting, best shadow, (graffiti wall:1.4), 1 girl, (extremely detailed face and eyes), (shiny big eyes), (shiny graffiti long hair:1.2), ((colorful)), ((colorful illustrations)), face focus, lip gloss, random eyes color,</code></pre>
</div><div class="language-txt"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre><!--::markdown-it-async::zyeqqcq1emikuxba2uv13h::--><code>by bad-picture-chill-75v, nude, porn, nipples, pussy, pornography, canvas frame, cartoon, 3d, ((disfigured)), ((bad art)), ((deformed)),((extra limbs)),((close up)),((b&amp;w)), wierd colors, blurry, (((duplicate))), ((morbid)), ((mutilated)), [out of frame], extra fingers, mutated hands, ((poorly drawn hands)), ((poorly drawn face)), (((mutation))), (((deformed))), ((ugly)), blurry, ((bad anatomy)), (((bad proportions))), ((extra limbs)), cloned face, (((disfigured))), out of frame, ugly, extra limbs, (bad anatomy), gross proportions, (malformed limbs), ((missing arms)), ((missing legs)), (((extra arms))), (((extra legs))), mutated hands, (fused fingers), (too many fingers), (((long neck))), Photoshop, video game, ugly, tiling, poorly drawn hands, poorly drawn feet, poorly drawn face, out of frame, mutation, mutated, extra limbs, extra legs, extra arms, disfigured, deformed, cross-eye, body out of frame, blurry, bad art, bad anatomy, 3d render, background blur, (blurred background),  (briefs), (triangle pants), watermark, astigmatism, scattered light, lens astigmatism, chest light, shiny boobs, glowing boobs, halo, fog, hazy,</code></pre>
</div><div class="language-txt"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre><!--::markdown-it-async::ztw1zhv7amshofyq4c746q::--><code>DPM++ SDE Karras</code></pre>
</div><div class="language-txt"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre><!--::markdown-it-async::qr0g3z6ovkn8zpqh4voel::--><code>30</code></pre>
</div><div class="language-txt"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre><!--::markdown-it-async::oq0wiktslhi2uoodpcnt::--><code>9</code></pre>
</div></div></div>
<p>最后效果如下</p>
<p><img src="./mac-install/MTY4ODMxMTAyMTY2Ng==688311021666.png" alt="" loading="lazy"></p>
<p><img src="./mac-install/MTY4ODMxMTI1MTEzNw==688311251137.png" alt="" loading="lazy"></p>
]]></content:encoded>
            <enclosure url="https://img.cdn.sugarat.top/mdImg/MTY4ODMwOTEzMzUzNA==688309133534" length="0" type="image//mdImg/MTY4ODMwOTEzMzUzNA==688309133534"/>
        </item>
        <item>
            <title><![CDATA[一个简约风的vitepress博客主题]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/theme.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/theme.html</guid>
            <pubDate>Sun, 05 Feb 2023 14:00:00 GMT</pubDate>
            <description><![CDATA[简约风的vitepress博客主题介绍]]></description>
            <content:encoded><![CDATA[<h1 id="一个简约风的vitepress博客主题" tabindex="-1">一个简约风的vitepress博客主题 <a class="header-anchor" href="#一个简约风的vitepress博客主题" aria-label="Permalink to “一个简约风的vitepress博客主题”">&#8203;</a></h1>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>笔者的博客之前是使用 <a href="https://vuepress.vuejs.org/" target="_blank" rel="noreferrer">VuePress</a> + <a href="https://vuepress-theme-reco.recoluan.com/" target="_blank" rel="noreferrer">reco主题</a></p>
<p>随着博客文章数量越来越多（md文件已经300+了），博客本地启动和构建越来越来慢了emmm</p>
<p>当然使用频率最高的就是本地启动，构建是个相对比较低频的动作。</p>
<p>恰好此时 <a href="https://vitepress.dev/" target="_blank" rel="noreferrer">VitePress</a> 也比较成熟了（alpha），相比 VuePress 更加的简洁，可玩性强，上手成本也低。</p>
<p>按照官方的给的定位，VitePress 主打是主题（个人感觉就像<a href="https://hexo.io/zh-cn/" target="_blank" rel="noreferrer">Hexo</a>丰富多彩的主题一样），不提供插件系统</p>
<p><img src="./theme/MTY3NTU3MjY0MjgzNQ==675572642835.png" alt="" loading="lazy"></p>
<p>在笔者进行博客迁移的时候，将主题分离了出来，可供单独使用</p>
<p>新旧对比</p>
<p><img src="./theme/MTY3NTU3NDk0OTI2Ng==675574949266.png" alt="新旧博客对比" loading="lazy"></p>
<p>风格借鉴了 <a href="https://vuepress-theme-reco.recoluan.com/" target="_blank" rel="noreferrer">reco</a> ，<a href="https://juejin.cn/" target="_blank" rel="noreferrer">掘金</a>，<a href="https://surmon.me/" target="_blank" rel="noreferrer">surmon</a>等等，组件部分用了 <a href="https://element-plus.gitee.io/zh-CN/" target="_blank" rel="noreferrer">element-plus</a></p>
<p>下面介绍食用指南（<a href="https://www.npmjs.com/package/@sugarat/theme" target="_blank" rel="noreferrer">主题</a>实现内容比较多，后面单开一个专栏介绍 😋嘿嘿！）</p>
<h2 id="快速体验" tabindex="-1">快速体验 <a class="header-anchor" href="#快速体验" aria-label="Permalink to “快速体验”">&#8203;</a></h2>
<p>只需3步，即可体验</p>
<p>① 拉取 Github 模板</p>
<div class="vp-code-group"><div class="tabs"><input type="radio" name="group-48" id="tab-49" checked><label data-title="npm" for="tab-49">npm</label><input type="radio" name="group-48" id="tab-50" ><label data-title="yarn" for="tab-50">yarn</label><input type="radio" name="group-48" id="tab-51" ><label data-title="pnpm" for="tab-51">pnpm</label></div><div class="blocks">
<div class="language-bash active"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::k2eutrk28wev5vo5vhecfg::--><code>npm create @sugarat/theme@latest</code></pre>
</div><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::l7h7r331g7iccj27c06rz::--><code>yarn create @sugarat/theme</code></pre>
</div><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::4w9dtmvaf1awa1zq011bv::--><code>pnpm create @sugarat/theme</code></pre>
</div></div></div>
<p>也可以指定项目名</p>
<div class="vp-code-group"><div class="tabs"><input type="radio" name="group-56" id="tab-57" checked><label data-title="npm" for="tab-57">npm</label><input type="radio" name="group-56" id="tab-58" ><label data-title="yarn" for="tab-58">yarn</label><input type="radio" name="group-56" id="tab-59" ><label data-title="pnpm" for="tab-59">pnpm</label></div><div class="blocks">
<div class="language-bash active"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::bk8bj7iyte5lpo1tlmffbn::--><code>npm create @sugarat/theme@latest my-first-blog</code></pre>
</div><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::dkdpt82vgbrt9word88u3::--><code>yarn create @sugarat/theme my-first-blog</code></pre>
</div><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre><!--::markdown-it-async::xx7bpvq5sfisn89ylxbq6::--><code>pnpm create @sugarat/theme my-first-blog</code></pre>
</div></div></div>
<p><img src="./theme/MTY4OTQyMDE1NTcxMA==689420155710.png" alt="" loading="lazy"></p>
<p>② 安装依赖</p>
<div class="vp-code-group"><div class="tabs"><input type="radio" name="group-67" id="tab-68" checked><label data-title="pnpm" for="tab-68">pnpm</label><input type="radio" name="group-67" id="tab-69" ><label data-title="安装 PNPM" for="tab-69">安装 PNPM</label></div><div class="blocks">
<div class="language-sh active"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::5fwcdekivjt7dqv0ve4b::--><code>pnpm install</code></pre>
</div><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::t0y7v4lldkl8j8nqq1ge::--><code># 如果你没有 PNPM 请先安装
npm i -g pnpm</code></pre>
</div></div></div>
<p>③ 启动</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::h5dc1x4xhraxhhd36mpzjm::--><code>pnpm dev</code></pre>
</div><p>就能得到如下的页面</p>
<p><img src="./theme/MTY3NTU3NDMxODU0OA==675574318548.png" alt="" loading="lazy"></p>
<h2 id="已支持功能" tabindex="-1">已支持功能 <a class="header-anchor" href="#已支持功能" aria-label="Permalink to “已支持功能”">&#8203;</a></h2>
<p>介绍一下主要的，非所有，详见<a href="https://theme.sugarat.top/" target="_blank" rel="noreferrer">主题文档</a></p>
<ul>
<li>博客首页
<ul>
<li>文章列表</li>
<li>精选文章</li>
<li>友链</li>
<li>标签分类</li>
</ul>
</li>
<li>图片预览</li>
<li>搜索（标题+简介）</li>
<li><a href="https://giscus.app/zh-CN" target="_blank" rel="noreferrer">giscus</a> 评论系统</li>
<li>推荐文章（同目录）</li>
<li>阅读时间计算</li>
<li>全局的提示弹窗 (由 <a href="https://element-plus.gitee.io/zh-CN/component/alert.html" target="_blank" rel="noreferrer">el-alert</a> 驱动)</li>
<li>全局的公告弹窗，支持设置图片，文字，按钮</li>
<li>全文搜索</li>
<li>RSS</li>
<li>...</li>
</ul>
<h2 id="规划中功能" tabindex="-1">规划中功能 <a class="header-anchor" href="#规划中功能" aria-label="Permalink to “规划中功能”">&#8203;</a></h2>
<ul>
<li>Valine 评论系统</li>
<li>文章合集</li>
<li>更多可定制的主题样式</li>
<li>。。。</li>
</ul>
<h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>读者有建议的 功能&amp;想法 欢迎 私信&amp;评论区 交流</p>
<ul>
<li>主题地址：<a href="https://theme.sugarat.top/" target="_blank" rel="noreferrer">https://theme.sugarat.top/</a></li>
<li>主题包：<a href="https://www.npmjs.com/package/@sugarat/theme" target="_blank" rel="noreferrer">@sugarat/theme</a></li>
<li>项目地址：<a href="https://github.com/ripplejourney/ripplejourney.github.io/tree/master/packages/theme" target="_blank" rel="noreferrer">https://github.com/ripplejourney/ripplejourney.github.io/tree/master/packages/theme</a></li>
</ul>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/theme/MTY3MzE3MDUxOTMwMw==673170519303.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[从0-1实现文件下载CLI工具]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/fs-cli.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/fs-cli.html</guid>
            <pubDate>Wed, 09 Nov 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[前言
在日常学习/生活中，下载资源时，大部分情况是通过别人分享的资源站点，找到下载入口然后触发下载。
当资源通过url传播的时候，一般也是直接打开，通过浏览器触发下载。
资深的冲浪选手，一般会用一些客]]></description>
            <content:encoded><![CDATA[<h1 id="从0-1实现文件下载cli工具" tabindex="-1">从0-1实现文件下载CLI工具 <a class="header-anchor" href="#从0-1实现文件下载cli工具" aria-label="Permalink to “从0-1实现文件下载CLI工具”">&#8203;</a></h1>
<blockquote>
<p>本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！</p>
</blockquote>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>在日常学习/生活中，下载资源时，大部分情况是通过别人分享的资源站点，找到下载入口然后触发下载。</p>
<p>当资源通过url传播的时候，一般也是直接打开，通过浏览器触发下载。</p>
<p>资深的冲浪选手，一般会用一些客户端工具（还记得Win上的各种下载器），Mac上笔者有时候会使用 <a href="https://www.neatdownloadmanager.com/index.php/en/" target="_blank" rel="noreferrer">NeatDownloadManager</a>，无 🪜 时也能拥有不错的下载速度</p>
<p><strong>Coder</strong>们用命令行下载文件的方式就很多了，比如最常使用的内置库 <a href="https://github.com/curl/curl" target="_blank" rel="noreferrer">curl</a></p>
<p>下面是最常用的拉取资源的例子</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::s4zn6n46tgm58ji07v1uo9::--><code># 链接是第三方服务缩短后的
# -L 参数表明自动对资源进行重定向
curl -L http://mtw.so/5YIGGb -o 码上掘金logo.image

# 通过管道
curl -L http://mtw.so/6647Rc &gt;码上掘金logo.image

# 原图链接 https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/759e2aa805c0461b840e0f0f09ed05fa~tplv-k3u1fbpfcp-zoom-1.image</code></pre>
</div><p>当然 <strong>curl</strong> 也支持上传下载，以及多种传输协议，具体用法这里就不展开了，感兴趣的读者可以前往<a href="https://wangchujiang.com/reference/docs/curl.html" target="_blank" rel="noreferrer">Quick Reference: Curl 备忘清单</a> 进一步了解。</p>
<p>本文从 0-1 使用Node实现一个 <code>url文件下载</code> 工具，读者可以收获包含但不限于如下知识点，</p>
<p><code>Node实现下载文件</code>，<code>如何通过Proxy（🪜）代理下载资源</code>，<code>通用的Node本地持久化存储方法</code>，<code>fs/path/http等模块的常见用法</code>等。</p>
<p>对包含文件下载场景的<strong>CLI</strong>提供一个实践参考。</p>
<p>下面是简单的使用演示，对实现感兴趣的读者可以接着往下阅读</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::k72gxg68gv6dnxfv3oqw2::--><code>npx efst http://mtw.so/66eO7c</code></pre>
</div><p><img src="./fs-cli/MTY2ODkyMDg3NDEwNg==668920874106.png" alt="图片" loading="lazy"></p>
<h2 id="url资源下载" tabindex="-1">url资源下载 <a class="header-anchor" href="#url资源下载" aria-label="Permalink to “url资源下载”">&#8203;</a></h2>
<p>先是纯 <strong>url资源下载</strong> 的场景，本小节将详细展开相关小功能的实现。</p>
<h3 id="node原生实现" tabindex="-1">Node原生实现 <a class="header-anchor" href="#node原生实现" aria-label="Permalink to “Node原生实现”">&#8203;</a></h3>
<p>基于<code>读写流</code>操作，可以看到代码还是十分的简洁</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::lxqlmmjnmrp00gz15crx7b3d::--><code>import https from &#039;https&#039;
import fs from &#039;fs&#039;
import path from &#039;path&#039;
function downloadByUrl(url: string, filename?: string) {
  const filepath = path.resolve(filename || randomName())
  https.get(url, (response) =&gt; {
    // 创建1个可写流
    const writeStream = fs.createWriteStream(filepath)
    response.pipe(writeStream).on(&#039;close&#039;, () =&gt; {
      console.log(`file save to ${filepath}`)
    })
  })
}

// sourceUrl 为前面的原图链接
downloadByUrl(sourceUrl,&#039;test.image&#039;)</code></pre>
</div><p><img src="./fs-cli/MTY2ODI2MjI2ODMxNQ==668262268315.png" alt="图片" loading="lazy"></p>
<p><a href="https://github.com/ATQQ/tools/blob/main/packages/cli/efst/__test__/download/1.ts" target="_blank" rel="noreferrer">示例代码1</a></p>
<h3 id="下载进度获取" tabindex="-1">下载进度获取 <a class="header-anchor" href="#下载进度获取" aria-label="Permalink to “下载进度获取”">&#8203;</a></h3>
<p>大一点的文件肯定无法实现秒下载，需要获取一下进度，了解现在下载了多少</p>
<p>资源的总大小可以一般可以通过<code>response headers</code>中的<code>content-length</code>字段获取</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::jzm43ijxwsbx6xny3srfes::--><code>const sumSize = +response.headers[&#039;content-length&#039;]</code></pre>
</div><p>流的传输进度可以通过<code>on data</code>事件间接获取</p>
<p>在不通过<code>response.setEncoding(BufferEncoding)</code>修改的编码时，<code>chunk</code>默认是<code>Buffer</code>类型</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::6ixi2be075nsjtxfhezo::--><code>let receive = 0
response.on(&#039;data&#039;, (chunk: Buffer) =&gt; {
  receive += chunk.length
  const percentage = receive / sumSize
})</code></pre>
</div><p>到此进度<code>percentage</code>就可以获取到了</p>
<p>对上面的方法进行稍加改造，增加<code>progress</code>，<code>end</code>两个方法（支持链式调用的丐版实现）</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::bt0bm3hb6jnpt2p67q5na::--><code>function downloadByUrl(url: string, filename?: string) {
  let receive = 0

  // 支持链式调用相关逻辑
  let progressFn: (cur: number, rec: number, sum: number) =&gt; void
  let endFn: (filepath: string) =&gt; void

  const thisArg = {
    progress: (fn: typeof progressFn) =&gt; {
      progressFn = fn
      return thisArg
    },
    end: (fn: typeof endFn) =&gt; {
      endFn = fn
      return thisArg
    }
  }

  https.get(url, (response) =&gt; {
    // 输出文件路径
    const filepath = path.resolve(filename || randomName())
    // 创建一个可写流
    const writeStream = fs.createWriteStream(filepath)

    const sumSize = +response.headers[&#039;content-length&#039;]! || 0
    response.on(&#039;data&#039;, (chunk: Buffer) =&gt; {
      receive += chunk.length
      progressFn &amp;&amp; progressFn(chunk.length, receive, sumSize)
    })

    response.pipe(writeStream).on(&#039;close&#039;, () =&gt; {
      endFn &amp;&amp; endFn(filepath)
    })
  })
  return thisArg
}

// 调用示例
downloadByUrl(sourceUrl, &#039;test.image&#039;)
  .progress((current, receive, sum) =&gt; {
    console.log(receive, ((receive / sum) * 100).toFixed(2), &#039;%&#039;)
  })
  .end((filepath) =&gt; {
    console.log(&#039;file save:&#039;, filepath)
  })</code></pre>
</div><p><img src="./fs-cli/MTY2ODI2MzA2OTAyMQ==668263069021.png" alt="图片" loading="lazy"></p>
<p><a href="https://github.com/ATQQ/tools/blob/main/packages/cli/efst/__test__/download/2.ts" target="_blank" rel="noreferrer">示例代码2</a></p>
<h3 id="重定向处理" tabindex="-1">重定向处理 <a class="header-anchor" href="#重定向处理" aria-label="Permalink to “重定向处理”">&#8203;</a></h3>
<p>部分资源在对外直接暴露时，可能是一个短链，此时就需要做重定向处理</p>
<p>重定向的状态码常见<code>301</code>和<code>302</code>，当然还有其它的3开头的这里不赘述</p>
<p>除了状态码，重定向的目标url由<code>response.headers.location</code>表示</p>
<p>这里稍微改造一下之前的代码，添加一个重定向逻辑即可</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::acjwb6g85wtxl2s24egt::--><code>// 通过url 简单区分一下 资源是 https 还是 http
const _http = url.startsWith(&#039;https&#039;) ? https : http
_http.get(
  url,
  {
    // 添加一个UA，避免404
    // 部分短链服务网站没有UA会响应404
    headers: {
      &#039;User-Agent&#039;: &#039;node http module&#039;
    }
  },
  (response) =&gt; {
    const { statusCode } = response
    // 判断状态码是否3开头
    if (Math.floor(statusCode! / 100) === 3) {
      // 且存在 location
      if (response.headers.location) {
        // 递归
        downloadByUrl(response.headers.location, filename)
          // 透传事件
          .progress(progressFn)
          .end(endFn)
        return
      }
      // 不存在抛出错误
      throw new Error(
        `url:${url} status ${statusCode} without location header`
      )
    }
  }
)</code></pre>
</div><p><img src="./fs-cli/MTY2ODI2NjY3NjE0MA==668266676140.png" alt="图片" loading="lazy"></p>
<p><a href="https://github.com/ATQQ/tools/blob/main/packages/cli/efst/__test__/download/3.ts" target="_blank" rel="noreferrer">示例代码3</a></p>
<p>为了防止无限重定向，还需要加个次数限制，再简单改造一下上述代码，添加一个配置属性作为入参</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::cllosperfyfjfdh3mzc03g::--><code>interface Options {
  filename: string
  maxRedirects: number
}
function downloadByUrl(url: string, option?: Partial&lt;Options&gt;) {
  const ops: Options = { filename: randomName(), maxRedirects: 10, ...option }
  // 省略一些重复代码
  _http.get(
    url,
    (response) =&gt; {
      const { statusCode } = response
      if (Math.floor(statusCode! / 100) === 3 &amp;&amp; ops.maxRedirects) {
        ops.maxRedirects -= 1
        // 递归调用
        if (response.headers.location) {
          downloadByUrl(response.headers.location, ops)
          return
        }
      }
    }
  )
  return thisArg
}</code></pre>
</div><p><a href="https://github.com/ATQQ/tools/blob/main/packages/cli/efst/__test__/download/4.ts" target="_blank" rel="noreferrer">示例代码4</a></p>
<h3 id="请求超时" tabindex="-1">请求超时 <a class="header-anchor" href="#请求超时" aria-label="Permalink to “请求超时”">&#8203;</a></h3>
<p>部分资源由于网络原因可能出现超时，为了避免长时间无反馈等待，可以设置超时时间</p>
<p><code>http</code>模块支持<code>timeout</code>属性设置</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::guq3lfvsah9p1z61swik::--><code>// 接着之前的例子修改部分代码即可
const request = _http.get(
  url,
  {
    // 设置超时时间，单位ms
    timeout: ops.timeout || 300000,
  },
  (response) =&gt; {
    // 省略response 逻辑
  }
)
request.on(&#039;timeout&#039;, () =&gt; {
  // 中断请求，输出错误
  request.destroy()
  console.error(`http request timeout url:${url}`)
})</code></pre>
</div><p>下面是请求 google logo 失败示例</p>
<p><img src="./fs-cli/MTY2ODMyOTcwMTAwMA==668329701000.png" alt="图片" loading="lazy"></p>
<p><a href="https://github.com/ATQQ/tools/blob/main/packages/cli/efst/__test__/download/5.ts" target="_blank" rel="noreferrer">示例代码5</a></p>
<h3 id="proxy" tabindex="-1">Proxy <a class="header-anchor" href="#proxy" aria-label="Permalink to “Proxy”">&#8203;</a></h3>
<p>部分资源访问不顺畅的时候，通常会走服务代理（🪜）</p>
<p>以谷歌的<code>logo</code>资源链接<code>https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_92x30dp.png</code></p>
<p>要让前面的方法<code>downloadByUrl</code>顺利执行，就需要其走代理服务</p>
<p>为<code>http</code>模块添加代理也非常简单，原生提供了一个<code>agent</code>参数，可用于设置代理</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::c859ur1n0m5mk3f79j6p7f::--><code>import http from &#039;http&#039;

const request = http.get(url,{
  agent: Agent,
})</code></pre>
</div><p>这个<code>Agent</code>的构造可以直接用社区已经封装好的<a href="https://www.npmjs.com/package/http-proxy-agent" target="_blank" rel="noreferrer">http-proxy-agent</a></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::pxaioivfag8w42q2dc1xx::--><code>const HttpProxyAgent = require(&#039;http-proxy-agent&#039;)

const proxy = new HttpProxyAgent(&#039;http://127.0.0.1:7890&#039;)</code></pre>
</div><p>在调用时只需将这个<code>proxy</code>实例传入即可</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::7vk9dbewvnbdz9w77ve0xp::--><code>http.get(url, {
  agent: proxy
})</code></pre>
</div><p>原有的方法只需要添加一个<code>proxy</code>入参即可，</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::0azj4o3yu9xg12wy5kd2dq::--><code>const request = _http.get(url, {
  agent: ops.proxy ? new HttpProxyAgent(ops.proxy) : undefined,
})</code></pre>
</div><p>下面是使用代理成功请求的示例</p>
<p><img src="./fs-cli/MTY2ODYwNTcyODQ3NA==668605728474.png" alt="图片" loading="lazy"></p>
<p><a href="https://github.com/ATQQ/tools/blob/main/packages/cli/efst/__test__/download/6.ts" target="_blank" rel="noreferrer">示例代码6</a></p>
<h3 id="合法文件名生成" tabindex="-1">合法文件名生成 <a class="header-anchor" href="#合法文件名生成" aria-label="Permalink to “合法文件名生成”">&#8203;</a></h3>
<p>文件下载到本地肯定需要有个名字，如果用随机的或者用户手动输入那肯定体验较差</p>
<p>最常见的就是通过<code>url</code>的<code>pathname</code>生成</p>
<p>比如上面的谷歌图片资源，咱们使用<code>URL</code>构造出一个示例，查看url的构成</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::s3yljwplt8bvv0zte1a3b::--><code>new URL(sourceUrl)</code></pre>
</div><p><img src="./fs-cli/MTY2ODY5MzA0OTM4Mg==668693049382.png" alt="图片" loading="lazy"></p>
<p>文件名就可以取<code>pathname</code>最后一截，通过<code>path.basename</code>即可获取</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::ydhmr5snkhoi6wkx3rmo8h::--><code>import path from &#039;path&#039;

const url = new URL(&#039;http://www.google.com/images/googlelogo_color_92x30dp.png&#039;)
const filename = path.basename(url.pathname) // googlelogo_color_92x30dp.png</code></pre>
</div><p>当然文件名也可能会重复，再非覆盖写入的前提下，通过会在文件名后添加&quot;分隔符+数字&quot;，比如<code>x.png</code>,<code>x_1.png</code>,<code>x 1.png</code></p>
<p>提取文件名与后缀可以用<code>path.parse</code>直接获取</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::nuybbtsruribj8ld7im8::--><code>import path from &#039;path&#039;

// { ext: &#039;.png&#039;, name: &#039;google&#039; }
path.parse(&#039;google.png&#039;)

// { ext: &#039;&#039;, name: &#039;hashname&#039; }
path.parse(&#039;hashname&#039;)

// { ext: &#039;.ts&#039;, name: &#039;index.d&#039; }
path.parse(&#039;index.d.ts&#039;)

// { ext: &#039;.&#039;, name: &#039;index&#039; }
path.parse(&#039;index.&#039;)

// { ext: &#039;&#039;, name: &#039;.gitkeep&#039; }
path.parse(&#039;.gitkeep&#039;)</code></pre>
</div><p>但是针对带有多个 <strong>.</strong> 的文件名不太友好，比如<code>.d.ts</code>是期望被当做完整的<code>ext</code>处理</p>
<p>所以咱们可以对其简单递归包装一下实现1个<code>nameParse</code>，确保最后<code>parse(input).name === input</code>即可</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::00fyhd2bpk0qqv4tj9dg5tg::--><code>function nameParse(filename: string, suffix = &#039;&#039;) {
  const { name, ext } = path.parse(filename)
  if (name === filename) {
    return { name, ext: ext + suffix }
  }
  return nameParse(name, ext + suffix)
}</code></pre>
</div><p>下面是运行示例</p>
<p><img src="./fs-cli/MTY2ODY5NzM4MDAzNw==668697380037.png" alt="图片" loading="lazy"></p>
<p>到此完成了<code>name</code>和<code>ext</code>的分离</p>
<p>文件名分离后简单进行一下<code>name</code>的合法性替换，避免出现操作系统不支持的字符</p>
<blockquote>
<p>正则来自于Google</p>
</blockquote>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::oeecztr3kizdyorr26799::--><code>function normalizeFilename(name: string) {
  return name.replace(/[\\/:*?&quot;&lt;&gt;|]/g, &#039;&#039;)
}</code></pre>
</div><p>再做文件名去重只需要给<code>name</code>添加后缀数字即可</p>
<p><code>url</code>上的内容还可能存在<code>encode</code>的情况，比如<code>掘金.png</code> =&gt; encode =&gt; <code>%E6%8E%98%E9%87%91.png</code></p>
<p>因此咱们在处理从<code>pathname</code>提取的<code>filename</code>前先进行必要的<code>decode</code></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::9z066i1o8lp94n8l6vp3bs::--><code>decodeURIComponent(&#039;%E6%8E%98%E9%87%91.png&#039;) // 掘金.png</code></pre>
</div><p>有了前面的准备工作咱们就可以组装出一个从<code>url</code>提取合法可用的文件名的方法嘞</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::jq8saictxeey0tdfxdquq::--><code>function getValidFilenameByUrl(url: string) {
  const urlInstance = new URL(url)
  return decodeURIComponent(path.basename(urlInstance.pathname))
}
getValidFilenameByUrl(&#039;http://a/b/c.png?width=100&amp;height&#039;) // c.png</code></pre>
</div><p>然后是获取不重复的文件路径</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::8dnwbnjdrrvu5jkvjrwyc::--><code>function getNoRepeatFilepath(filename: string, dir = process.cwd()) {
  const { name, ext } = nameParse(filename)
  let i = 0
  let filepath = &#039;&#039;
  do {
    filepath = path.join(dir, `${name}${i ? ` ${i}` : &#039;&#039;}${ext}`)
    i += 1
  } while (fs.existsSync(filepath))
  return filepath
}</code></pre>
</div><p>最后集成到<code>downloadByUrl</code>方法中，使输出的文件名可控</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::hkqytjinyrsvd8tjhndxhd::--><code>// ...code
const filename = normalizeFilename(
  ops.filename || getValidFilenameByUrl(url) || randomName()
)
const filepath = ops.override
  ? path.resolve(filename)
  : getNoRepeatFilepath(filename)

const writeStream = fs.createWriteStream(filepath)

// ...code</code></pre>
</div><p>测试案例运行结果如下</p>
<p><img src="./fs-cli/MTY2ODc4Njc0NzcwMg==668786747702.png" alt="图片" loading="lazy"></p>
<p><a href="https://github.com/ATQQ/tools/blob/main/packages/cli/efst/__test__/download/7.ts" target="_blank" rel="noreferrer">示例代码7</a></p>
<h3 id="异常错误情况处理" tabindex="-1">异常错误情况处理 <a class="header-anchor" href="#异常错误情况处理" aria-label="Permalink to “异常错误情况处理”">&#8203;</a></h3>
<p>对于非法的<code>url</code>，资源不存在通常会响应<code>404</code>等没考虑到的异常场景</p>
<p>可以在上述的<code>downloadByUrl</code>方法中拓展1个<code>error</code>方法，用于错误处理</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::weeumrxp5fcy10bscb5xmi::--><code>let request: http.ClientRequest

let errorFn = (err, source) =&gt; {
  console.log(&#039;error url:&#039;, source)
  console.log(&#039;error msg:&#039;, err.message)
  console.log()
}

const responseCallback = (response: http.IncomingMessage) =&gt; {
  const { statusCode } = response
  // 404
  if (statusCode === 404) {
    request.emit(&#039;error&#039;, new Error(&#039;404 source&#039;))
    return
  }
}

// ...code
try {
  request = _http.get(url, reqOptions, responseCallback)
  request.on(&#039;error&#039;, (err) =&gt; {
    request.destroy()
    errorFn &amp;&amp; errorFn(err, url)
  })
  request.on(&#039;timeout&#039;, () =&gt; {
    request.emit(&#039;error&#039;, new Error(&#039;request timeout&#039;))
  })
} catch (error: any) {
  setTimeout(() =&gt; {
    errorFn &amp;&amp; errorFn(error, url)
  })
}</code></pre>
</div><p>除特殊情况外，统一用<code>request.on('error')</code>处捕获错误</p>
<p>下面是示例代码及运行结果</p>
<p><img src="./fs-cli/MTY2ODg0NjEwNDEwMQ==668846104101.png" alt="图片" loading="lazy"></p>
<p><a href="https://github.com/ATQQ/tools/blob/main/packages/cli/efst/__test__/download/8.ts" target="_blank" rel="noreferrer">示例代码8</a></p>
<h2 id="封装cli" tabindex="-1">封装CLI <a class="header-anchor" href="#封装cli" aria-label="Permalink to “封装CLI”">&#8203;</a></h2>
<p>上一小节阐述了功能的核心实现方法，此部分将上述能力集成到CLI中，方便对外分享与使用。</p>
<h3 id="options定义" tabindex="-1">Options定义 <a class="header-anchor" href="#options定义" aria-label="Permalink to “Options定义”">&#8203;</a></h3>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::qu2euye1cg8c1igyaz05f::--><code>import { Command } from &#039;commander&#039;
const program = new Command()

program
  .argument(&#039;&lt;url&gt;&#039;, &#039;set download source url&#039;)
  .option(&#039;-f,--filename &lt;filename&gt;&#039;, &#039;set download filename&#039;)
  .option(&#039;-L,--location &lt;times&gt;&#039;, &#039;set location times&#039;, &#039;10&#039;)
  .option(&#039;-t,--timeout &lt;timeout&gt;&#039;, &#039;set the request timeout(ms)&#039;, &#039;3000&#039;)
  .option(&#039;-p,--proxy &lt;proxy server&gt;&#039;, &#039;set proxy server&#039;)
  .option(&#039;-o,--override&#039;, &#039;override duplicate file&#039;, false)
  .action(defaultCommand)</code></pre>
</div><p><img src="./fs-cli/MTY2ODg0ODAxNzkxOQ==668848017919.png" alt="图片" loading="lazy"></p>
<h3 id="参数转换传递" tabindex="-1">参数转换传递 <a class="header-anchor" href="#参数转换传递" aria-label="Permalink to “参数转换传递”">&#8203;</a></h3>
<p>下面是<code>defaultCommand</code>的逻辑，只需要将相关参数处理后透传给定义的<code>download</code>方法即可</p>
<p><code>option</code> 不支持 <strong>number</strong> 所以需要对数字字符串做一下显示转换</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::6m4jt4zupe5t5xrhttmne::--><code>export default function defaultCommand(url: string, options: CLIOptions) {
  const { filename, location, timeout, proxy, override } = options
  downloadByUrl(url, {
    maxRedirects: +location,
    timeout: +timeout,
    proxy,
    override,
    filename
  })
    .error((err) =&gt; {
      console.log(&#039;error url:&#039;, url)
      console.log(&#039;error msg:&#039;, redStr(err.message))
      process.exit()
    })
    .end((filepath) =&gt; {
      console.log(&#039;file save:&#039;, underlineStr(yellowStr(filepath)))
    })
}</code></pre>
</div><p>下面是使用演示</p>
<p><img src="./fs-cli/MTY2ODg1MDU4NzY1OQ==668850587659.png" alt="图片" loading="lazy"></p>
<h3 id="下载进度展示" tabindex="-1">下载进度展示 <a class="header-anchor" href="#下载进度展示" aria-label="Permalink to “下载进度展示”">&#8203;</a></h3>
<p>小文件还能无感等待，大文件咱就得整个进度条来显示了，方遍了解进度。</p>
<p>在<code>npm</code>中检索，除了推荐了老牌库 <a href="https://www.npmjs.com/package/progress" target="_blank" rel="noreferrer">progress</a>，还看到了1个 <a href="https://www.npmjs.com/package/cli-progress" target="_blank" rel="noreferrer">cli-progress</a></p>
<p>咱们这里就用后者（最近更新时间看着近一些）</p>
<p>最简单的示例与结果如下</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::7h32hv2so2lyz23lqajpyq::--><code>import cliProgress from &#039;cli-progress&#039;

const progressBar = new cliProgress.SingleBar({})
downloadByUrl(url)
  .progress((cur, rec, sum) =&gt; {
    // 初始化
    if (progressBar.getProgress() === 0) {
      progressBar.start(sum, 0)
    }

    // 更新进度
    progressBar.update(rec)

    // 结束
    if (rec === sum) {
      progressBar.stop()
    }
  })</code></pre>
</div><p><img src="./fs-cli/MTY2ODg2NDk4NjA2OA==668864986068.png" alt="图片" loading="lazy"></p>
<p>展示内容过于简单，可以自定义一下显示，展示文件大小和下载速度，<a href="https://www.npmjs.com/package/cli-progress" target="_blank" rel="noreferrer">参考文档</a>，结合内置的一些值设定初始化如下</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::8xu4mkvnux741luy571gn::--><code>const format = &#039;[{bar}] {percentage}% | ETA: {eta}s | {rec}/{sum} | Speed {speed}&#039;

const progressBar = new cliProgress.SingleBar(
  {
    format,
    barsize: 16
  },
  cliProgress.Presets.shades_classic
)</code></pre>
</div><p>紧接着是<code>start</code>时设置<code>sum</code>和<code>speed</code>默认值</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::jvk595a09f3dsyz5m44ny::--><code>// 初始化的时候计算总大小
progressBar.start(sum, 0, {
  sum: formatSize(sum)
})

// 过程中更新进度
progressBar.update(rec, {
  rec: formatSize(rec),
  speed: speed(cur)
})</code></pre>
</div><p><code>formatSize</code>方法实现如下(来源于谷歌推荐代码)，短小精悍的代码，将B转换为其它单位展示。</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::td3wnr9tzkg6rsxywp1thk::--><code>export function formatSize(
  size: number,
  pointLength?: number,
  units?: string[]
) {
  let unit
  units = units || [&#039;B&#039;, &#039;K&#039;, &#039;M&#039;, &#039;G&#039;, &#039;TB&#039;]
  while ((unit = units.shift()) &amp;&amp; size &gt; 1024) {
    size /= 1024
  }
  return (
    (unit === &#039;B&#039;
      ? size
      : size.toFixed(pointLength === undefined ? 2 : pointLength)) + unit!
  )
}

formatSize(1234) // 1.21K
formatSize(10240) // 10.00K</code></pre>
</div><h3 id="计算下载速度" tabindex="-1">计算下载速度 <a class="header-anchor" href="#计算下载速度" aria-label="Permalink to “计算下载速度”">&#8203;</a></h3>
<p><code>speed</code>方法实现如下</p>
<ul>
<li>使用闭包</li>
<li>一段时间计算一次速度（1000ms / 时间周期 * 周期内下载量B）</li>
</ul>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::ph941id3hwp0kqi7mc4ndb::--><code>/**
 * @param cycle 多久算一次（ms）
 */
function getSpeedCalculator(cycle = 500) {
  let startTime = 0
  let endTime = 0
  let speed = &#039;N/A&#039; // 记录速度
  let sum = 0 // 计算之前收到了多少B

  return (chunk: number) =&gt; {
    sum += chunk
    if (startTime === 0) {
      startTime = Date.now()
    }
    endTime = Date.now()
    // 计算一次
    if (endTime - startTime &gt;= cycle) {
      speed = `${formatSize((1000 / (endTime - startTime)) * sum)}/s`
      startTime = Date.now()
      sum = 0
    }
    return speed
  }
}

// 获取到计算速度的方法
const speed = getSpeedCalculator()

setTimeout(speed, 200, 4000)
setTimeout(speed, 300, 5000)
setTimeout(speed, 1000, 10240)
setTimeout(() =&gt; {
  console.log(speed(0)) // 23.49K/s
}, 1100)</code></pre>
</div><p>优化后的下载效果如下</p>
<p><img src="./fs-cli/MTY2ODg2ODI5MjgxNg==668868292816.png" alt="图片" loading="lazy"></p>
<h3 id="持久化配置存储" tabindex="-1">持久化配置存储 <a class="header-anchor" href="#持久化配置存储" aria-label="Permalink to “持久化配置存储”">&#8203;</a></h3>
<p>像<code>proxy</code>，<code>timeout</code>参数不希望每次都设置，就需要将这些配置存起来，下次直接读取。</p>
<p>通常的CLI工具都会在<code>/Users/$username/.xxx</code>目录中存放自己的配置文件，即<code>HOME</code>目录下。</p>
<p><img src="./fs-cli/MTY2ODg2ODgwOTU3Mw==668868809573.png" alt="图片" loading="lazy"></p>
<p>同理我们可以开辟一个文件存放<code>.efstrc</code>，<code>process.env.HOME</code>即可获取到<code>HOME</code>目录,<code>process.env.USERPROFILE</code>用于兼容<code>win32</code>平台。</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::kunh2tzk7es4zkkyucf7c::--><code>const configPath = path.join(
  process.env.HOME || process.env.USERPROFILE || process.cwd(),
  &#039;.efstrc&#039;
)</code></pre>
</div><p>读写配置实现如下,利用<code>Array.prototype.reduce</code>方法在遍历的过程中做存取值操作</p>
<ul>
<li>支持<strong>多级的key</strong>的读写</li>
<li>兼容异常场景，返回空或空对象</li>
</ul>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::ey1oiqfululgf13zagv7h::--><code>function getCLIConfig(key = &#039;&#039;) {
  try {
    const value = JSON.parse(fs.readFileSync(configPath, &#039;utf-8&#039;))
    return !key
      ? value
      : key.split(&#039;.&#039;).reduce((pre, k) =&gt; {
          return pre?.[key]
        }, value)
  } catch {
    return !key ? {} : &#039;&#039;
  }
}

function setCLIConfig(key: string, value: string) {
  if (!key) {
    return
  }
  const nowCfg = getCLIConfig()
  // 支持传入多级的key
  const keys = key.split(&#039;.&#039;)

  // 遍历设置的所有都配置都与nowCfg直接或间接的进行了引用关联
  keys.reduce((pre, k, i) =&gt; {
    // 赋值
    if (i === keys.length - 1) {
      pre[k] = value
    } else if (!(pre[k] instanceof Object)) {
      pre[k] = {}
    }
    return pre[k]
  }, nowCfg)

  // 输出到文件
  fs.writeFileSync(configPath, JSON.stringify(nowCfg, null, 2))
}

setCLIConfig(&#039;proxy&#039;, &#039;http://127.0.0.1:7890&#039;)
setCLIConfig(&#039;timeout&#039;, &#039;2000&#039;)
setCLIConfig(&#039;github.name&#039;, &#039;ATQQ&#039;)
setCLIConfig(&#039;github.info.url&#039;, &#039;https://github.com/ATQQ&#039;)</code></pre>
</div><p><img src="./fs-cli/MTY2ODg2OTk1MzUyNA==668869953524.png" alt="图片" loading="lazy"></p>
<p>再添加一个移除配置的方法，与设置的的方法类似只是使用<code>delete</code>操作符删除相关的<code>key</code></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::w4dfx6e6utnosez89wwug::--><code>function delCLIConfig(key: string) {
  if (!key) {
    return
  }
  const nowCfg = getCLIConfig()
  const keys = key.split(&#039;.&#039;)
  keys.reduce((pre, k, i) =&gt; {
    // 移除
    if (i === keys.length - 1) {
      delete pre[k]
    }
    return pre[k] instanceof Object ? pre[k] : {}
  }, nowCfg)
  fs.writeFileSync(configPath, JSON.stringify(nowCfg, null, 2))
}

delCLIConfig(&#039;timeout&#039;)
delCLIConfig(&#039;github.info.name&#039;)
delCLIConfig(&#039;github.name&#039;)</code></pre>
</div><p><img src="./fs-cli/MTY2ODg3MDYzODk1NA==668870638954.png" alt="图片" loading="lazy"></p>
<p>有了这3个方法支撑就可以封装成一个<code>config</code>指令用于配置的<code>CRUD</code></p>
<h3 id="config指令实现" tabindex="-1">config指令实现 <a class="header-anchor" href="#config指令实现" aria-label="Permalink to “config指令实现”">&#8203;</a></h3>
<p>先是定义</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::npxlzbe3gmiitn8wnqxrzc::--><code>program
  .command(&#039;config &lt;type&gt; &lt;key&gt; [value]&#039;)
  .alias(&#039;c&#039;)
  .description(&#039;crud config &lt;type&gt; in [del,get,set]&#039;)
  .action(configCommand)</code></pre>
</div><p><img src="./fs-cli/MTY2ODg3MjMzMzkzNQ==668872333935.png" alt="图片" loading="lazy"></p>
<p><code>configCommand</code>封装实现，将上述实现的方法按场景放入即可</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::yt5zcy4rampdos6buq74mc::--><code>export type ConfigType = &#039;set&#039; | &#039;get&#039; | &#039;del&#039;

function defaultCommand(
  type: ConfigType,
  key: string,
  value: string
) {
  if (type === &#039;set&#039;) {
    setCLIConfig(key, value)
  }
  if (type === &#039;del&#039;) {
    delCLIConfig(key)
  }
  if (type === &#039;get&#039;) {
    console.log(getCLIConfig(key) || &#039;&#039;)
  }
}</code></pre>
</div><p>使用演示如下</p>
<p><img src="./fs-cli/MTY2ODg3MzQyNzc2Nw==668873427767.png" alt="图片" loading="lazy"></p>
<p>config 指令这部分逻辑完全可以分离成一个通用的 <code>commander</code> 模块，在需要的CLI里直接注册即可，简化后大概如下</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::qle52yuflfry3q2k2tjr::--><code>import { Command } from &#039;commander&#039;
const program = new Command()

registerConfigCommand(program,&#039;.efstrc&#039;)</code></pre>
</div><h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>笔者对这个工具的想法还有很多，后续先把功能🐴出来再写续集，本文就先到这里。</p>
<p>内容有不妥的之处，还请评论区斧正。</p>
<p>CLI完整源码见<a href="https://github.com/ATQQ/tools/tree/main/packages/cli/efst" target="_blank" rel="noreferrer">GitHub</a></p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/fs-cli/MTY2ODkyMDg3NDEwNg==668920874106.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[SourceMap解析CLI工具实现]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/sm-cli.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/sm-cli.html</guid>
            <pubDate>Sat, 29 Oct 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[前言
source-map 大家都不陌生了，通常情况就是产物里的`xx.js.map`文件里的内容。
可用于对压缩混淆后的代码还原。通常用于帮助定位源码问题。
区别于构建时的配置（以webpack 的]]></description>
            <content:encoded><![CDATA[<h1 id="sourcemap解析cli工具实现" tabindex="-1">SourceMap解析CLI工具实现 <a class="header-anchor" href="#sourcemap解析cli工具实现" aria-label="Permalink to “SourceMap解析CLI工具实现”">&#8203;</a></h1>
<blockquote>
<p>本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！</p>
</blockquote>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p><strong>source-map</strong> 大家都不陌生了，通常情况就是产物里的<code>xx.js.map</code>文件里的内容。</p>
<p>可用于对压缩混淆后的代码还原。通常用于帮助定位源码问题。</p>
<p>区别于构建时的配置（<a href="https://webpack.docschina.org/configuration/devtool/#special-cases" target="_blank" rel="noreferrer">以webpack 的devtool配置项为例</a>）不同配置，<code>source-map</code>暴露的信息程度也就也不一样</p>
<p>一般公司里的项目，是会把<code>.map</code>文件上传到内网环境，不耽误问题排查，也不暴露源码</p>
<p>个人的开源项目，一般就没这么讲究了，直接和产物一起传了。</p>
<p>前端监控平台，一般都支持错误堆栈解析，通过<code>.map</code>，还原出错代码位置调用堆栈信息。</p>
<p>有时候没有自动解析的平台可用的时候（比如一些商用监控平台，免费版通常不提供自动source-map解析能力）</p>
<p>就会搜些在线<code>source-map</code>解析工具凑合一下，包含在线网页，以及CLI版本的。作者也体验使用了一些（都贴到最后附录列表中，读者有其它推荐的也可评论区补充）。</p>
<p>本文将综合现有的source-map cli解析工具优缺点，取长补短，🐴一个缝合怪（主要包含<code>报错源码解析</code>和<code>根据sourceMap文件生成源码</code>2个能力）。</p>
<p>先上个演示，有兴趣的读者可接着往下看</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::07wfues3adubw4bidlcz6k::--><code>npm i -g @sugarat/source-map-cli</code></pre>
</div><p><img src="./sm-cli/MTY2NzY2NTE1NzQwOQ==667665157409.png" alt="图片" loading="lazy"></p>
<h2 id="source-map库的简介" tabindex="-1">source-map库的简介 <a class="header-anchor" href="#source-map库的简介" aria-label="Permalink to “source-map库的简介”">&#8203;</a></h2>
<p>npm地址：<a href="https://www.npmjs.com/package/source-map" target="_blank" rel="noreferrer">source-map</a></p>
<p>可以用于生成和解析sourcemap的库，本文主要用到其解析的能力，关注<a href="https://www.npmjs.com/package/source-map#sourcemapconsumer" target="_blank" rel="noreferrer">API:SourceMapConsumer</a>即可</p>
<p>下面是示例，其返回值<code>consumer</code>是一个<code>Promise</code></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::a6ihd6fne9qll079x2bum::--><code>import sourceMap from &#039;source-map&#039;

function createSourceMapConsumer(sourceMapCode: string) {
  const consumer = new sourceMap.SourceMapConsumer(sourceMapCode)
  return consumer
}</code></pre>
</div><p><code>consumer</code>中包含一个<code>sources</code>属性，标明了包含的所用到的源码文件路径信息，通过实例上的<code>sourceContentFor</code>方法即可获取到对应<code>文件(source)</code>的<code>源码(sourceCode)</code></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::8tg6m1hfw45pk63g9g981::--><code>// mapContent 内容来源 https://script.sugarat.top/js/tests/index.9bb0da5c.js.map
;(async () =&gt; {
  const consumer = await createSourceMapConsumer(mapContent)

  // [
  // &#039;../../vite/modulepreload-polyfill&#039;,
  // &#039;../../node_modules/.pnpm/@vue+shared@3.2.37/node_modules/@vue/shared/dist/shared.esm-bundler.js&#039;,
  // 类似的源文件路径
  // ]
  const sourceFileNames = consumer.sources

  // 源文件个数
  const sourceCount = sourceFileNames.length

  // 第一个源文件的内容
  const sourceCode = consumer.sourceContentFor(sourceFileNames[0])
})()</code></pre>
</div><p><code>consumer</code>实例上的另一个最常用的方法<code>originalPositionFor</code>可以通过压缩混淆后的代码行列号，解析出源文件信息。</p>
<p>包含<code>源文件source</code>,<code>行号line</code>,<code>列号column</code>,<code>name</code></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::6o13dy56ct4mfalg6pqz7a::--><code>// 第一个源文件的内容
const sourceCode = consumer.sourceContentFor(sourceFileNames[0])

// 通过压缩混淆后的代码的行列号，定位到源文件
const sourceInfo = consumer.originalPositionFor({
  line: 24,
  column: 17596
})

// 这个例子的结果如下
console.log(sourceInfo)
//   {
//     source: &#039;../../node_modules/.pnpm/vue-router@4.0.14_vue@3.2.37/node_modules/vue-router/dist/vue-router.esm-bundler.js&#039;,
//     line: 2882,
//     column: 12,
//     name: null
//   }</code></pre>
</div><p>通过如上2个简单的<code>API</code>即可完成常用能力的封装。</p>
<p>本小节<a href="https://github.com/ATQQ/tools/blob/main/packages/cli/source-map/__test__/sourcemap.ts" target="_blank" rel="noreferrer">示例代码</a></p>
<h2 id="map资源加载" tabindex="-1">.map资源加载 <a class="header-anchor" href="#map资源加载" aria-label="Permalink to “.map资源加载”">&#8203;</a></h2>
<p>通常每个js产物都对应有一份<code>.map</code>文件，文件命名为<code>原文件名.js.map</code></p>
<p>在不考虑特殊的约定条件情况下，通常情况是在js产物末尾都有1个<code>// #sourceMappingURL=xx.js.map</code>注释表明js资源关联的map文件路径</p>
<p>于是乎咱们，可以先写个方法来获取传入文件对应的sourceMap文件路径</p>
<h3 id="本地sourcemap路径获取" tabindex="-1">本地sourceMap路径获取 <a class="header-anchor" href="#本地sourcemap路径获取" aria-label="Permalink to “本地sourceMap路径获取”">&#8203;</a></h3>
<p>先是考虑本地的情况，通过路径拼接<code>.map</code>与读取文件文件末尾<code>sourceMappingURL</code>2种方式相结合</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::1fni8xhlyc78a60ryoz3ep::--><code>function getLocalSourceMapFilePath(sourceJsPath: string) {
  // 文件不存在
  if (!existsSync(sourceJsPath)) {
    return NOT_FOUND
  }

  // 先直接判断是否存在.js.map文件存在
  if (existsSync(`${sourceJsPath}.map`)) {
    return `${sourceJsPath}.map`
  }

  // 获取代码里的 // #sourceMappingURL= 注释的内容
  const jsCode = readFileSync(sourceJsPath, &#039;utf-8&#039;)
  const flag = &#039;//# sourceMappingURL=&#039;
  const flagIdx = jsCode.lastIndexOf(flag)
  if (flagIdx === -1) {
    return NOT_FOUND
  }
  const sourceMappingURL = jsCode.slice(flagIdx + flag.length)

  // 如果是http路径表明 是绝对路径 直接返回
  if (isHTTPSource(sourceMappingURL)) {
    return sourceMappingURL
  }

  // 否则拼接js资源的目录
  return path.resolve(path.dirname(sourceJsPath), sourceMappingURL)
}</code></pre>
</div><p>本小节<a href="https://github.com/ATQQ/tools/blob/9cee3f881157199c365b0a41ababe31d2f5b6fdf/packages/cli/source-map/src/util/index.ts#L26" target="_blank" rel="noreferrer">示例代码</a></p>
<h3 id="远程资源加载" tabindex="-1">远程资源加载 <a class="header-anchor" href="#远程资源加载" aria-label="Permalink to “远程资源加载”">&#8203;</a></h3>
<p>除了本地情况那也有线上资源的情况，比如用于测试的<code>https://script.sugarat.top/js/tests/index.9bb0da5c.js</code></p>
<p>下面介绍3种常见方式获取<code>http</code>资源，<code>http</code>,<code>axios</code>,<code>fetch</code></p>
<p>首先是<code>http</code>，node内置网络模块，使用上的感官和web里的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noreferrer">XMLHttpRequest</a>差不多，不太优雅</p>
<p>简单场景书写代码量也在可接受的范围</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::m2dlar7kt12yfepiiepup::--><code>import http from &#039;http&#039;
import https from &#039;https&#039;

function getRemoteSource(
  url: string
): Promise&lt;{ body: string; code?: number }&gt; {
  return new Promise((resolve, reject) =&gt; {
    // 区别https与http资源
    const HTTP = url.startsWith(&#039;https://&#039;) ? https : http

    // 通过回调的形式获取
    HTTP.get(url, (res) =&gt; {
      // 设置可读流的字符编码
      res.setEncoding(&#039;utf-8&#039;)

      // 响应内容拼接
      let content = &#039;&#039;
      res.on(&#039;data&#039;, (chunk) =&gt; {
        content += chunk
      })

      // 读完对外暴露内容和状态码
      res.on(&#039;end&#039;, () =&gt; {
        resolve({
          body: content,
          code: res.statusCode
        })
      })

      res.on(&#039;error&#039;, (err) =&gt; {
        reject(err)
      })
    })
  })
}</code></pre>
</div><p><code>axios</code>，前端常用的跨平台网络请求库（web/node/其它场景提供adaptor层做适配）</p>
<p>用这个代码量就更简洁了，3行就能搞定</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::olkxb5fj1ptla41a6gl91d::--><code>function getRemoteSourceByAxios(url: string) {
  return axios.get(url).then((v) =&gt; {
    return {
      code: v.status,
      body: v.data
    }
  })
}</code></pre>
</div><p><code>fetch</code>，在web侧已经出现很久了，Node.js&gt;=v17.5.0 内置，低版本可使用第三方的<a href="https://www.npmjs.com/package/node-fetch" target="_blank" rel="noreferrer">node-fetch</a></p>
<p>这里使用<code>node-fetch</code>进行举例，使用也是非常简单</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::hjs459srfa60dt2kc94l54::--><code>import fetch from &#039;node-fetch&#039;

function getRemoteSourceByFetch(url: string) {
  return fetch(url).then(async (v) =&gt; {
    const code = v.status
    const body = await v.text()
    return {
      code,
      body
    }
  })
}</code></pre>
</div><p>包含但不限于以上三种方式达到需要的目的。本小节<a href="https://github.com/ATQQ/tools/blob/main/packages/cli/source-map/__test__/remoteSource.ts" target="_blank" rel="noreferrer">示例代码</a></p>
<h3 id="远程sourcemap路径获取" tabindex="-1">远程sourceMap路径获取 <a class="header-anchor" href="#远程sourcemap路径获取" aria-label="Permalink to “远程sourceMap路径获取”">&#8203;</a></h3>
<p>思路和本地的资源逻辑基本一致，只是内容获取和判断需要走网络，实现如下，接近一半都是重复代码，有优化空间，这里不赘述了</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::gcduo04ly70lc2ocbkq12::--><code>async function getRemoteSourceMapFilePath(sourceJsPath: string) {
  const context = await getRemoteSource(sourceJsPath)
  if (context.code === 404) {
    return NOT_FOUND
  }
  if ((await getRemoteSource(`${sourceJsPath}.map`)).code === 200) {
    return `${sourceJsPath}.map`
  }
  const jsCode = context.body
  const flag = &#039;//# sourceMappingURL=&#039;
  const flagIdx = jsCode.lastIndexOf(flag)
  if (flagIdx === -1) {
    return NOT_FOUND
  }
  const sourceMappingURL = jsCode.slice(flagIdx + flag.length)
  if (isHTTPSource(sourceMappingURL)) {
    return sourceMappingURL
  }
  return path.resolve(path.dirname(sourceJsPath), sourceMappingURL)
}</code></pre>
</div><p>简单做合并后的方法如下</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::rpe195uti4n2kxkabedp::--><code>const isHTTPSource = (sourcePath: string) =&gt;
  sourcePath.startsWith(&#039;http&#039;)

async function getSourceMapFilePath(sourceJsPath: string) {
  if (!isHTTPSource(sourceJsPath)) {
    return getLocalSourceMapFilePath(sourceJsPath)
  }
  return getRemoteSourceMapFilePath(sourceJsPath)
}</code></pre>
</div><p>本小节<a href="https://github.com/ATQQ/tools/blob/9cee3f881157199c365b0a41ababe31d2f5b6fdf/packages/cli/source-map/src/util/index.ts#L19" target="_blank" rel="noreferrer">示例代码</a></p>
<h2 id="还原报错源码" tabindex="-1">还原报错源码 <a class="header-anchor" href="#还原报错源码" aria-label="Permalink to “还原报错源码”">&#8203;</a></h2>
<p>有了前面的基础，咱们第一个整合功能就可以实现了 <strong>根据报错资源信息，还原源码和行列号</strong>，先给出方法的定义</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::xo41ouu4cdc4xk3ka1z5::--><code>interface SourceResult {
  /**
   * 源码
   */
  sourceCode: string
  /**
   * 源码文件路径
   */
  source: string
  /**
   * 行号
   */
  line: number
  /**
   * 列号
   */
  column: number
}

/**
 * 根据报错资源信息，获取对应源码信息
 * @param url 报错资源
 * @param line 行号
 * @param column 列号
 */
async function getErrorSourceResult(
  url: string,
  line: number,
  column: number
): Promise&lt;SourceResult&gt;</code></pre>
</div><p>利用上面实现的<code>getSourceMapFilePath</code>,配合<code>source-map</code>的2个API即可实现<code>originalPositionFor</code>,<code>sourceContentFor</code></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::vqeud5y11hz99rl92kfr::--><code>import fs from &#039;fs/promises&#039;

const sourceMapURL = await getSourceMapFilePath(url)

// sourceMap 内容
const sourceMapCode = await (isHTTPSource(sourceMapURL)
  ? getRemoteSource(sourceMapURL).then((v) =&gt; v.body)
  : fs.readFile(sourceMapURL, &#039;utf-8&#039;))

const consumer = await createSourceMapConsumer(sourceMapCode)
// 解析出原来的行列号，源文件路径等信息
const { name, ...rest } = consumer.originalPositionFor({
  line,
  column
})
// 获取源码
const sourceCode = consumer.sourceContentFor(rest.source!)
const result = {
  ...rest,
  sourceCode
}</code></pre>
</div><p>方便终端里预览结果，可以编写一个<code>printSourceResult</code>方法，友好的打印输出一些内容</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::5pl8cua052ec0et8jb6fn::--><code>getErrorSourceResult(
  &#039;https://script.sugarat.top/js/tests/index.9bb0da5c.js&#039;,
  24,
  17596
).then(printResult)</code></pre>
</div><p>示例打印结果如下</p>
<p><img src="./sm-cli/MTY2NzYzNTkxODE1OQ==667635918159.png" alt="图片" loading="lazy"></p>
<p>方法实现如下(详细释义见注释)</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::tfi815wxd6j4sp2xwwry::--><code>/**
 * @param result
 * @param showMaxLine 控制显示的行数
 */
export function printResult(result: SourceResult, showMaxLine = 5) {
  const { sourceCode, source, line, column } = result
  // 源码拆成数租
  const lines = sourceCode.split(&#039;\n&#039;)

  // 打印错误路径
  console.log(`error in  ${source}:${line}:${column}`)
  console.log()

  // 计算要展示的行的起始位置，起始行号不能小于1
  const startLine = Math.max(1, line - Math.floor(showMaxLine / 2))
  // 结束位置不能大于总行数
  const endLine = Math.min(lines.length, startLine + showMaxLine - 1)

  const showCode = lines
    // 截取需要展示的内容
    .slice(startLine - 1, endLine)
    .map(
      (v, idx) =&gt;
        // 加上黄色行号
        `${yellowStr(startLine + idx)} ${
          // 针对错误的行进行下划线+红色展示
          idx + startLine === line
            ? // 从错误的列号开始展示
              v.slice(0, column - 1) + redStr(underlineStr(v.slice(column - 1)))
            : v
        }`
    )
    .join(&#039;\n&#039;)

  console.log(showCode)
}</code></pre>
</div><p>打印彩色的场景有限，这里直接将需要的效果颜色对应的<code>ANSI Escape code</code>从<code>chalk</code>库中截取出来</p>
<p><img src="./sm-cli/MTY2NzYzNDUwMzk2Ng==667634503966.png" alt="图片" loading="lazy"></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::pcg8xw9ttgjssrcg66m5y7::--><code>const underlineStr = (v: any) =&gt; `\x1B[4m${v}\x1B[24m`

const yellowStr = (v: any) =&gt; `\x1B[33m${v}\x1B[39m`

const redStr = (v: any) =&gt; `\x1B[31m${v}\x1B[39m`</code></pre>
</div><p>到此第一个功能的核心代码就封装好了</p>
<p>本小节<a href="https://github.com/ATQQ/tools/blob/9cee3f881157199c365b0a41ababe31d2f5b6fdf/packages/cli/source-map/__test__/util.ts#L15-L27" target="_blank" rel="noreferrer">示例代码</a></p>
<h2 id="完整source生成" tabindex="-1">完整source生成 <a class="header-anchor" href="#完整source生成" aria-label="Permalink to “完整source生成”">&#8203;</a></h2>
<p>都知道通过<code>sourceMap</code>可以获取完整的源码，所以一般的非开源应用，都是对<code>sourceMap</code>文件做了环境隔离，防止源码泄露。</p>
<p>这部分就封装1个方法，<strong>实现将sourceMap中包含的所有源文件输出到本地指定目录</strong></p>
<p>首先实现1个方法，将sourceMap中需要的信息解析出来</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::1novqq09tzs3fqqni6a4aj::--><code>export async function getSourcesBySourceMapCode(sourceMapCode: string) {
  const consumer = await createSourceMapConsumer(sourceMapCode)
  const { sources } = consumer
  const result = sources.map((source) =&gt; {
    return {
      source,
      code: consumer.sourceContentFor(source)
    }
  })
  return result
}</code></pre>
</div><p>配合文件操作(<code>fs</code>模块)，将内容输出到文件系统</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::hw4v8h8dliofecsbpeo9l6::--><code>import { existsSync, mkdirSync, writeFileSync } from &#039;fs&#039;

async function outPutSources(
  sources: SourceItem[],
  outPutDir = &#039;source-map-result/project&#039;
) {
  for (const sourceItem of sources) {
    const { source, code } = sourceItem
    const filepath = path.resolve(process.cwd(), outPutDir, source)
    if (!existsSync(path.dirname(filepath))) {
      mkdirSync(path.dirname(filepath), { recursive: true })
    }
    writeFileSync(filepath, code, &#039;utf-8&#039;)
  }
}</code></pre>
</div><p>示例代码与运行结果如下</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::vrddosxt15n48wy92y68::--><code>getRemoteSource(
  &#039;https://script.sugarat.top/js/tests/index.9bb0da5c.js.map&#039;
).then(async ({ body }) =&gt; {
  const sources = await getSourcesBySourceMapCode(body)
  console.log(sources.length, &#039;个文件&#039;)
  outPutSources(sources)
})</code></pre>
</div><p><img src="./sm-cli/MTY2NzYzOTU5NTgwOA==667639595808.png" alt="图片" loading="lazy"></p>
<p>本小节<a href="https://github.com/ATQQ/tools/blob/9cee3f881157199c365b0a41ababe31d2f5b6fdf/packages/cli/source-map/__test__/util.ts#L30-L36" target="_blank" rel="noreferrer">示例代码</a></p>
<p>到此常用的2个能力的核心实现就完成了，下面将把其封装为一个CLI工具，方便接入使用</p>
<h2 id="封装cli" tabindex="-1">封装CLI <a class="header-anchor" href="#封装cli" aria-label="Permalink to “封装CLI”">&#8203;</a></h2>
<p>基于<code>commander</code>进行实践</p>
<h3 id="parse指令" tabindex="-1">parse指令 <a class="header-anchor" href="#parse指令" aria-label="Permalink to “parse指令”">&#8203;</a></h3>
<p>首先是指令的定义</p>
<p>主要功能就是将指定的 <code>error js</code> 资源的通过<code>sourcemap</code>还原出具体的报错源码</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::gietwnh69441t6fnae5397::--><code>program
  // sourceUrl 格式 &lt;url&gt;[:line][:column]
  .command(&#039;parse &lt;sourceUrl&gt;&#039;)
  .description(&#039;parse error form url source&#039;)
  .alias(&#039;p&#039;)
  // 标明sourceUrl 是否为 sourceMap 资源
  .option(&#039;-s, --source-map&#039;, &#039;set url source as sourceMap type&#039;)
  // 单独设置行号
  .option(&#039;-l, --line &lt;number&gt;&#039;, &#039;set line number&#039;)
  // 单独设置列号
  .option(&#039;-c, --column &lt;number&gt;&#039;, &#039;set column number&#039;)
  // 将结果输出到文件
  .option(&#039;-o, --output [string]&#039;, &#039;set log output dir&#039;)
  // 设置展示的错误信息行数
  .option(&#039;-n, --show-num &lt;number&gt;&#039;, &#039;set show error source lines&#039;, &#039;5&#039;)
  .action(parseCommand)</code></pre>
</div><p>为保证下面3个指令一样的效果，需要对 <strong>&lt;sourceUrl&gt;</strong> 与 <code>-c</code>,<code>-l</code> <strong>Option</strong>做一层处理</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::mvevdl6w9t9kc87d86r2i9::--><code>smt parse xxx.js:24:17596
smt parse xxx.js -l 24 -c 17596
smt parse xxx.js:24 -c 17596</code></pre>
</div><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::o04oucm5cfdo1fyr8fikp::--><code>const match = sourceUrl.match(/:\d+/)
let url = sourceUrl
let l
let c
if (match?.index) {
  ;[l, c] = sourceUrl.slice(match.index + 1).split(&#039;:&#039;)
  url = sourceUrl.slice(0, match.index)
}
// 最终需要的行号和列号
const line = l || options.line
const column = c || options.column</code></pre>
</div><p>后续的处理逻辑只需要把<code>url</code>,<code>line</code>,<code>column</code>3个参数传给前面实现的<code>getErrorSourceResult</code>方法即可</p>
<p>效果如下</p>
<p><img src="./sm-cli/MTY2NzY1NzIwMDI4OQ==667657200289.png" alt="图片" loading="lazy"></p>
<p>本小节<a href="https://github.com/ATQQ/tools/blob/main/packages/cli/source-map/src/command/parse.ts" target="_blank" rel="noreferrer">源码</a></p>
<h3 id="sources指令" tabindex="-1">sources指令 <a class="header-anchor" href="#sources指令" aria-label="Permalink to “sources指令”">&#8203;</a></h3>
<p>sources指令定义</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::qak9kaouf6lwqssogvp9f::--><code>program
  .command(&#039;sources &lt;sourceUrl&gt;&#039;)
  .description(&#039;generating source files by source-map&#039;)
  .alias(&#039;s&#039;)
  .option(&#039;-s, --source-map&#039;, &#039;set url source as sourceMap type&#039;)
  .option(&#039;-o, --output [string]&#039;, &#039;set log output dir&#039;)
  .action(sourcesCommand)</code></pre>
</div><p>效果如下</p>
<p><img src="./sm-cli/MTY2NzY2MDI1Mjg4MA==667660252880.png" alt="图片" loading="lazy"></p>
<p>本小节<a href="https://github.com/ATQQ/tools/blob/main/packages/cli/source-map/src/command/sources.ts" target="_blank" rel="noreferrer">源码</a></p>
<h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>这个CLI本身能力比较简单，依赖的核心库也只有<code>source-map</code>。主要用于弥补缺失平台自动解析source-map能力的场景，协助定位<code>js error</code>的报错源码</p>
<p>后续再出一篇在线sourcemap解析的工具，功能与CLI类似，不过是Web版的</p>
<p>CLI完整源码见<a href="https://github.com/ATQQ/tools/tree/main/packages/cli/source-map" target="_blank" rel="noreferrer">GitHub</a></p>
<h2 id="附录" tabindex="-1">附录 <a class="header-anchor" href="#附录" aria-label="Permalink to “附录”">&#8203;</a></h2>
<p>其它同类 Web&amp;CLI 工具</p>
<p>Web</p>
<ul>
<li><a href="https://www.hai-fe.com/decodeSourceMap" target="_blank" rel="noreferrer">decodeSourceMap</a></li>
</ul>
<p>CLI</p>
<ul>
<li><a href="https://www.npmjs.com/package/restore-source-tree" target="_blank" rel="noreferrer">restore-source-tree</a></li>
<li><a href="https://www.npmjs.com/package/source-map-tools" target="_blank" rel="noreferrer">source-map-tools</a></li>
<li><a href="https://www.npmjs.com/package/source-map-cli" target="_blank" rel="noreferrer">source-map-cli</a></li>
<li><a href="https://www.npmjs.com/package/source-map-to-source" target="_blank" rel="noreferrer">source-map-to-source</a></li>
<li><a href="https://www.npmjs.com/package/kaifu" target="_blank" rel="noreferrer">kaifu</a></li>
<li><a href="https://www.npmjs.com/package/@hl-cli/restore-code" target="_blank" rel="noreferrer">@hl-cli/restore-code</a></li>
</ul>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/sm-cli/MTY2NzY2NTE1NzQwOQ==667665157409.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[内联JS处理(ES语法降级&内容压缩)]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/html-inline-js-transform.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/html-inline-js-transform.html</guid>
            <pubDate>Sat, 22 Oct 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[本文简单介绍一下当前`html`在现代工程中的现状，并阐述内联js代码可能存在的一些问题，同时介绍一系列处理页面内联脚本的方法，以及通过`SWC`如何转换目标代码，通过`CLI工具如何组合这些能力`。]]></description>
            <content:encoded><![CDATA[<h1 id="内联js处理-es语法降级-内容压缩" tabindex="-1">内联JS处理(ES语法降级&amp;内容压缩) <a class="header-anchor" href="#内联js处理-es语法降级-内容压缩" aria-label="Permalink to “内联JS处理(ES语法降级&amp;内容压缩)”">&#8203;</a></h1>
<blockquote>
<p>本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！</p>
</blockquote>
<p>本文简单介绍一下当前<code>html</code>在现代工程中的现状，并阐述内联js代码可能存在的一些问题，同时介绍一系列处理页面内联脚本的方法，以及通过<code>SWC</code>如何转换目标代码，通过<code>CLI工具如何组合这些能力</code>。</p>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p><strong>当下</strong>大部分现代前端Web工程中，HTML文件大部分都是以<code>public/index.html</code>或<code>&lt;projectRoot&gt;/index.html</code>存在</p>
<p>其内容也比较简单，通常像下面这样。</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::um4mpzfdrvj0yr4udv5mtro::--><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;!-- some meta or link source --&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div><p>项目通过构建工具，将编写的&quot;源码&quot;进行<code>一系列操作</code>后转换成供浏览器可直接运行的js</p>
<p>在产生的<code>HTML文件</code>中体现的就是通过<code>&lt;script src&gt;</code>和<code>&lt;link href&gt;</code>标签引入了构建后的资源</p>
<p>其中部分插件会往页面中直接插入<code>内联的JS代码</code>。</p>
<p>当然也不排除一些项目也会主动通过<code>CDN</code>引入一些第三方的SDK，然后会在模板中插入一些<code>初始化或者激活相应功能特性的代码</code>。</p>
<p>针对上面2种情况产生的<code>JS</code>代码，<code>大部分情况下</code>是没有通过<code>babel</code>进行编译的，可能存在一些质量问题（兼容性问题为主）。</p>
<p>如果只是<code>ES语法检查</code>，可以用前面文章介绍的<a href="https://juejin.cn/post/7148618887787970597" target="_blank" rel="noreferrer">增强ESCheck工具</a>进行检测。</p>
<p>本文将进一步介绍一下提取<code>HTML inline Code</code>的多种方法，然后进一步使用<code>SWC</code>对内联脚本进行<code>压缩</code>，<code>ES语法转换降级</code>等等操作。</p>
<h2 id="inlinejs内容处理" tabindex="-1">InlineJS内容处理 <a class="header-anchor" href="#inlinejs内容处理" aria-label="Permalink to “InlineJS内容处理”">&#8203;</a></h2>
<p>用于测试的目标代码如下</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::jy536x42drj7n1gdrgoftk::--><code>&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
  &lt;script&gt;
    const hello = &#039;hello&#039;
  &lt;/script&gt;
  &lt;script src=&quot;hello.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    const world = &#039;hello&#039;
  &lt;/script&gt;
  &lt;script&gt;
    console.log(hello,world);
  &lt;/script&gt;
&lt;/body&gt;</code></pre>
</div><p>目的是将里面的<code>js code</code>先提取出来，然后将里面的<code>const</code>简单的替换成<code>var</code></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::chw2e8rol9svwrhhmwav4::--><code>// 简单转换示例
function simpleConst2Var(code: string) {
  return code.replace(/const /g, &#039;var &#039;)
}</code></pre>
</div><h3 id="正则" tabindex="-1">正则 <a class="header-anchor" href="#正则" aria-label="Permalink to “正则”">&#8203;</a></h3>
<p>搞文本内容的处理首先想到的方法，<a href="https://regexper.com/#%2F%3Cscript%3E%28%5B%5Cs%5CS%5D*%3F%29%3C%5C%2Fscript%3E%2Fg" target="_blank" rel="noreferrer">简单的正则</a>如下</p>
<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre><!--::markdown-it-async::p02xa7n91aqgjol5nacf3h::--><code>/&lt;script&gt;([\s\S]*?)&lt;\/script&gt;/g</code></pre>
</div><p><img src="./html-inline-js-transform/MTY2NjQzNTk5MjcyMg==666435992722.png" alt="图片" loading="lazy"></p>
<p>利用<code>replace</code>方法，几行代码就能搞定</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::kov499v56nhyq8wc1qpnm::--><code>function traverseScript(htmlCode: string, transformFn: (v: string) =&gt; string) {
  const rScriptTag = /&lt;script&gt;([\s\S]*?)&lt;\/script&gt;/g
  return htmlCode.replace(rScriptTag, (all, $1) =&gt; {
    return all.replace($1, transformFn($1))
  })
}</code></pre>
</div><p>局限性就是无法区分出注释，字符串的值，勉强可用。</p>
<p>示例代码地址:<a href="https://github.com/ATQQ/tools/blob/main/packages/cli/inlinejs-transform/__test__/inline-code/regexp.ts" target="_blank" rel="noreferrer">inline-code/regexp.ts</a></p>
<h3 id="gogocode" tabindex="-1">GoGoCode <a class="header-anchor" href="#gogocode" aria-label="Permalink to “GoGoCode”">&#8203;</a></h3>
<blockquote>
<p>GoGoCode 是一个基于 AST 的 JavaScript/Typescript/HTML 代码转换工具，API是jQuery风格，API还是很简洁好用</p>
</blockquote>
<p>其中<code>HTML</code>的解析使用的是<a href="https://www.npmjs.com/package/hyntax-yx" target="_blank" rel="noreferrer">hyntax-yx</a>看上去是 fork<a href="https://www.npmjs.com/package/hyntax" target="_blank" rel="noreferrer">hyntax</a>重新发了个版</p>
<p>因此用<code>GoGoCode</code>同样可以很简单的实现</p>
<p>先生成AST</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::s64wbru60kneyo3o1biwj::--><code>import $ from &#039;gogocode&#039;
const htmlAST = $(htmlCode, { parseOptions: { language: &#039;html&#039; } })</code></pre>
</div><p>遍历<code>&lt;script&gt;</code>节点，其中<code>$scriptNode</code>节点结构如下，可以直接使用<code>attr</code>方法进行值的<code>存取操作</code></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::9qhzrpqhp0c16363svghdw::--><code>htmlAST.find(`&lt;script&gt;$_$&lt;/script&gt;`).each(($scriptNode) =&gt; {
  const origin = $scriptNode.attr(&#039;content.value.content&#039;)
  $scriptNode.attr(&#039;content.value.content&#039;, transformFn(origin.toString()))
})</code></pre>
</div><p><img src="./html-inline-js-transform/MTY2NjQ0OTc4NTQxMQ==666449785411.png" alt="图片" loading="lazy"></p>
<p>完整代码如下</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::5dx77z0jqyxaa662bwh0gb::--><code>function traverseScript(htmlCode: string, transformFn: (v: string) =&gt; string) {
  const htmlAST = $(htmlCode, { parseOptions: { language: &#039;html&#039; } })
  htmlAST.find(`&lt;script&gt;$_$&lt;/script&gt;`).each(($scriptNode) =&gt; {
    const origin = $scriptNode.attr(&#039;content.value.content&#039;)
    $scriptNode.attr(&#039;content.value.content&#039;, transformFn(origin.toString()))
  })
  return htmlAST.generate()
}</code></pre>
</div><p>代码量和使用正则差不多，但使用AST操作准确性更高，可玩性也强。</p>
<p><code>hyntax</code>只提供了AST与Tokens的生成，节点遍历与AST内容转换输出由<a href="https://github.com/thx/gogocode/tree/main/packages/gogocode-core/src/html-core" target="_blank" rel="noreferrer">GoGoCode实现</a>。</p>
<p>示例代码地址:<a href="https://github.com/ATQQ/tools/blob/main/packages/cli/inlinejs-transform/__test__/inline-code/gogocode.ts" target="_blank" rel="noreferrer">inline-code/gogocode.ts</a></p>
<h3 id="svelte" tabindex="-1">svelte <a class="header-anchor" href="#svelte" aria-label="Permalink to “svelte”">&#8203;</a></h3>
<blockquote>
<p><a href="https://www.sveltejs.cn/" target="_blank" rel="noreferrer">Svelte</a> 是一种全新的构建用户界面的方法。传统框架如 React 和 Vue 在浏览器中需要做大量的工作，而 Svelte 将这些工作放到构建应用程序的编译阶段来处理。</p>
</blockquote>
<p><em>当然不了解这个框架，也不影响理解后续的代码，可以接着往下看</em></p>
<p>这个是从 <a href="https://astexplorer.net/#/gist/d08dcb5d93461b5811a254a8f9630a6f/5032128f77e49280e3fbfc4656bd9560f6ce6dec" target="_blank" rel="noreferrer">AST Explorer</a> transform示例demo中看到的</p>
<p>看了一下<a href="https://github1s.com/fkling/astexplorer/blob/HEAD/website/src/parsers/html/transformers/svelte/index.js#L35" target="_blank" rel="noreferrer">demo实现代码</a></p>
<p><a href="https://github.com/sveltejs/svelte/blob/146e7a6310627d4599bb60760d573dffa5d1d2ce/src/compiler/compile/index.ts#L88" target="_blank" rel="noreferrer">sevlte/compiler</a>提供了直接生成AST的方法<code>compile</code></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::lbpeddfm5inivllmc5bhd::--><code>import * as svelte from &#039;svelte/compiler&#039;

const AST = svelte.compile(htmlCode).ast
const htmlAST = AST.html</code></pre>
</div><p><img src="./html-inline-js-transform/MTY2NjUxMjc4MTc4MQ==666512781781.png" alt="图片" loading="lazy"></p>
<p>同时提供了一个预处理方法<code>preprocess</code>，可以实现<code>script</code>,<code>style</code>与其他标签内容的遍历与修改，最后返回处理后的结果</p>
<p>使用示例如下，其返回值是<code>promise</code></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::ncy3r5vge2iu1hflp00x7::--><code>import * as svelte from &#039;svelte/compiler&#039;

svelte.preprocess(htmlCode, {
  script(ops) {
    return {
      code: transformFn(ops.content)
    }
  }
})</code></pre>
</div><p>同样按照上面要求实现<code>script代码的转换</code>，代码很简洁</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::cnp6qpa2jh6o9gckvybm1::--><code>function traverseScript(htmlCode: string, transformFn: (v: string) =&gt; string) {
  return svelte
    .preprocess(htmlCode, {
      script(ops) {
        return {
          code: transformFn(ops.content)
        }
      }
    })
    .then((v) =&gt; v.code)
}</code></pre>
</div><p>示例代码地址:<a href="https://github.com/ATQQ/tools/blob/main/packages/cli/inlinejs-transform/__test__/inline-code/svelte.ts" target="_blank" rel="noreferrer">inline-code/svelte.ts</a></p>
<h3 id="posthtml" tabindex="-1">posthtml <a class="header-anchor" href="#posthtml" aria-label="Permalink to “posthtml”">&#8203;</a></h3>
<blockquote>
<p><a href="https://github.com/posthtml/posthtml" target="_blank" rel="noreferrer">PostHTML</a> 是一个支持使用用 JS 插件转换 HTML/XML 的库。本身只包含<code>HTML parser</code>, <code>HTML node tree API</code>, <code>node tree stringifier</code>三部分。</p>
</blockquote>
<p>插件开发也很简单，其官方的<a href="https://github.com/posthtml/awesome-posthtml" target="_blank" rel="noreferrer">awesome</a>里提供了很多示例的插件，也有可参考的<a href="https://posthtml.org/#/api" target="_blank" rel="noreferrer">API文档</a></p>
<p>先通过<a href="https://astexplorer.net/#/gist/d08dcb5d93461b5811a254a8f9630a6f/cc9ab894776ff836030a82a44bbe6794ad5c306c" target="_blank" rel="noreferrer">AST Explorer demo 示例</a>看一下其生成的AST面貌</p>
<p>其AST结构描述很朴素</p>
<p><img src="./html-inline-js-transform/MTY2NjUxNjA5NzE0NQ==666516097145.png" alt="图片" loading="lazy"></p>
<p>使用方法如下,也很简单</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::ho630jey5ckhn41ano4fz::--><code>import posthtml, { Node } from &#039;posthtml&#039;

const result = posthtml()
    .use(posthtmlPlugin)
    .process(htmlCode, { sync: true }).html</code></pre>
</div><p>这里就简单实现一下<code>posthtmlScriptContentTransform</code></p>
<ul>
<li>利用<code>match</code>遍历<code>script</code>节点</li>
<li>使用用户传入的<code>transformFn</code>处理<code>content</code>内容</li>
</ul>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::377d7quy54ek6hqih6wzei::--><code>import type { Node } from &#039;posthtml&#039;

function posthtmlScriptContentTransform(transformFn: (v: string) =&gt; string) {
  return (tree: Node) =&gt; {
    tree.match({ tag: &#039;script&#039; }, (node) =&gt; {
      if (node?.content?.[0]) {
        node.content[0] = transformFn(node.content[0].toString())
      }
      return node
    })
  }
}</code></pre>
</div><p>最终使用代码如下</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::7il01xw5ql74w752mpto0u::--><code>function traverseScript(htmlCode: string, transformFn: (v: string) =&gt; string) {
  return posthtml()
    .use(posthtmlScriptContentTransform(transformFn))
    .process(htmlCode, { sync: true }).html
}</code></pre>
</div><p>示例代码地址:<a href="https://github.com/ATQQ/tools/blob/main/packages/cli/inlinejs-transform/__test__/inline-code/posthtml.ts" target="_blank" rel="noreferrer">inline-code/posthtml.ts</a></p>
<h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to “小结”">&#8203;</a></h3>
<p>这部分除了<code>正则</code>外，介绍了3个可以用来提取<code>inline js</code>库（<code>gogocode</code>，<code>svelte</code>，<code>posthtml</code>）</p>
<p>从专业程度来看<code>posthtml</code>更加合适，拓展起来也方便，后面的功能也将基于其直接开发插件，方便复用。</p>
<h2 id="使用swc处理" tabindex="-1">使用SWC处理 <a class="header-anchor" href="#使用swc处理" aria-label="Permalink to “使用SWC处理”">&#8203;</a></h2>
<blockquote>
<p><a href="https://swc.rs/" target="_blank" rel="noreferrer">SWC</a> 是一个可以用于替换babel的工具，基于Rust实现，在单线程上比 Babel 快20倍。</p>
</blockquote>
<p>前面主要阐述了html中js代码的提取，这个部分就简单阐述一下使用<code>SWC</code>对js部分代码进行<code>ES语法降级</code>与<code>压缩</code>。</p>
<p>直接利用<a href="https://swc.rs/docs/usage/core#transformfilesync" target="_blank" rel="noreferrer">transformSync</a>方法对代码进行语法降级</p>
<ul>
<li><a href="https://swc.rs/docs/configuration/compilation#jscexternalhelpers" target="_blank" rel="noreferrer">jsc</a>：js代码编译相关配置</li>
<li><a href="https://swc.rs/docs/configuration/minification" target="_blank" rel="noreferrer">minify</a>：是否压缩</li>
</ul>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::wuvng2u0g0b7zmc0h829m9::--><code>import { transformSync } from &#039;@swc/core&#039;
import type { JscTarget } from &#039;@swc/core&#039;

export function transformCode(
  code: string,
  target: JscTarget = &#039;es5&#039;,
  minify = false
) {
  return transformSync(code, {
    jsc: {
      target
    },
    minify
  }).code
}</code></pre>
</div><p><a href="https://swc.rs/docs/usage/core#minify" target="_blank" rel="noreferrer">minifySync</a>直接对代码进行压缩处理。</p>
<ul>
<li><a href="https://swc.rs/docs/configuration/minification#jscminifycompress" target="_blank" rel="noreferrer">compress参数</a>：可用于更细粒度的控制压缩策略</li>
<li><a href="https://swc.rs/docs/configuration/minification#jscminifymangle" target="_blank" rel="noreferrer">mangle参数</a>：细粒度的控制代码混淆策略</li>
</ul>
<p>由于在HTML中的JS 代码可能会被后续的<code>script</code>所引用。所以关掉混淆策略，避免影响代码正常工作</p>
<p><strong>例如</strong></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::m5n2e6xz0rskl762p56wwa::--><code>const hello = &#039;hello&#039;
// 开启混淆后结果是
var l=&quot;hello&quot;;</code></pre>
</div><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::fsn5wh1hwkbqj5618h5ib::--><code>import { minifySync } from &#039;@swc/core&#039;
import type { JsMinifyOptions } from &#039;@swc/core&#039;

export function minifyCode(code: string, ops?: JsMinifyOptions) {
  return minifySync(code, {
    compress: false,
    mangle: false,
    ...ops
  }).code
}</code></pre>
</div><p>其它压缩相关的细节参数这里就不展开介绍了,可以看结合文档介绍和官方的<a href="https://swc.rs/playground" target="_blank" rel="noreferrer">playground</a>进行实践验证</p>
<h2 id="posthtml插件封装" tabindex="-1">posthtml插件封装 <a class="header-anchor" href="#posthtml插件封装" aria-label="Permalink to “posthtml插件封装”">&#8203;</a></h2>
<p>这里就封装2个<code>posthtmlSWCMinify</code>和<code>posthtmlSWCTransform</code>2个方法，用于压缩和转换两个场景</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::7e47l1vycfjgsysp2d03hr::--><code>export function posthtmlSWCTransform(
  target: JscTarget = &#039;es5&#039;,
  minify = false
) {
  return (tree: Node) =&gt; {
    tree.match({ tag: &#039;script&#039; }, (node) =&gt; {
      if (node?.content?.[0]) {
        node.content[0] = transformCode(
          node.content[0].toString(),
          target,
          minify
        )
      }
      return node
    })
  }
}

export function posthtmlSWCMinify(ops?: JsMinifyOptions) {
  return (tree: Node) =&gt; {
    tree.match({ tag: &#039;script&#039; }, (node) =&gt; {
      if (node?.content?.[0]) {
        node.content[0] = minifyCode(node.content[0].toString(), ops)
      }
      return node
    })
  }
}</code></pre>
</div><p>使用示例如下</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::o96hqmn6v9b277fqt1x3e0i::--><code>import posthtml from &#039;posthtml&#039;

posthtml()
      .use(posthtmlSWCTransform())
      .process(htmlCode, { sync: true })

posthtml()
      .use(posthtmlSWCMinify())
      .process(htmlCode, { sync: true })</code></pre>
</div><p>至此对<code>HTML</code>中inlineJS的提取与使用<code>SWC</code>处理的方法进行了较为详细的阐述，下面就是通过CLI组合能力，然后对外提供使用。</p>
<h2 id="cli封装" tabindex="-1">CLI封装 <a class="header-anchor" href="#cli封装" aria-label="Permalink to “CLI封装”">&#8203;</a></h2>
<p>通过封装一个简单的CLI工具，直接对目标HTML进行转换，调用起来更加的便捷，也方便的在现有工程中集成。</p>
<h3 id="参数定义" tabindex="-1">参数定义 <a class="header-anchor" href="#参数定义" aria-label="Permalink to “参数定义”">&#8203;</a></h3>
<p>使用<code>commander</code>做参数解析，先定义一下指令和传参，就2个指令<code>transform</code>和<code>minify</code>，只包含上述方法的基本的传入参数</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::u6nd2sdg7rqoc23ulz1iso::--><code>#!/usr/bin/env node

import { Command } from &#039;commander&#039;
import pkg from &#039;../package.json&#039;
import { minifyCommand, transformCommand } from &#039;./command&#039;

const program = new Command()
program.version(pkg.version)

program
  .command(&#039;transform [paths...]&#039;)
  .description(&#039;transform inlineJS code ESVersion by SWC&#039;)
  .alias(&#039;t&#039;)
  .option(
    &#039;-e, --ecmaVersion [ecmaVersion]&#039;,
    &#039;set transform jsc target version&#039;,
    &#039;es5&#039;
  )
  .option(&#039;-m, --minify&#039;, &#039;minify transform result&#039;)
  .action(transformCommand)

program
  .command(&#039;minify [paths...]&#039;)
  .description(&#039;minify inlineJS code by SWC&#039;)
  .alias(&#039;m&#039;)
  .action(minifyCommand)

program.parse(process.argv)</code></pre>
</div><p><img src="./html-inline-js-transform/MTY2NjUzOTE5NjI2Ng==666539196266.png" alt="图片" loading="lazy"></p>
<h3 id="指令实现" tabindex="-1">指令实现 <a class="header-anchor" href="#指令实现" aria-label="Permalink to “指令实现”">&#8203;</a></h3>
<p>下面是 <code>transformCommand</code> 的简单实现</p>
<ul>
<li>使用<code>fs</code>模块读写文件内容</li>
<li>直接通过<code>posthtml</code>调用前面实现的<code>posthtmlSWCTransform</code>插件对内容进行转换</li>
</ul>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::2yqgaxqan16j1kccxyaiwp::--><code>// transformCommand
import fs from &#039;fs&#039;
import type { JscTarget } from &#039;@swc/core&#039;
import posthtml from &#039;posthtml&#039;
import { posthtmlSWCTransform } from &#039;../index&#039;

interface Options {
  ecmaVersion?: JscTarget
  minify?: boolean
}

export default function transformCommand(filesArg: string[], options: Options) {
  for (const filepath of filesArg) {
    const content = fs.readFileSync(filepath, &#039;utf-8&#039;)
    const result = posthtml()
      .use(posthtmlSWCTransform(options.ecmaVersion || &#039;es5&#039;, !!options.minify))
      .process(content, { sync: true }).html
    fs.writeFileSync(filepath, result, &#039;utf-8&#039;)
  }
}</code></pre>
</div><p><code>minifyCommand</code>的实现是类似的这里就不再赘述。</p>
<h3 id="效果" tabindex="-1">效果 <a class="header-anchor" href="#效果" aria-label="Permalink to “效果”">&#8203;</a></h3>
<blockquote>
<p>安装 npm i -g @sugarat/inlinejs-transform</p>
</blockquote>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::891xjklb8ttabb1c9a4cpm::--><code>ijs minify __test__/test.html</code></pre>
</div><p><img src="./html-inline-js-transform/MTY2NjU0MTExNzIyMw==666541117223.png" alt="图片" loading="lazy"></p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::nvdhqqymctsju2sh10pb8f::--><code>ijs transform __test__/test.html --minify</code></pre>
</div><p><img src="./html-inline-js-transform/MTY2NjU0MTE5Mjk3NQ==666541192975.png" alt="图片" loading="lazy"></p>
<h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>文章中涉及示例代码以及工具完整源码见 <a href="https://github.com/ATQQ/tools/tree/main/packages/cli/inlinejs-transform" target="_blank" rel="noreferrer">GitHub</a></p>
<p>如内容有误还请评论区斧正，读者有其它💡想法可评论&amp;私信交流探讨。</p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/html-inline-js-transform/MTY2NjQzNTk5MjcyMg==666435992722.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[NodeCLI工具原理解析]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/node-cli.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/node-cli.html</guid>
            <pubDate>Mon, 17 Oct 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[本文将主要介绍`CLI相关周边知识`，通过本文读者可以了解到`CLI的基本工作原理`，`注册全局指令`的几种方式、`Node CLI的基本工作原理`。
 前言
&gt;CLI(Command-Line]]></description>
            <content:encoded><![CDATA[<h1 id="node-cli工具原理解析" tabindex="-1">Node CLI工具原理解析 <a class="header-anchor" href="#node-cli工具原理解析" aria-label="Permalink to “Node CLI工具原理解析”">&#8203;</a></h1>
<blockquote>
<p>本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！</p>
</blockquote>
<p>本文将主要介绍<code>CLI相关周边知识</code>，通过本文读者可以了解到<code>CLI的基本工作原理</code>，<code>注册全局指令</code>的几种方式、<code>Node CLI的基本工作原理</code>。</p>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<blockquote>
<p>CLI(Command-Line Interface) 命令行界面</p>
</blockquote>
<p>搞开发的同学，或多或少的都会接触到许多的命令行工具。</p>
<p>有生产力工具，也有有意思的小玩意、自动化任务处理等等。</p>
<p>命令行工具的安装方式就很多了。</p>
<p><code>win</code>上大部分是通过软件安装包安装，安装同时会通过<code>环境变量</code>配置相关指令。</p>
<p><code>linux</code>和<code>mac</code>上就比较丰富了，前者常用<code>yum</code>和<code>api-get</code>、mac 上就<code>brew</code>。</p>
<p>也有使用<code>wget</code>和<code>curl</code>拉取相关工具的<code>shell</code>脚本执行安装。</p>
<p>说了这么多工具，都不是本文要讲的工具，前端搬砖当然首选<code>node</code>，然后基于<code>npm</code>做包的分发。</p>
<p><em>PS：文中的示例都以<code>mac</code>为主</em></p>
<h2 id="可执行shell" tabindex="-1">可执行shell <a class="header-anchor" href="#可执行shell" aria-label="Permalink to “可执行shell”">&#8203;</a></h2>
<p><code>unix</code>系上大部分可执行文件都是基于<code>shell</code>的脚本。</p>
<p>比如随手写个<code>hello world</code></p>
<p>文件名<code>hello</code>,内容如下</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::irnv5u0jsonmoy3abm9lf::--><code>echo &quot;Hello world&quot;</code></pre>
</div><p><img src="./node-cli/MTY2NTkwNjg1MjMwNQ==665906852305.png" alt="图片" loading="lazy"></p>
<p>此时我们直接执行是会提醒没有执行权限，我们为当前用户加1个可执行权限</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::fe95mk2cigqiv8gwyah8f::--><code>chmod u+x hello</code></pre>
</div><p>然后再当前目录执行，就看到输出结果了</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::85mzzf0me923mddap4dfnb::--><code>./hello</code></pre>
</div><p><img src="./node-cli/MTY2NTkwNzgzMTQ1OA==665907831458.png" alt="图片" loading="lazy"></p>
<h2 id="注册全局指令" tabindex="-1">注册全局指令 <a class="header-anchor" href="#注册全局指令" aria-label="Permalink to “注册全局指令”">&#8203;</a></h2>
<p>为了使“指令”在全局任意位置都能被使用，就需要做相关操作了。</p>
<h3 id="环境变量" tabindex="-1">环境变量 <a class="header-anchor" href="#环境变量" aria-label="Permalink to “环境变量”">&#8203;</a></h3>
<p>相信大多数首次接触这个词的朋友都在<code>win</code>上深有体会。装<code>JDK</code>、<code>MySQL</code>时都避免不了有配置的操作。</p>
<p>如果想在其它目录直接执行<code>hello</code>就生效呢？那这就离不开环境变量配置了</p>
<p>咱们先看终端用的<code>shell</code>工具是什么。</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::u50bzaydgerl8qqprcm1ha::--><code>echo $0</code></pre>
</div><p>我这里使用的是<code>zsh</code>,其它的常见的还有<code>bash</code></p>
<p><img src="./node-cli/MTY2NTkwODA4MDA1NA==665908080054.png" alt="图片" loading="lazy"></p>
<p>相应的配置文件分别是<code>.zshrc</code>和<code>.bashrc</code></p>
<p><img src="./node-cli/MTY2NTkwODIzNDg1Mw==665908234853.png" alt="图片" loading="lazy"></p>
<h3 id="alias指令" tabindex="-1">alias指令 <a class="header-anchor" href="#alias指令" aria-label="Permalink to “alias指令”">&#8203;</a></h3>
<p><strong>使用 alias指令设置别名</strong></p>
<p>指令格式</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::0e9wioq4wdmbas0jxfeqcm::--><code>alias &lt;别名&gt;=&lt;指令或可执行文件路径&gt;</code></pre>
</div><p>添加内容如下</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::a31k353crde67eymb2gkzt::--><code>alias hello=/Users/sugar/Documents/diy-cli/hello</code></pre>
</div><p>立即生效配置</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::ml3a2rs2aapcf7xk8k8e::--><code>source ~/.zshrc</code></pre>
</div><h3 id="export指令" tabindex="-1">export指令 <a class="header-anchor" href="#export指令" aria-label="Permalink to “export指令”">&#8203;</a></h3>
<p><strong>使用export命令添加添加相关目录</strong></p>
<p>指令格式</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::2crnwlj6yz9sb5d8i9tp59::--><code>export PATH=$PATH:&lt;路径 1&gt;:&lt;路径 2&gt;:&lt;路径 N&gt;</code></pre>
</div><p>添加内容如下</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::wveoux0vythpzetz8cnbk::--><code>export PATH=$PATH:/Users/sugar/Documents/diy-cli</code></pre>
</div><p>以上2种方案都能达到目标的效果</p>
<p><img src="./node-cli/MTY2NTkwOTgzNDM0NQ==665909834345.png" alt="图片" loading="lazy"></p>
<p>如果每个工具都单独配一条规则。那会导致相关配置文件非常的庞大，也不方便维护。</p>
<p>实际上我们在用<code>npm i -g</code>安装的全局包的时候，并没有手动配置。那么这个是如何做到的呢。这个就离不开下面将要说到的<code>符号链接</code>了</p>
<h2 id="符号链接" tabindex="-1">符号链接 <a class="header-anchor" href="#符号链接" aria-label="Permalink to “符号链接”">&#8203;</a></h2>
<blockquote>
<p><code>软链接</code>类似于快捷方式，它可以指向任意文件系统中的一个文件或目录；硬链接也可以看作是文件或目录的快捷方式，但源文件删除了也不影响<code>硬链接</code>。</p>
</blockquote>
<p>先通过<code>which npm</code>看一下npm所在位置</p>
<p>打印一下<code>$PATH</code>的值，可以看到<code>npm</code>指令对应文件所在目录就在其中</p>
<p><img src="./node-cli/MTY2NTkxOTUwNzgzMQ==665919507831.png" alt="图片" loading="lazy"></p>
<p>展开目录内容可以看到文件类型都是<code>l（软连接）</code></p>
<p><img src="./node-cli/MTY2NTkxOTgwODA1OQ==665919808059.png" alt="图片" loading="lazy"></p>
<p>因此咱们可以小结出来 <strong>通过向已添加到$PATH变量中的目录，直接创建短链可以实现指令的自动注册全局</strong></p>
<p>下面实践演示一下</p>
<h3 id="ln指令" tabindex="-1">ln指令 <a class="header-anchor" href="#ln指令" aria-label="Permalink to “ln指令”">&#8203;</a></h3>
<p><strong>指令格式</strong></p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::8zanwhrobvqei683snie3o::--><code># 硬链接
ln source target
# 软连接
ln -s source target</code></pre>
</div><p>接着上面之前的例子，再使用<code>export</code>完成对目录的添加后。咱们再随便建立个文件<code>hello2.sh</code>进行操作</p>
<p>内容如下</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::fkl92mv8cuewtjthcb1a::--><code>echo &quot;Hello world2&quot;</code></pre>
</div><p>创建一个软链</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::r4v2ril3vh88yuuqvtw5tn::--><code>ln -s &lt;source&gt;/hello.sh &lt;target&gt;/hello2</code></pre>
</div><p>操作结果如下</p>
<p><img src="./node-cli/MTY2NTkyMDk5MDQ3NA==665920990474.png" alt="图片" loading="lazy"></p>
<p>前面代码都是简单的写的<code>shell</code>脚本</p>
<p>前端当然是羧<code>js</code>，咱们把代码改成js。</p>
<p><code>hello.js</code></p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::1erfsik1vephwhiq0mu04::--><code>console.log(&#039;hello js&#039;)</code></pre>
</div><p>按照前面的步骤，完成可执行权限添加和软链的创建。</p>
<p><img src="./node-cli/MTY2NTkyMTQzOTg0Ng==665921439846.png" alt="图片" loading="lazy"></p>
<p>结果可以预测是会报错的，默认会被当做<code>shell</code>脚本进行执行。</p>
<p>那么如何指定为使用<code>node</code>去执行这个文件？</p>
<p>这就是我们下文要说到的<code>hashbang</code></p>
<h2 id="hashbang" tabindex="-1">Hashbang <a class="header-anchor" href="#hashbang" aria-label="Permalink to “Hashbang”">&#8203;</a></h2>
<blockquote>
<p><code>Hashbang</code>（也称为<code>Shebang</code>）是一个由井号和叹号构成的字符序列 #!，通常出现在文件开头，例如 <code>#!/usr/bin/env bash</code></p>
</blockquote>
<p>用于指定脚本的运行环境</p>
<p>于是，我们给前面的<code>hello.js</code>头部加上<code>#!/usr/bin/env node</code> 再次运行就成了</p>
<p><img src="./node-cli/MTY2NTk3NjM5NTkyNQ==665976395925.png" alt="图片" loading="lazy"></p>
<p>至此基本清楚了，如何将1个<code>js</code>脚本便捷的注册为1个全局可执行指令</p>
<h2 id="node-cli" tabindex="-1">Node CLI <a class="header-anchor" href="#node-cli" aria-label="Permalink to “Node CLI”">&#8203;</a></h2>
<p><code>node</code>官配包管理工具<code>npm</code>，通常每个项目中有一个<code>package.json</code>文件，用于描述项目的一些信息或者包含项目相关的配置内容</p>
<h3 id="指令注册" tabindex="-1">指令注册 <a class="header-anchor" href="#指令注册" aria-label="Permalink to “指令注册”">&#8203;</a></h3>
<p>其中<code>bin</code>属性用于设置<code>指令名称</code>和<code>执行脚本所在位置</code></p>
<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre><!--::markdown-it-async::tyrwsv4k1mlnofsfocwc5l::--><code>{
    &quot;name&quot;:&quot;pkgName&quot;,
    &quot;bin&quot;: {
        &quot;command&quot;: &quot;exec/filepath.js&quot;
    }
}</code></pre>
</div><p>使用<code>npm install</code>安装依赖，会根据<code>bin</code>中的描述，创建1个<code>command</code>到<code>exec/filepath.js</code>的软链</p>
<p>软链所在目录区别于是否是<code>global</code>安装</p>
<p>这个目录可以通过<code>npm bin</code>指令查看</p>
<p><img src="./node-cli/MTY2NTk3NzgzMzUyOQ==665977833529.png" alt="图片" loading="lazy"></p>
<p>全局路径和前面使用 <code>which npm</code>获取的一致，当前项目的路径即在<code>node_modules/.bin</code>中</p>
<p>如果是本地开发CLI时，可以使用<code>npm link</code>指令根据<code>bin</code>描述信息，自动创建软链到<code>npm bin</code>所示的目录中，通过<code>-g</code>参数区别是否是全局</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::qqgg7bhn8mqlhhyk1kz47f::--><code># 项目工作目录下执行
npm link
# or
npm link -g</code></pre>
</div><h3 id="命令行参数" tabindex="-1">命令行参数 <a class="header-anchor" href="#命令行参数" aria-label="Permalink to “命令行参数”">&#8203;</a></h3>
<p>前面主要都在围绕命令展开介绍。要实现工具的丰富功能离不开参数的组合，本小节就介绍下<code>Node</code>里如何处理<code>Command</code>与<code>Options</code>。</p>
<p>我们可以通过<code>process.argv</code>方法获取到运行时的 命令行入参</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::l98o42ukmkxv6aaurx0re::--><code>console.log(process.argv);</code></pre>
</div><p><img src="./node-cli/MTY2NjAxMzEwMTkzNQ==666013101935.png" alt="图片" loading="lazy"></p>
<p>各位置参数释义</p>
<ul>
<li><code>0</code>：Node可执行文件所在路径</li>
<li><code>1</code>：执行的js脚本路径</li>
<li><code>&gt;1</code>：用户运行时传入的参数</li>
</ul>
<p>通过这些参数，就能区分出用户要执行的行为</p>
<p>当然在实际开发中大部分场景下，都会使用第三方库去解析<code>命令行参数</code>，来降低代码的复杂度，提高可读性。</p>
<p>下面是一个使用<code>commander</code>的例子</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::yz9506bgk9ydijeizugkd::--><code>#!/usr/bin/env node

const { Command } = require(&#039;commander&#039;)
const pkg = require(&#039;./package.json&#039;)

const program = new Command()
program.version(pkg.version)

program
    .command(&#039;hello [paths...]&#039;)
    .description(&#039;hello world demo&#039;)
    .alias(&#039;h&#039;)
    .option(&#039;-p, --pkg &lt;path&gt;&#039;, &#039;set package.json path&#039;)
    .action((paths, options) =&gt; {
        console.log(&#039;😄😄😄&#039;);
        console.log(paths);
        console.log(options);
    })

program.parse(process.argv)</code></pre>
</div><p><img src="./node-cli/MTY2NjAxNDgwMjQ1MQ==666014802451.png" alt="图片" loading="lazy"></p>
<p>可以看到使用第三方库辅助处理<code>参数</code>，已经非常完善了</p>
<p>除了老牌的<a href="https://www.npmjs.com/package/commander" target="_blank" rel="noreferrer">commander</a>之外还有其它的相同作用的库，这里就不展开介绍了。</p>
<h3 id="彩色打印" tabindex="-1">彩色打印 <a class="header-anchor" href="#彩色打印" aria-label="Permalink to “彩色打印”">&#8203;</a></h3>
<p>这个大家都不陌生了，大部分CLI打印结果都是<code>五颜六色</code>的</p>
<p>比如下面的例子</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::bhamljg0tfvc1ypbpl87a8::--><code>echo &#039;[36mhello  world[39m&#039;</code></pre>
</div><p><img src="./node-cli/MTY2NjAxNjQ3NTM3OA==666016475378.png" alt="图片" loading="lazy"></p>
<p>相关知识点是<code>ANSI Escape code</code>，这里就不展开说明了。</p>
<p>实际开发中，也很少直接写这种原始的数值。通常会使用<a href="https://www.npmjs.com/package/chalk" target="_blank" rel="noreferrer">chalk</a>这个库辅助，比如上面这个颜色对应代码如下。</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::mhpu3xfj7vn57v0x5xwrs::--><code>const Chalk = require(&#039;chalk&#039;);

console.log(Chalk.cyan(&#039;hello world&#039;));</code></pre>
</div><p>渐变色打印就常用<a href="https://www.npmjs.com/package/gradient-string" target="_blank" rel="noreferrer">gradient-string</a>这个库</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::0dmsdfborrva4h5mpmzc8us::--><code>const gradient = require(&#039;gradient-string&#039;);

console.log(gradient(&#039;cyan&#039;, &#039;pink&#039;)(&#039;Hello world!&#039;));</code></pre>
</div><p><img src="./node-cli/MTY2NjAxNzA5NTYwOQ==666017095609.png" alt="图片" loading="lazy"></p>
<p>简单两行代码效果就出来了</p>
<h3 id="终端交互" tabindex="-1">终端交互 <a class="header-anchor" href="#终端交互" aria-label="Permalink to “终端交互”">&#8203;</a></h3>
<p>在使用 例如<code>Vue CLI</code> 此类工具进行项目初始化的时候，会有<code>输入</code>，<code>单选</code>，<code>多选</code>等交互操作。</p>
<p><em>相关原理涉及内容太“抽象”，篇幅较大，后续通俗精简了再做分享</em></p>
<p>常用的第三方库就是<a href="https://www.npmjs.com/package/inquirer" target="_blank" rel="noreferrer">inquirer</a>这个库</p>
<p>下面是简单<code>checkbox</code>示例</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::dsz0c6ddtlkvlquzybe1v::--><code>const inquirer = require(&#039;inquirer&#039;);

inquirer
    .prompt([
        {
            type: &#039;checkbox&#039;,
            message: &#039;水果选择&#039;,
            name: &#039;fruits&#039;,
            choices: [
                {
                    name: &#039;🍌&#039;,
                },
                {
                    name: &#039;🍉&#039;,
                },
                {
                    name: &#039;🍇&#039;,
                },
            ]
        },
    ])
    .then((answers) =&gt; {
        console.log(answers);
    });</code></pre>
</div><p><img src="./node-cli/MTY2NjAyMDU3NDQzOQ==666020574439.png" alt="图片" loading="lazy"></p>
<h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>本文没有阐述非常深奥的知识点，只涉及日常的一些<code>基操</code>，有助于读者了解Node CLI 背后的工作原理。</p>
<p>如内容有不妥之处，可以评论区交流；有感兴趣希望深入了解的知识点也可评论区@。</p>
<p>完整示例代码移步=&gt;<a href="https://github.com/ATQQ/tools/tree/main/packages/demos/diy-cli" target="_blank" rel="noreferrer">Github</a></p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/node-cli/MTY2NTkwNjg1MjMwNQ==665906852305.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[Mac上抓包秒通关羊了个羊]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/yanglegeyang.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/yanglegeyang.html</guid>
            <pubDate>Mon, 19 Sep 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[最近这游戏是火得不行，睡前玩几把，几天了从未通过。那只能上科技了。。。
 前言
看网上大部分是 Windows 微信小游戏的抓包教程通关文章，因为Mac微信不支持小游戏（尴尬了。）
对于真机抓包的话，]]></description>
            <content:encoded><![CDATA[<h1 id="mac上抓包秒通关羊了个羊" tabindex="-1">Mac上抓包秒通关羊了个羊 <a class="header-anchor" href="#mac上抓包秒通关羊了个羊" aria-label="Permalink to “Mac上抓包秒通关羊了个羊”">&#8203;</a></h1>
<p>最近这游戏是火得不行，睡前玩几把，几天了从未通过。那只能上科技了。。。</p>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>看网上<strong>大部分是 Windows 微信小游戏</strong>的抓包教程通关文章，因为Mac微信不支持小游戏（尴尬了。）</p>
<p>对于真机抓包的话，高版本Android配置CA太麻烦（Root），相信 大部分都是10左右的安卓</p>
<p>手里只有台Mac，那咱就直接用 Mac 配安卓模拟器搞定抓包（<code>Whistle</code> + <code>MuMu</code>）</p>
<p>PS：文中有最终演示视频</p>
<h2 id="工具介绍-使用" tabindex="-1">工具介绍&amp;使用 <a class="header-anchor" href="#工具介绍-使用" aria-label="Permalink to “工具介绍&amp;使用”">&#8203;</a></h2>
<h3 id="whistle" tabindex="-1">Whistle <a class="header-anchor" href="#whistle" aria-label="Permalink to “Whistle”">&#8203;</a></h3>
<p><a href="https://github.com/avwo/whistle" target="_blank" rel="noreferrer">whistle</a>，是基于 Node 实现的跨平台抓包调试工具</p>
<p>对咱前端同学比较友好，安装配置都很简单</p>
<p>安装</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::dbnvic2ur1ln5fh2h915hb::--><code>npm i -g whistle</code></pre>
</div><p>启动</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::b6o0bxo576ozc5yz20jc9::--><code>w2 start</code></pre>
</div><p>访问 <code>http://localhost:8899/#network</code> 即可看到</p>
<p><img src="./yanglegeyang/MTY2MzU2NjE2NzMwMg==663566167302.png" alt="图片" loading="lazy"></p>
<p>然后就是配置CA证书，参照<a href="http://wproxy.org/whistle/webui/https.html" target="_blank" rel="noreferrer">官方文档: Mac安装根证书</a>，这里不再赘述（CV），只有几个步骤1分钟就能完成配置。</p>
<p>获取一下ip，后面会用到</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::6ljixy0gtxhidzawjsu54k::--><code>172.30.43.170</code></pre>
</div><p><img src="./yanglegeyang/MTY2MzU2NjIyNjg3MQ==663566226871.png" alt="图片" loading="lazy"></p>
<h3 id="mumu" tabindex="-1">MuMu <a class="header-anchor" href="#mumu" aria-label="Permalink to “MuMu”">&#8203;</a></h3>
<p><a href="https://mumu.163.com/mac/index.html" target="_blank" rel="noreferrer">MuMu模拟器</a> 网易出品的安卓模拟器（Android6），在Mac上运行稳定，用来娱乐或者开发调试都还是比较方便</p>
<p>安装就是官网下载，一顿下一步就行，下面介绍模拟器中的配置（当然大家装完后把微信安装并登录上）</p>
<p><img src="./yanglegeyang/MTY2MzU2NjQ3NjE0NA==663566476144.png" alt="图片" loading="lazy"></p>
<p>登录微信后，咱就开始配置CA证书</p>
<p>先配置模拟器网络，添加代理，IP就是咱们前面获取的本机ip</p>
<p>长按Wifi名  =&gt; 修改网络 =&gt; 代理（手动）</p>
<p>输入本机ip，端口<code>8899</code>，whistle使用</p>
<p><img src="./yanglegeyang/MTY2MzU2NjY4ODc0Ng==663566688746.png" alt="图片" loading="lazy"></p>
<p><img src="./yanglegeyang/MTY2MzU2NjU0MzE4OQ==663566543189.png" alt="图片" loading="lazy"></p>
<p>使用浏览器访问 <code>rootca.pro</code> 安装CA证书</p>
<p><img src="./yanglegeyang/MTY2MzU4NjA4MjIzNQ==663586082235.png" alt="图片" loading="lazy"></p>
<p>配置完毕，不出意外的话，咱们打开羊了个羊就看见网络请求了</p>
<p><img src="./yanglegeyang/MTY2MzU2NzAxMDc0MQ==663567010741.png" alt="图片" loading="lazy"></p>
<h2 id="方案1-修改关卡数据" tabindex="-1">方案1：修改关卡数据 <a class="header-anchor" href="#方案1-修改关卡数据" aria-label="Permalink to “方案1：修改关卡数据”">&#8203;</a></h2>
<p>咱把第二关的数据改成第一关，享受游戏的乐趣</p>
<p>点击加入羊群（开始游戏），可以看到两个接口  /maps/xxxx.txt</p>
<p>”PS:如果看到的是一个就操作删除羊了个羊小程序，重新打开“</p>
<p>返回的就是游戏地图数据</p>
<p><img src="./yanglegeyang/MTY2MzU2ODA2MDg4MQ==663568060881.png" alt="图片" loading="lazy"></p>
<p>好家伙：第二关比第一关的数据多了不是点吧点</p>
<p>下面开始一顿操作修改关卡数据</p>
<ol>
<li>复制第一关的数据，添加到whistle Values 面板</li>
</ol>
<p><img src="./yanglegeyang/MTY2MzU2OTM2OTcyNw==663569369727.png" alt="图片" loading="lazy"></p>
<ol start="2">
<li>添加转发规则，在whistle Rules 面板操作</li>
</ol>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::zvvm8n1fx97pm6uwoosji::--><code>^cat-match-static.easygame2021.com/maps/***.txt$ resBody://{羊1}</code></pre>
</div><p><img src="./yanglegeyang/MTY2MzU2OTk5OTIxNQ==663569999215.png" alt="图片" loading="lazy"></p>
<ol start="3">
<li>删除小游戏重新进入</li>
</ol>
<p>”羊了个羊“会使用已经拉取的关卡数据，不会重复请求，所以需要删除，重新进入</p>
<p>再次打开即可看见，2关都是用的咱们修改后的数据</p>
<p><img src="./yanglegeyang/MTY2MzU2OTczNTA0Mg==663569735042.png" alt="图片" loading="lazy"></p>
<p>下面是演示录屏
<video controls style="width:100%;" src="./yanglegeyang/MTY2MzU4MTkxODU3Mw==羊了个羊.mp4?s1=https%3A//img.cdn.sugarat.top/mdImg/MTY2MzU4MTkxODU3Mw%3D%3D%E7%BE%8A%E4%BA%86%E4%B8%AA%E7%BE%8A.mp4"></video></p>
<h2 id="方案2-直接调用成功接口" tabindex="-1">方案2：直接调用成功接口 <a class="header-anchor" href="#方案2-直接调用成功接口" aria-label="Permalink to “方案2：直接调用成功接口”">&#8203;</a></h2>
<ul>
<li><s>接口1：<code>https://cat-match.easygame2021.com/sheep/v1/game/game_over?rank_score=1&amp;rank_state=1&amp;rank_time=40&amp;rank_role=1&amp;skin=1</code></s> 过了一天换接口了</li>
<li>接口2：POST <a href="https://cat-match.easygame2021.com/sheep/v1/game/game_over_ex" target="_blank" rel="noreferrer">https://cat-match.easygame2021.com/sheep/v1/game/game_over_ex</a></li>
<li>鉴权：request header 上的 t 参数，扒拉下来就能用
<img src="./yanglegeyang/MTY2MzU2NzI2NzkzNA==663567267934.png" alt="图片" loading="lazy"></li>
</ul>
<p><img src="./yanglegeyang/MTY2MzU4MjE5MjQwNw==663582192407.png" alt="图片" loading="lazy"></p>
<p>使用 whistle 直接发起请求</p>
<p>选择目标请求
<img src="./yanglegeyang/MTY2MzU4MjM5Nzk2OQ==663582397969.png" alt="图片" loading="lazy"></p>
<p>修改参数，点击右上角小飞机发起请求</p>
<p><img src="./yanglegeyang/MTY2MzU4NjIyMjcyNQ==663586222725.png" alt="图片" loading="lazy"></p>
<h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>Whistle 这个工具真的很好用，再次安利一下</p>
<p>如果上述方法有问题，欢迎评论区交流</p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/yanglegeyang/MTY2MzU2NjE2NzMwMg==663566167302.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[ESCheck工具原理解析及增强实现]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/escheck.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/escheck.html</guid>
            <pubDate>Mon, 19 Sep 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[# ESCheck工具原理解析及增强实现
> 本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！
## 前言

2022了，大家做的面向C端的产品（Web，小程序，其它跨端方案），涉及JS产物的还是避不开兼容性的话题（即使IE已官宣停止支持）

但就目前看来这个停止维护还是避免不了大家做开发还是要考虑兼容低端机，甚至`IE11`

针对js目前通常的手段都是通过工具对js进行语法降级至 ES5，同时引入对应的 polyfill（垫片）

工具首选还是老牌 [Babel](https://babeljs.io/)，当然现在还有 [SWC](https://swc.rs/) 这个冉冉升起的新星

经过一顿操作为项目配置 Babel 之后，为了保证产物不出现 ES5 之外的语法，通常都会搭配一个 Check 工具去检测产物是否符合要求

本文将阐述市面上已有工具的`实现原理`，`功能对比`，最后`实现增强型的es-check`，提供 CLI 和 Lib 两种使用方式

下面先分别介绍一下社区版的[es-check](https://github.com/yowainwright/es-check)和滴滴版的[@mpxjs/es-check](https://github.com/mpx-ecology/mpx-es-check)实现原理，最后再实现一个集大成者

## es-check
先看一下其效果，下面是用于测试的代码
```js
// test.js
var str = 'hello'
var str2 = 'world'

const varConst = 'const'
let varLet = 'let'
const arrFun = () => {
    console.log('hello world');
}
```
```sh
npx es-check es5 testProject/**/*.js
```
![图片](./escheck/MTY2NDAyODU1NTI3OA==664028555278.png)

可以看到其报错信息比较简单，只输出了代码中的第一个ES语法问题`const`,然后对应的是行数和具体文件路径

我们再把这个测试文件`构建压缩混淆一下`(模拟build产物)

```sh
npx tsup __test__/testProject/js/index.js --sourcemap -d __test__/testProject/dist --minify
```
通过结果，可以看到，只说有解析问题，并未告知是什么问题，然后有对应的行列数

![图片](./escheck/MTY2NDAyOTcwMjg4Ng==664029702886.png)

如果有`sourcemap`那么我们暂且是可以通过[source-map](https://www.npmjs.com/package/source-map)这个库解析一下，以上面的报错为例
```ts
// npx esno source-map.ts
import sourceMap from 'source-map'
import fs from 'fs'
import path from 'path'

const file = path.join(__dirname, 'testProject/dist/index.js.map')
const lineNumber = 1
const columnNumber = 45

;(async () => {
  const consumer = await new sourceMap.SourceMapConsumer(
    fs.readFileSync(file, 'utf-8')
  )
  const sm = consumer.originalPositionFor({
    column: columnNumber,
    line: lineNumber
  })
  // 对应文件的源码
  const content = consumer.sourceContentFor(sm.source!)
  // 错误行的代码
  const errCode = content?.split(/\r?\n/g)[sm.line! - 1]
  console.log(errCode)
})()
```
执行结果如下，可以得到对应的错误代码

![图片](./escheck/MTY2NDAzMjI5MTA1Mw==664032291053.png)

### 原理分析
打开[源码](https://github.com/yowainwright/es-check/blob/master/index.js)可以看到实现非常简单，关键不过100行。可以总结为3步骤

1. 使用 [fast-glob](https://www.npmjs.com/package/fast-glob) 获取目标文件
2. 使用 [acorn](https://github.com/acornjs/acorn/tree/master/acorn) 解析源码生层AST，并捕获解析错误
3. 判断是否存在解析错误，有就打印

`acorn` 是一个很常见的 js 解析库，可以用于AST的生成与CRUD操作，其包含1个 `ecmaVersion` 参数用于指定要解析的 `ECMAScript` 版本。`es-check`正是利用了这个特性

```ts
import * as acorn from 'acorn'

try {
  acorn.parse(`const a = 'hello'`, {
    ecmaVersion: 5,
    silent: true
    // sourceType: 'module'
    // allowHashBang:true
  })
} catch (err) {
  // The keyword 'const' is reserved (1:0)
  console.log(err)
  // err 除了继承常规 Error 对象，包含 stack 和 message 等内容外，还包含如下信息
  // {
  //   pos: 0,
  //   loc: Position { line: 1, column: 0 },
  //   raisedAt: 7
  // }
}
```

下面是`es-check`的精简实现，完整源码见 [Github](https://github.com/ATQQ/tools/blob/feature/es-check/packages/cli/es-check/__test__/es-check.ts)

```ts
// npx esno es-check.ts
import fg from 'fast-glob'
import path from 'path'
import * as acorn from 'acorn'
import fs from 'fs'

const testPattern = path.join(__dirname, 'testProject/**/*.js')
// 要检查的文件
const files = fg.sync(testPattern)

// acorn 解析配置
const acornOpts = {
  ecmaVersion: 5,// 目标版本
  silent: true
  // sourceType: 'module'
  // allowHashBang:true
}

// 错误
const errArr: any[] = []

// 遍历文件
files.forEach((file) => {
  const code = fs.readFileSync(file, 'utf8')
  try {
    acorn.parse(code, acornOpts as any)
  } catch (err: any) {
    errArr.push({
      err,
      stack: err.stack,
      file
    })
  }
})

// 打印错误信息
if (errArr.length > 0) {
  console.error(
    `ES-Check: there were ${errArr.length} ES version matching errors.`
  )
  errArr.forEach((o) => {
    console.info(`
        ES-Check Error:
        ]]></description>
            <content:encoded><![CDATA[<h1 id="escheck工具原理解析及增强实现" tabindex="-1">ESCheck工具原理解析及增强实现 <a class="header-anchor" href="#escheck工具原理解析及增强实现" aria-label="Permalink to “ESCheck工具原理解析及增强实现”">&#8203;</a></h1>
<blockquote>
<p>本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！</p>
</blockquote>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>2022了，大家做的面向C端的产品（Web，小程序，其它跨端方案），涉及JS产物的还是避不开兼容性的话题（即使IE已官宣停止支持）</p>
<p>但就目前看来这个停止维护还是避免不了大家做开发还是要考虑兼容低端机，甚至<code>IE11</code></p>
<p>针对js目前通常的手段都是通过工具对js进行语法降级至 ES5，同时引入对应的 polyfill（垫片）</p>
<p>工具首选还是老牌 <a href="https://babeljs.io/" target="_blank" rel="noreferrer">Babel</a>，当然现在还有 <a href="https://swc.rs/" target="_blank" rel="noreferrer">SWC</a> 这个冉冉升起的新星</p>
<p>经过一顿操作为项目配置 Babel 之后，为了保证产物不出现 ES5 之外的语法，通常都会搭配一个 Check 工具去检测产物是否符合要求</p>
<p>本文将阐述市面上已有工具的<code>实现原理</code>，<code>功能对比</code>，最后<code>实现增强型的es-check</code>，提供 CLI 和 Lib 两种使用方式</p>
<p>下面先分别介绍一下社区版的<a href="https://github.com/yowainwright/es-check" target="_blank" rel="noreferrer">es-check</a>和滴滴版的<a href="https://github.com/mpx-ecology/mpx-es-check" target="_blank" rel="noreferrer">@mpxjs/es-check</a>实现原理，最后再实现一个集大成者</p>
<h2 id="es-check" tabindex="-1">es-check <a class="header-anchor" href="#es-check" aria-label="Permalink to “es-check”">&#8203;</a></h2>
<p>先看一下其效果，下面是用于测试的代码</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::d3yi17a2etiqluuc59jin::--><code>// test.js
var str = &#039;hello&#039;
var str2 = &#039;world&#039;

const varConst = &#039;const&#039;
let varLet = &#039;let&#039;
const arrFun = () =&gt; {
    console.log(&#039;hello world&#039;);
}</code></pre>
</div><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::u8k10lnv08tq3lc8p4kv::--><code>npx es-check es5 testProject/**/*.js</code></pre>
</div><p><img src="./escheck/MTY2NDAyODU1NTI3OA==664028555278.png" alt="图片" loading="lazy"></p>
<p>可以看到其报错信息比较简单，只输出了代码中的第一个ES语法问题<code>const</code>,然后对应的是行数和具体文件路径</p>
<p>我们再把这个测试文件<code>构建压缩混淆一下</code>(模拟build产物)</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::5ucwq0zsarvlv5s3a5nx6::--><code>npx tsup __test__/testProject/js/index.js --sourcemap -d __test__/testProject/dist --minify</code></pre>
</div><p>通过结果，可以看到，只说有解析问题，并未告知是什么问题，然后有对应的行列数</p>
<p><img src="./escheck/MTY2NDAyOTcwMjg4Ng==664029702886.png" alt="图片" loading="lazy"></p>
<p>如果有<code>sourcemap</code>那么我们暂且是可以通过<a href="https://www.npmjs.com/package/source-map" target="_blank" rel="noreferrer">source-map</a>这个库解析一下，以上面的报错为例</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::kd62x4yr0trno18yyv98h::--><code>// npx esno source-map.ts
import sourceMap from &#039;source-map&#039;
import fs from &#039;fs&#039;
import path from &#039;path&#039;

const file = path.join(__dirname, &#039;testProject/dist/index.js.map&#039;)
const lineNumber = 1
const columnNumber = 45

;(async () =&gt; {
  const consumer = await new sourceMap.SourceMapConsumer(
    fs.readFileSync(file, &#039;utf-8&#039;)
  )
  const sm = consumer.originalPositionFor({
    column: columnNumber,
    line: lineNumber
  })
  // 对应文件的源码
  const content = consumer.sourceContentFor(sm.source!)
  // 错误行的代码
  const errCode = content?.split(/\r?\n/g)[sm.line! - 1]
  console.log(errCode)
})()</code></pre>
</div><p>执行结果如下，可以得到对应的错误代码</p>
<p><img src="./escheck/MTY2NDAzMjI5MTA1Mw==664032291053.png" alt="图片" loading="lazy"></p>
<h3 id="原理分析" tabindex="-1">原理分析 <a class="header-anchor" href="#原理分析" aria-label="Permalink to “原理分析”">&#8203;</a></h3>
<p>打开<a href="https://github.com/yowainwright/es-check/blob/master/index.js" target="_blank" rel="noreferrer">源码</a>可以看到实现非常简单，关键不过100行。可以总结为3步骤</p>
<ol>
<li>使用 <a href="https://www.npmjs.com/package/fast-glob" target="_blank" rel="noreferrer">fast-glob</a> 获取目标文件</li>
<li>使用 <a href="https://github.com/acornjs/acorn/tree/master/acorn" target="_blank" rel="noreferrer">acorn</a> 解析源码生层AST，并捕获解析错误</li>
<li>判断是否存在解析错误，有就打印</li>
</ol>
<p><code>acorn</code> 是一个很常见的 js 解析库，可以用于AST的生成与CRUD操作，其包含1个 <code>ecmaVersion</code> 参数用于指定要解析的 <code>ECMAScript</code> 版本。<code>es-check</code>正是利用了这个特性</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::4ji0eujkdems5dzcjxfuf::--><code>import * as acorn from &#039;acorn&#039;

try {
  acorn.parse(`const a = &#039;hello&#039;`, {
    ecmaVersion: 5,
    silent: true
    // sourceType: &#039;module&#039;
    // allowHashBang:true
  })
} catch (err) {
  // The keyword &#039;const&#039; is reserved (1:0)
  console.log(err)
  // err 除了继承常规 Error 对象，包含 stack 和 message 等内容外，还包含如下信息
  // {
  //   pos: 0,
  //   loc: Position { line: 1, column: 0 },
  //   raisedAt: 7
  // }
}</code></pre>
</div><p>下面是<code>es-check</code>的精简实现，完整源码见 <a href="https://github.com/ATQQ/tools/blob/feature/es-check/packages/cli/es-check/__test__/es-check.ts" target="_blank" rel="noreferrer">Github</a></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::5jz3vdxsqqmv2mvdpyk6f::--><code>// npx esno es-check.ts
import fg from &#039;fast-glob&#039;
import path from &#039;path&#039;
import * as acorn from &#039;acorn&#039;
import fs from &#039;fs&#039;

const testPattern = path.join(__dirname, &#039;testProject/**/*.js&#039;)
// 要检查的文件
const files = fg.sync(testPattern)

// acorn 解析配置
const acornOpts = {
  ecmaVersion: 5,// 目标版本
  silent: true
  // sourceType: &#039;module&#039;
  // allowHashBang:true
}

// 错误
const errArr: any[] = []

// 遍历文件
files.forEach((file) =&gt; {
  const code = fs.readFileSync(file, &#039;utf8&#039;)
  try {
    acorn.parse(code, acornOpts as any)
  } catch (err: any) {
    errArr.push({
      err,
      stack: err.stack,
      file
    })
  }
})

// 打印错误信息
if (errArr.length &gt; 0) {
  console.error(
    `ES-Check: there were ${errArr.length} ES version matching errors.`
  )
  errArr.forEach((o) =&gt; {
    console.info(`
        ES-Check Error:
        ----
        · erroring file: ${o.file}
        · error: ${o.err}
        · see the printed err.stack below for context
        ----\n
        ${o.stack}
      `)
  })
  process.exit(1)
}

console.info(`ES-Check: there were no ES version matching errors!  🎉`)</code></pre>
</div><p><img src="./escheck/MTY2NDEwNzY1NjA0Nw==664107656047.png" alt="图片" loading="lazy"></p>
<h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to “小结”">&#8203;</a></h3>
<ol>
<li>只能检测源码中是否存在不符合对应ECMAScript版本的语法</li>
<li>只会反应出文件中第一个语法问题</li>
<li>错误信息只包含所在文件中的<code>行列号</code>以及<code>parser error</code></li>
<li>不支持html</li>
</ol>
<h2 id="mpx-es-check" tabindex="-1">mpx-es-check <a class="header-anchor" href="#mpx-es-check" aria-label="Permalink to “mpx-es-check”">&#8203;</a></h2>
<blockquote>
<p>滴滴出品的 <a href="https://mpxjs.cn/" target="_blank" rel="noreferrer">mpx</a> (增强型跨端小程序框架)的配套工具 <a href="https://github.com/mpx-ecology/mpx-es-check" target="_blank" rel="noreferrer">@mpxjs/es-check</a></p>
</blockquote>
<p>咱们还是用上面的例子先实测一下效果</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::3ltkxvx1uismp7jtetm2kk::--><code># 1
npm i -g @mpxjs/es-check
# 2
mpx-es-check --ecma=6 testProject/**/*.js</code></pre>
</div><p>可以看到其将错误信息输出到了1个log文件中</p>
<p><img src="./escheck/MTY2NDA3Mzg0NTcxNw==664073845717.png" alt="图片" loading="lazy"></p>
<p>log日志信息如下，还是很清晰的指出了有哪些错误并标明了错误的具体位置，内置了<code>source-map</code>解析。</p>
<p><img src="./escheck/MTY2NDA3NDExNjQ3Ng==664074116476.png" alt="图片" loading="lazy"></p>
<p>下面来探究一下实现原理</p>
<h3 id="原理分析-1" tabindex="-1">原理分析 <a class="header-anchor" href="#原理分析-1" aria-label="Permalink to “原理分析”">&#8203;</a></h3>
<p>打开源码，从<a href="https://github.com/mpx-ecology/mpx-es-check/blob/master/index.js" target="_blank" rel="noreferrer">入口文件</a>开始看，大体分为以下几步：</p>
<ol>
<li>使用<code>glob</code>获取要检测目标文件</li>
<li>获取文件对应的<code>源码</code>和<code>sourcemap</code>文件内容</li>
<li>使用<a href="https://babel.dev/docs/en/babel-parser" target="_blank" rel="noreferrer">@babel/parser</a>解析生成AST</li>
<li>使用<a href="https://babel.dev/docs/en/babel-traverse" target="_blank" rel="noreferrer">@babel/traverse</a>遍历节点</li>
<li>将所有非ES5语法的节点规则进行枚举，再遍历节点时，找出符合条件的节点</li>
<li>格式化输出信息</li>
</ol>
<p>其中<code>@babel/parser</code>与<code>@babel/traverse</code>是<code>babel</code>的核心构成部分。一个用于解析一个用于遍历</p>
<p>节点规则示例如下，这个方法准确，就是费时费力，需要将每个版本的特性都穷举出来</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::dcug8uowo29w42bo9nkuh8::--><code>// 部分节点规则
const partRule = {
  // let and const
  VariableDeclaration(node) {
    if (node.kind === &#039;let&#039; || node.kind === &#039;const&#039;) {
      errArr.push({
        node,
        message: `Using ${node.kind} is not allowed`
      })
    }
  },
  // 箭头函数
  ArrowFunctionExpression(node) {
    errArr.push({
      node,
      message: &#039;Using ArrowFunction(箭头函数) is not allowed&#039;
    })
  }
}</code></pre>
</div><p>下面是遍历规则与节点的逻辑</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::ou61frypv592qt3ab8mhjb::--><code>// 存放所有节点
const nodeQueue = []
const code = fs.readFileSync(file, &#039;utf8&#039;)
// 生成AST
const ast = babelParser.parse(code, acornOpts)
// 遍历获取所有节点
babelTraverse(ast, {
  enter(path) {
    const { node } = path
    nodeQueue.push({ node, path })
  }
})

// 遍历每个节点，执行对应的规则
nodeQueue.forEach(({ node, path }) =&gt; {
  partRule[node.type]?.(node)
})

// 解析格式化错误
errArr.forEach((err) =&gt; {
  // 省略 sourcemap 解析步骤
  problems.push({
    file,
    message: err.message,
    startLine: err.node.loc.start.line,
    startColumn: err.node.loc.start.column
  })
})</code></pre>
</div><p>精简实现的运行结果如下，完整源码见<a href="https://github.com/ATQQ/tools/blob/feature/es-check/packages/cli/es-check/__test__/mpx-es-check.ts" target="_blank" rel="noreferrer">Github</a></p>
<p><img src="./escheck/MTY2NDA5MjM0NDgyNQ==664092344825.png" alt="图片" loading="lazy"></p>
<h3 id="小结-1" tabindex="-1">小结 <a class="header-anchor" href="#小结-1" aria-label="Permalink to “小结”">&#8203;</a></h3>
<ol>
<li>检测输出的结果相对友好（比较理想的格式），内置了sourcemap解析逻辑</li>
<li>不支持html</li>
<li>需要额外维护一套规则（相对ECMAScript迭代频率来说，可以接受）</li>
</ol>
<h2 id="增强实现es-check" tabindex="-1">增强实现es-check <a class="header-anchor" href="#增强实现es-check" aria-label="Permalink to “增强实现es-check”">&#8203;</a></h2>
<p>综上2个对比，从源码实现反应来看 <code>es-check</code> 的实现更简单，维护成本也相对较低</p>
<!-- 补超链接 -->
<p>@sugarat/es-check 也将基于<code>es-check</code>做1个增强实现，弥补<code>单文件多次检测</code>,<code>支持HTML</code>、<code>sourcemap解析</code>等能力</p>
<h3 id="单文件多次检测" tabindex="-1">单文件多次检测 <a class="header-anchor" href="#单文件多次检测" aria-label="Permalink to “单文件多次检测”">&#8203;</a></h3>
<p>现状：利用<code>acorn.parse</code>直接对<code>code</code>进行解析时候，将会直接抛出<code>code</code>中的一处<code>解析错误</code>，然后就结束了</p>
<p>那咱们只需要将<code>code</code>拆成多个代码片段，那这个问题理论上就迎刃而解了</p>
<p>现在的问题就是怎么拆了？</p>
<p>我们这直接简单暴力一点，<strong>对AST直接进行节点遍历，然后分别检测每个节点对应的代码是否合法</strong></p>
<p>首先使用<code>latest</code>版本生成这棵AST</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::v56kk9p0w9jsgaynplieh::--><code>const ast = acorn.parse(code, {
  ecmaVersion: &#039;latest&#039;
})</code></pre>
</div><p>接下来使用<a href="https://github.com/acornjs/acorn/tree/master/acorn-walk" target="_blank" rel="noreferrer">acorn-walk</a>进行遍历</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::vs4kztdndoyl6v3qei4h::--><code>import * as acornWalk from &#039;acorn-walk&#039;

acornWalk.full(ast, (node, _state, _type) =&gt; {
  // 节点对应的源码
  const codeSnippet = code.slice(node.start, node.end)
  try {
    acorn.parse(codeSnippet, {
        ecmaVersion,
    })
  } catch (error) {
    // 在这里输出错误片段和解析报错原因
    console.log(codeSnippet)
    console.log(error.message)
  }
})</code></pre>
</div><p>还是以前面的测试代码为例，输出的错误信息如下</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::lg7395lnt8hmfwnj3g9w3::--><code>var str = &#039;hello&#039;
var str2 = &#039;world&#039;

const varConst = &#039;const&#039;
let varLet = &#039;let&#039;
const arrFun = () =&gt; {
    console.log(&#039;hello world&#039;);
}</code></pre>
</div><p><a href="https://github.com/ATQQ/tools/blob/feature/es-check/packages/cli/es-check/__test__/demos/more-error/1.ts" target="_blank" rel="noreferrer">完整demo1代码</a></p>
<p><img src="./escheck/MTY2NDI5MDc0Mzc4MA==664290743780.png" alt="图片" loading="lazy"></p>
<p>部分节点对应的片段可能不完整，会导致解析错误</p>
<p><img src="./escheck/MTY2NDI5MTE3Nzc2NQ==664291177765.png" alt="图片" loading="lazy"></p>
<p>用于测试的片段如下</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::w8pumqb442b89z6nj8qj::--><code>const obj = {
  &#039;boolean&#039;: true,
}</code></pre>
</div><p>这里可以再<code>parse</code>检测<code>error</code>前再parse一次<code>latest</code> 用于排除语法错误，额外逻辑如下</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::cos02mscrzrovji61gj7r8::--><code>let isValidCode = true
// 判断代码片段 是否合法
try {
  acorn.parse(codeSnippet, {
    ecmaVersion: &#039;latest&#039;
  })
} catch (_) {
  isValidCode = false
}
// 不合法不处理
if (!isValidCode) {
  return
}</code></pre>
</div><p><img src="./escheck/MTY2NDI5MTMyMzU1MQ==664291323551.png" alt="图片" loading="lazy"></p>
<p><a href="https://github.com/ATQQ/tools/blob/feature/es-check/packages/cli/es-check/__test__/demos/more-error/2.ts" target="_blank" rel="noreferrer">完整demo2代码</a></p>
<p>此时输出的错误存在一些重复的情况，比如<code>父节点包含子节点的问题代码</code>，这里做一下过滤</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::mt45v2tbivkyfe7flzroe::--><code>const codeErrorList: any[] = []
acornWalk.full(ast, (node, _state, _type) =&gt; {
  // 节点对应的源码
  const codeSnippet = code.slice(node.start, node.end)
  // 省略重复代码。。。
  try {
    acorn.parse(codeSnippet, {
      ecmaVersion: &#039;5&#039;
    } as any)
  } catch (error: any) {
    // 与先存错误进行比较
    const isRepeat = codeErrorList.find((e) =&gt; {
      // 判断是否是包含关系
      return e.start &gt;= node.start &amp;&amp; e.end &lt;= node.end
    })

    if (!isRepeat) {
      codeErrorList.push({
        codeSnippet,
        message: error.message,
        start: node.start,
        end: node.end
      })
    }
  }
})
console.log(codeErrorList)</code></pre>
</div><p>修正后结果如下</p>
<p><img src="./escheck/MTY2NDI5MjA0MDk1Ng==664292040956.png" alt="图片" loading="lazy"></p>
<p><a href="https://github.com/ATQQ/tools/blob/feature/es-check/packages/cli/es-check/__test__/demos/more-error/3.ts" target="_blank" rel="noreferrer">完整demo3代码</a></p>
<p>如有一些边界情况也是在 <code>catch err</code>部分根据 <code>message</code>做一下过滤即可</p>
<p>比如下代码</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::pfncembc44s8warotzbvys::--><code>var { boolean:hello } = {}</code></pre>
</div><p><img src="./escheck/MTY2NDI5MjY5Mjg2Ng==664292692866.png" alt="图片" loading="lazy"></p>
<p><a href="https://github.com/ATQQ/tools/blob/feature/es-check/packages/cli/es-check/__test__/demos/more-error/4.ts" target="_blank" rel="noreferrer">完整demo4代码</a></p>
<p>做一下过滤，<code>catch message</code>添加过滤逻辑</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::k5sk46v4nj926nzcnqzv::--><code>const filterMessage = [/^The keyword /]
if (filterMessage.find((r) =&gt; r.test(error.message))) {
  return
}</code></pre>
</div><p>调整后的报错信息就是<code>解构赋值</code>的语法错误了</p>
<p><img src="./escheck/MTY2NDI5MjkxNDY0MQ==664292914641.png" alt="图片" loading="lazy"></p>
<p><a href="https://github.com/ATQQ/tools/blob/feature/es-check/packages/cli/es-check/__test__/demos/more-error/5.ts" target="_blank" rel="noreferrer">完整demo5代码</a></p>
<p>至此基本能完成了<code>单文件的多次es-check检测</code>，虽然不像<code>mpx-es-check</code>那样用直白的语言直接说面是什么语法。但还有改进空间嘛，后面再单独写个文章做个工具检测目标代码用了哪些<code>ES6+</code>特性。就不再这里赘述了</p>
<h3 id="sourcemap解析" tabindex="-1">sourcemap解析 <a class="header-anchor" href="#sourcemap解析" aria-label="Permalink to “sourcemap解析”">&#8203;</a></h3>
<p>这个主要针对检测资源是<code>build产物</code>的一项优化，通过<code>source-map</code>解析报错信息对应的源码</p>
<p>前面的代码我们只获取了<code>问题源码</code>的起止字符位置<code>start</code>,<code>end</code></p>
<p>通过source-map解析，首先要获取报错代码在资源中的行列信息</p>
<p>这里通过<code>acorn.getLineInfo</code>方法可直接获取行列信息</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::yon1tg2snqvey20nwqfv::--><code>// 省略了重复代码
const codeErrorList: any[] = []
acornWalk.full(ast, (node, _state, _type) =&gt; {
  // 节点对应的源码
  const codeSnippet = code.slice(node.start, node.end)
  try {
    acorn.parse(codeSnippet, {
      ecmaVersion: &#039;5&#039;
    } as any)
  } catch (error) {
    const locStart = acorn.getLineInfo(code, node.start)
    const locEnd = acorn.getLineInfo(code, node.end)
    codeErrorList.push({
      loc: {
        start: locStart,
        end: locEnd
      }
    })
  }
})
console.dir(codeErrorList, {
  depth: 3
})</code></pre>
</div><p>结果如下，<a href="https://github.com/ATQQ/tools/blob/feature/es-check/packages/cli/es-check/__test__/demos/source-map/1.ts" target="_blank" rel="noreferrer">完整demo1代码</a></p>
<p><img src="./escheck/MTY2NDMzNzAxMjIyOQ==664337012229.png" alt="图片" loading="lazy"></p>
<p>有了行列号，我们就可以根据<code>*.map</code>文件进行源码的解析</p>
<p>默认<code>map</code>文件由原文件名加<code>.map</code>后缀</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::wczxh16ci76tm58anhc25::--><code>function getSourcemapFileContent(file: string) {
  const sourceMapFile = `${file}.map`
  if (fs.existsSync(sourceMapFile)) {
    return fs.readFileSync(sourceMapFile, &#039;utf-8&#039;)
  }
  return &#039;&#039;
}</code></pre>
</div><p>解析<code>map</code>文件直接使用 <code>sourceMap.SourceMapConsumer</code>,返回的实例是1个<code>Promise</code>,使用时需注意</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::z3u9tugtjszmvmv01qbf::--><code>function parseSourceMap(code: string) {
  const consumer = new sourceMap.SourceMapConsumer(code)
  return consumer
}</code></pre>
</div><p>根据前面<code>source-map</code>解析的例子，把这块逻辑放到<code>checkCode</code>之后即可</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::2tfg9wi138je7k6o7kxbqo::--><code>const code = fs.readFileSync(file, &#039;utf-8&#039;)
// ps: checkCode 即为上一小节实现代码检测能力的封装
const codeErrorList = checkCode(code)
const sourceMapContent = getSourcemapFileContent(file)
if (sourceMapContent) {
  const consumer = await parseSourceMap(sourceMapContent)
  codeErrorList.forEach((v) =&gt; {
    // 解析获取原文件信息
    const smStart = consumer.originalPositionFor({
      line: v.loc.start.line,
      column: v.loc.start.column
    })
    const smEnd = consumer.originalPositionFor({
      line: v.loc.end.line,
      column: v.loc.end.column
    })

    // start对应源码所在行的代码
    const sourceStartCode = consumer
      .sourceContentFor(smStart.source!)
      ?.split(/\r?\n/g)[smStart.line! - 1]
    const sourceEndCode = consumer
      .sourceContentFor(smEnd.source!)
      ?.split(/\r?\n/g)[smEnd.line! - 1]
    // 省略 console 打印代码
  })
}</code></pre>
</div><p><a href="https://github.com/ATQQ/tools/blob/feature/es-check/packages/cli/es-check/__test__/demos/source-map/2.ts" target="_blank" rel="noreferrer">完整demo2代码</a></p>
<p><img src="./escheck/MTY2NDMzNzM4NTkyMw==664337385923.png" alt="图片" loading="lazy"></p>
<p>这块就对齐了<code>mpx-es-check</code>的<code>source-map</code>解析能力</p>
<h3 id="html支持" tabindex="-1">HTML支持 <a class="header-anchor" href="#html支持" aria-label="Permalink to “HTML支持”">&#8203;</a></h3>
<p>这个就比较好办了，只需要将<code>script</code>里的内容提取出来，调用上述的<code>checkCode</code>方法，然后对结果进行一个行列号的优化即可</p>
<p>这里提取的方法很多，可以</p>
<ol>
<li><code>正则匹配</code></li>
<li><a href="https://cheerio.js.org/" target="_blank" rel="noreferrer">cheerio</a>：像jQuery一样操作</li>
<li><a href="https://github.com/inikulin/parse5" target="_blank" rel="noreferrer">parse5</a>：生成AST，递归遍历需要的节点</li>
<li><a href="https://github.com/fb55/htmlparser2" target="_blank" rel="noreferrer">htmlparser2</a>：生成AST，相比<code>parse5</code>更加，解析策略更加”包容“</li>
</ol>
<p>小试对比了一下，最后发现是用<code>parse5</code>更符合这个场景（编写代码更少）</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::zjuob1reop44rbcjof1j::--><code>import * as parse5 from &#039;parse5&#039;

const htmlAST = parse5.parse(code, {
  sourceCodeLocationInfo: true
})</code></pre>
</div><p>下面是生成的AST示例: <a href="https://astexplorer.net/#/gist/03728790dcd82e64204cdf4641a43d8f/c988f350916bfe04c642333b0839ed35e7578ca6" target="_blank" rel="noreferrer">https://astexplorer.net/#/gist/03728790dcd82e64204cdf4641a43d8f/c988f350916bfe04c642333b0839ed35e7578ca6</a></p>
<p>通过<code>nodeName</code>或者<code>tagName</code>就可以区分节点类型，这里简单写个遍历方法</p>
<p>节点可以通过<code>childNodes</code>属性区分是否包含子节点</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::vmfnvtk9lpspsl1ea6e8hr::--><code>function traverse(ast: any, traverseSchema: Record&lt;string, any&gt;) {
  traverseSchema?.[ast?.nodeName]?.(ast)
  if (ast?.nodeName !== ast?.tagName) {
    traverseSchema?.[ast?.tagName]?.(ast)
  }
  ast?.childNodes?.forEach((n) =&gt; {
    traverse(n, traverseSchema)
  })
}</code></pre>
</div><p>这里遍历一下demo代码生成的ast</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::opgtycac7hgaitl75p2qbh::--><code>traverse(htmlAST, {
  script(node: any) {
    const code = `${node.childNodes.map((n) =&gt; n.value)}`
    const loc = node.sourceCodeLocation
    if (code) {
      console.log(code)
      console.log(loc)
    }
  }
})</code></pre>
</div><p><a href="https://github.com/ATQQ/tools/blob/feature/es-check/packages/cli/es-check/__test__/demos/html-check/1.ts" target="_blank" rel="noreferrer">完整demo1代码</a></p>
<p><img src="./escheck/MTY2NDM1MTM3NDUyMA==664351374520.png" alt="图片" loading="lazy"></p>
<p>获得对应的源码后就可以调用之前的<code>checkCode</code>方法，对错误行号做一个拼接即可得到错误信息</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::ivh4hihtqwcs2j7qti768::--><code>traverse(htmlAST, {
  script(node: any) {
    const code = `${node.childNodes.map((n) =&gt; n.value)}`
    const loc = node.sourceCodeLocation
    if (code) {
      const errList = checkCode(code)
      errList.forEach((err) =&gt; {
        console.log(
          &#039;line:&#039;,
          loc.startLine + err.loc.start.line - 1,
          &#039;column:&#039;,
          err.loc.start.column
        )
        console.log(err.source)
        console.log()
      })
    }
  }
})</code></pre>
</div><p><a href="https://github.com/ATQQ/tools/blob/feature/es-check/packages/cli/es-check/__test__/demos/html-check/2.ts" target="_blank" rel="noreferrer">完整demo2代码</a></p>
<p><img src="./escheck/MTY2NDM1MzM1OTY4OA==664353359688.png" alt="图片" loading="lazy"></p>
<h3 id="组建cli能力" tabindex="-1">组建CLI能力 <a class="header-anchor" href="#组建cli能力" aria-label="Permalink to “组建CLI能力”">&#8203;</a></h3>
<p>这里就不再赘述CLI过程代码，核心的已在前面阐述，这里直接上最终成品的使用演示，参数同<code>es-check</code>保持一致</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::92griyf5a1pzf9voilz3o::--><code>npm i @sugarat/es-check -g</code></pre>
</div><p>检测目标文件</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::1lghbq90o22hps7dk1hpa6::--><code>escheck es5 testProject/**/*.js testProject/**/*.html</code></pre>
</div><p><img src="./escheck/MTY2NDM3ODMyNjc0OQ==664378326749.png" alt="图片" loading="lazy"></p>
<p>日志输出到文件</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::haxp69l04ssxid05jym7re::--><code>escheck es5 testProject/**/*.js testProject/**/*.html --out</code></pre>
</div><p><img src="./escheck/MTY2NDM3ODU2NzI1OA==664378567258.png" alt="图片" loading="lazy"></p>
<h2 id="最终对比" tabindex="-1">最终对比 <a class="header-anchor" href="#最终对比" aria-label="Permalink to “最终对比”">&#8203;</a></h2>
<table tabindex="0">
<thead>
<tr>
<th>Name</th>
<th>JS</th>
<th>HTML</th>
<th>Friendly</th>
</tr>
</thead>
<tbody>
<tr>
<td>es-check</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>@mpxjs/es-check</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>@sugarat/es-check</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>取了2者的优点相结合然后做了一定的增强</p>
<h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>当然这个工具可能存在bug，遗漏部分场景等情况，读者试用可以评论区给反馈，或者库里直接提<code>issues</code></p>
<p>有其它功能上的建议也可评论区留言交流</p>
<p>完整源码移步=&gt;<a href="https://github.com/ATQQ/tools/tree/main/packages/cli/es-check" target="_blank" rel="noreferrer">Github</a></p>
<h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to “参考”">&#8203;</a></h2>
<ul>
<li><a href="https://github.com/yowainwright/es-check" target="_blank" rel="noreferrer">es-check</a>：社区出品</li>
<li><a href="https://github.com/mpx-ecology/mpx-es-check" target="_blank" rel="noreferrer">mpx-es-check</a>：滴滴出品 <a href="https://mpxjs.cn/" target="_blank" rel="noreferrer">MPX</a> 框架的配套工具</li>
</ul>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/escheck/MTY2NDAyODU1NTI3OA==664028555278.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[组装个支持记笔记的CodePen]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/codeNote.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/codeNote.html</guid>
            <pubDate>Sun, 28 Aug 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[# 组装个支持记笔记的CodePen
## 前言
emmm。。。，有好长一段时间没码文了（近几个月实在是太忙了），这个玩具刚好是这两周抽空`拼`的拿出来和大家分享一下

朋友最近刚学前端，经常问一些问题，通过聊天软件发代码和贴图实在是不太方便，就给它推荐了[CodePen](https://codepen.io/) 和 [🐴上掘金](https://code.juejin.cn/)

前者国内访问实在不稳定，后者emm有个内容审核，导致内容`实时性`较差。

就搜了搜GitHub上有不有类似的项目，搜了一圈还真有不少，这里贴两个感觉不错的 [CodeRun](https://wanglin2.github.io/code-run-online/#/) 和 [CodePan](https://codepan.egoist.sh/)

朋友使用后反馈，问了问有不有啥支持直接在旁边 **写笔记**，**贴图片（这个）**，方便做记录

emm...，检索了一圈记忆中除了 `VsCode` 好像还真没有这种东西（可能是我孤陋寡闻了，读者有推荐的可以评论区补充）

那就给他造个吧，练练手，有段时间没写自己的代码了

等不及了？先体验体验👉🏻 [示例1：应用首页](https://code.sugarat.top)，[示例2：分享代码](https://code.sugarat.top/share/63035c10a6ea447087355f55)

## 技术选型
行动肯定是要站在巨人的"键盘上"(手滑打错了，那就这样吧)，先看看有哪些可用的 "零件"

### 内容编辑器
先是写笔记部分，挑了几个库玩了一下
* [wangEditor](https://www.wangeditor.com/) - 开源 Web 富文本编辑器，开箱即用，配置简单
* [prosemirror](https://prosemirror.net/) - 支持部分MarkDown语法，可拓展定制的富文本编辑器
* [🧴 Lotion](https://lotion.dashibase.com/) - 基于Vue3开发的块编辑器
* [Editor.js](https://editorjs.io/) - 官方:"Next generation block styled editor.",下一代块编辑器

因为屏幕中需要展示 笔记/代码/预览 3个部分，直接使用markdown语法会有个切换的动作（这里就不考虑markdown格式做编辑了）

上述的几个库分大体上分为两类`富文本编辑器`，`块编辑器`

|                                富文本编辑器                                 |                                  块编辑器                                   |
| :]]></description>
            <content:encoded><![CDATA[<h1 id="组装个支持记笔记的codepen" tabindex="-1">组装个支持记笔记的CodePen <a class="header-anchor" href="#组装个支持记笔记的codepen" aria-label="Permalink to “组装个支持记笔记的CodePen”">&#8203;</a></h1>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>emmm。。。，有好长一段时间没码文了（近几个月实在是太忙了），这个玩具刚好是这两周抽空<code>拼</code>的拿出来和大家分享一下</p>
<p>朋友最近刚学前端，经常问一些问题，通过聊天软件发代码和贴图实在是不太方便，就给它推荐了<a href="https://codepen.io/" target="_blank" rel="noreferrer">CodePen</a> 和 <a href="https://code.juejin.cn/" target="_blank" rel="noreferrer">🐴上掘金</a></p>
<p>前者国内访问实在不稳定，后者emm有个内容审核，导致内容<code>实时性</code>较差。</p>
<p>就搜了搜GitHub上有不有类似的项目，搜了一圈还真有不少，这里贴两个感觉不错的 <a href="https://wanglin2.github.io/code-run-online/#/" target="_blank" rel="noreferrer">CodeRun</a> 和 <a href="https://codepan.egoist.sh/" target="_blank" rel="noreferrer">CodePan</a></p>
<p>朋友使用后反馈，问了问有不有啥支持直接在旁边 <strong>写笔记</strong>，<strong>贴图片（这个）</strong>，方便做记录</p>
<p>emm...，检索了一圈记忆中除了 <code>VsCode</code> 好像还真没有这种东西（可能是我孤陋寡闻了，读者有推荐的可以评论区补充）</p>
<p>那就给他造个吧，练练手，有段时间没写自己的代码了</p>
<p>等不及了？先体验体验👉🏻 <a href="https://code.sugarat.top" target="_blank" rel="noreferrer">示例1：应用首页</a>，<a href="https://code.sugarat.top/share/63035c10a6ea447087355f55" target="_blank" rel="noreferrer">示例2：分享代码</a></p>
<h2 id="技术选型" tabindex="-1">技术选型 <a class="header-anchor" href="#技术选型" aria-label="Permalink to “技术选型”">&#8203;</a></h2>
<p>行动肯定是要站在巨人的&quot;键盘上&quot;(手滑打错了，那就这样吧)，先看看有哪些可用的 &quot;零件&quot;</p>
<h3 id="内容编辑器" tabindex="-1">内容编辑器 <a class="header-anchor" href="#内容编辑器" aria-label="Permalink to “内容编辑器”">&#8203;</a></h3>
<p>先是写笔记部分，挑了几个库玩了一下</p>
<ul>
<li><a href="https://www.wangeditor.com/" target="_blank" rel="noreferrer">wangEditor</a> - 开源 Web 富文本编辑器，开箱即用，配置简单</li>
<li><a href="https://prosemirror.net/" target="_blank" rel="noreferrer">prosemirror</a> - 支持部分MarkDown语法，可拓展定制的富文本编辑器</li>
<li><a href="https://lotion.dashibase.com/" target="_blank" rel="noreferrer">🧴 Lotion</a> - 基于Vue3开发的块编辑器</li>
<li><a href="https://editorjs.io/" target="_blank" rel="noreferrer">Editor.js</a> - 官方:&quot;Next generation block styled editor.&quot;,下一代块编辑器</li>
</ul>
<p>因为屏幕中需要展示 笔记/代码/预览 3个部分，直接使用markdown语法会有个切换的动作（这里就不考虑markdown格式做编辑了）</p>
<p>上述的几个库分大体上分为两类<code>富文本编辑器</code>，<code>块编辑器</code></p>
<table tabindex="0">
<thead>
<tr>
<th style="text-align:center">富文本编辑器</th>
<th style="text-align:center">块编辑器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="./codeNote/MTY2MTY5ODE0NTY2OQ==661698145669.png" alt="图片" loading="lazy"></td>
<td style="text-align:center"><img src="./codeNote/MTY2MTY5ODIyNjk3NQ==661698226975.png" alt="图片" loading="lazy"></td>
</tr>
</tbody>
</table>
<p>前者是比较传统的编辑器，后者从社区反应来看像是<code>下一代趋势</code>，但国内好像还没看到使用此方案的成熟产品（可能是我孤陋寡闻了，读者有推荐的可以评论区补充）</p>
<p>最后本着技术尝鲜（喜欢折腾）的精神选了<a href="https://editorjs.io/" target="_blank" rel="noreferrer">Editor.js</a>，官方提供了一系列的基础插件，提供了简单的API支持自定义的插件（后面单独开文章介绍）</p>
<h3 id="代码编辑器" tabindex="-1">代码编辑器 <a class="header-anchor" href="#代码编辑器" aria-label="Permalink to “代码编辑器”">&#8203;</a></h3>
<p>这个就<a href="https://github.com/microsoft/monaco-editor" target="_blank" rel="noreferrer">monaco-editor</a> 没得跑了</p>
<p>不过在使用之前先看了一下最近阿里开源的<a href="https://opensumi.com/zh" target="_blank" rel="noreferrer">OpenSumi</a>，看之前以为是个可直接用的<code>NPM</code>包，文档翻了半天，只给了个demo，emm 拉下来，果然如官方预料 卡在了 <code>yarn install</code>，感觉有一定上手成本，先不看了</p>
<h3 id="后端部分" tabindex="-1">后端部分 <a class="header-anchor" href="#后端部分" aria-label="Permalink to “后端部分”">&#8203;</a></h3>
<p>思考了一下都是简单的<code>CRUD</code>场景，存储和鉴权<code>MongoDB</code>与<code>Redis</code>感觉就够了（也没有配置成本，安装即用）</p>
<p>服务端框架部分就直接拿自己的之前写的玩具<a href="https://github.com/ATQQ/flash-wolves" target="_blank" rel="noreferrer">flash-wolves</a>开整</p>
<p>接下来就是组装了</p>
<h2 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-label="Permalink to “实现”">&#8203;</a></h2>
<h3 id="项目搭建" tabindex="-1">项目搭建 <a class="header-anchor" href="#项目搭建" aria-label="Permalink to “项目搭建”">&#8203;</a></h3>
<p>粗糙的原型图如下</p>
<p><img src="./codeNote/MTY2MTY5OTkyOTE2OQ==661699929169.png" alt="图片" loading="lazy"></p>
<p>布局也比较简单</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::9s9qoqfw4zwatb2fxbq7vd::--><code>&lt;header&gt;工具条...&lt;/header&gt;
&lt;!-- 主体内容 --&gt;
&lt;main&gt;
    &lt;Note /&gt;
    &lt;Code /&gt;
    &lt;Render /&gt;
&lt;/main&gt;</code></pre>
</div><p>直接拿之前整的模板进行创建<a href="https://github.com/ATQQ/vite-vue3-template" target="_blank" rel="noreferrer">vite-vue3-template</a>出前端工程</p>
<h3 id="文本编辑部分" tabindex="-1">文本编辑部分 <a class="header-anchor" href="#文本编辑部分" aria-label="Permalink to “文本编辑部分”">&#8203;</a></h3>
<p>示例代码在线演示：<a href="https://code.sugarat.top/share/630b8793789c242a31e57c40" target="_blank" rel="noreferrer">https://code.sugarat.top/share/630b8793789c242a31e57c40</a></p>
<p>直接<a href="https://editorjs.io/configuration" target="_blank" rel="noreferrer">参照官方文档</a>，CV起来就能运行，这里仅仅贴几个关键部分（避免代码占用太大篇幅，降低文章可读性）</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::sw1smg4fhxhpfpk5sr9d99::--><code> const editor = new EditorJS({
    holder: &#039;note-editor&#039;,
    placeholder: &#039;在这里开始记录你的笔记&#039;,
    onReady: () =&gt; {
      console.log(&#039;Editor.js is ready to work!&#039;)
      // 内容初始化
      // 下方拿到的outputData直接塞进来就行
      // 可以在页面加载的时候从数据库取历史数据进行展示
      editor.render(xxx)
    },
    onChange: (api, e) =&gt; {
      editor
        .save()
        .then((outputData) =&gt; {
            // 取得编写的内容
            // 可以将这个内存存起来
            // 在合适的时机调接口存入数据库即可
        })
        .catch((error) =&gt; {
          console.log(&#039;Saving failed: &#039;, error)
        })
    },
    tools: {
      // 图片处理
      image: {
        class: Image,
        config: {
          uploader: {
            uploadByFile(file: File) {
              // 需要自己处理图片上传逻辑
              // 按结构进行返回即可
              return {
                success: 1,
                file: {
                  url: &#039;./codeNote/pupza3m486.png&#039;
                }
              }
            }
          }
        }
      },
    // 一系列官方插件
      header: Header,
      list: List,
    //   ...
    },
    i18n: {
      // 国际化相关配置
    }
  })</code></pre>
</div><h3 id="代码编辑" tabindex="-1">代码编辑 <a class="header-anchor" href="#代码编辑" aria-label="Permalink to “代码编辑”">&#8203;</a></h3>
<p>参照<a href="https://github.com/microsoft/monaco-editor/blob/main/docs/integrate-esm.md" target="_blank" rel="noreferrer">官方文档</a>，几步就起飞，直接调用 <code>monaco-editor</code> 进行初始化，以HTML编辑器为例</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::9g78brwe4d6xuwpbgwek7r::--><code>import * as monaco from &#039;monaco-editor&#039;

const htmlEditor = monaco.editor.create(
  document.getElementById(&#039;html-editor&#039;),
  {
    // 初始化展示的内容
    value: &#039;&lt;h1&gt;hello world&lt;/h1&gt;&#039;,
    language: &#039;html&#039;,
    theme: &#039;vs-dark&#039;,
    fontSize: 18,
    automaticLayout: true
  }
)
// 如果数据是异步从接口拿，那么可以调用setValue方法，设置内容
setTimeout(() =&gt; {
  htmlEditor.setValue(&#039;&lt;h2&gt;hello world&lt;/h2&gt;&#039;)
}, 2000);

// 在这个方法监听编辑器的内容变动
htmlEditor.onDidChangeModelContent(() =&gt; {
  const newValue = htmlEditor.getValue()
})</code></pre>
</div><p>通过上述<code>3</code>个简单的方法即可实现1个简单编辑器的内容读写</p>
<p>当然笔者这里用的Vite + Vue3，<strong>这里还有几个坑</strong></p>
<p>导入worker，参考<a href="https://github.com/vitejs/vite/discussions/1791#discussioncomment-321046" target="_blank" rel="noreferrer">尤大给的示例</a></p>
<blockquote></blockquote>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::wj5r6m4wxedpcfuv8zccir::--><code>// main.ts
import EditorWorker from &#039;monaco-editor/esm/vs/editor/editor.worker?worker&#039;
import JSONWorker from &#039;monaco-editor/esm/vs/language/json/json.worker?worker&#039;
import CSSWorker from &#039;monaco-editor/esm/vs/language/css/css.worker?worker&#039;
import HTMLWorker from &#039;monaco-editor/esm/vs/language/html/html.worker?worker&#039;
import TSWorker from &#039;monaco-editor/esm/vs/language/typescript/ts.worker?worker&#039;
self.MonacoEnvironment = {
  getWorker(_: any, label: string) {
    if (label === &#039;json&#039;) {
      return new JSONWorker()
    }
    if (label === &#039;css&#039; || label === &#039;scss&#039; || label === &#039;less&#039;) {
      return new CSSWorker()
    }
    if (label === &#039;html&#039; || label === &#039;handlebars&#039; || label === &#039;razor&#039;) {
      return new HTMLWorker()
    }
    if (label === &#039;typescript&#039; || label === &#039;javascript&#039;) {
      return new TSWorker()
    }
    return new EditorWorker()
  }
}</code></pre>
</div><p>editor使用ref绑定调用的时候需要toRaw，不然应用就会卡死</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::1s10o07a2vlihrgt6ti097::--><code>const htmlEditor = ref&lt;monaco.editor.IStandaloneCodeEditor&gt;(null as any)
// 根据props更新
watchEffect(() =&gt; {
  if (htmlEditor.value &amp;&amp; props.html) {
    toRaw(htmlEditor.value).setValue(props.html)
  }
})
onMounted(()=&gt;{
  // 初始化实例
  htmlEditor.value = monaco.editor.create({...ops})
    toRaw(htmlEditor.value).onDidChangeModelContent(() =&gt; {
    console.log(toRaw(htmlEditor.value).getValue())
  })
})
</code></pre>
</div><h3 id="代码渲染" tabindex="-1">代码渲染 <a class="header-anchor" href="#代码渲染" aria-label="Permalink to “代码渲染”">&#8203;</a></h3>
<p>这里使用<code>iframe</code>承载内容，期望iframe里页面最终结构如下</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::50c3c4todyrp0bln237jyh::--><code>&lt;head&gt;
  &lt;style&gt;
    /* 内置一些样式重载 */
  &lt;/style&gt;
  &lt;style&gt;
    /* 用户书写样式 */
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!--console信息面板 --&gt;
  &lt;script src=&quot;//cdn.jsdelivr.net/npm/eruda&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    if(window.eruda){
      window.eruda.init({
        defaults: {
          displaySize: 25,
          transparency: 0.9,
        }
      })
      window.eruda.show()
    }
  &lt;/script&gt;

  &lt;div&gt;
    &lt;!-- ...用户html代码 --&gt;
  &lt;/div&gt;

  &lt;script&gt;
    // 用户js代码
  &lt;/script&gt;
&lt;/body&gt;</code></pre>
</div><p>其中 <a href="https://github.com/liriliri/eruda" target="_blank" rel="noreferrer">eruda</a> 主要用于展示 iframe 页面的 log 日志信息、 Dom 结构等，避免打开Chrome DevTools</p>
<p>所有dom的创建均通过 Dom API 完成</p>
<p><strong>在线预览示例代码效果：<a href="https://code.sugarat.top/share/6312ffa045a77f0bc4b881dc" target="_blank" rel="noreferrer">https://code.sugarat.top/share/6312ffa045a77f0bc4b881dc</a></strong></p>
<p>下面简单过一下实现的代码</p>
<p>先给iframe搞个样式,避免看不到</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::xkzu4byhc79p5qvca3gz9::--><code>&lt;style&gt;
iframe {
  width: 100%;
  height: 500px;
}
&lt;/style&gt;</code></pre>
</div><p>然后来3个dom承载我们的<code>三剑客</code>代码</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::j1m45in7hg7ntf38ih78rp::--><code>// 一系列用户编写的代码
const cssCode = `h1{
    color:red;
}`;
const htmlCode = `&lt;h1&gt;hello world&lt;/h1&gt;`;
const jsCode = `console.log(&quot;hello world&quot;)`;

// 3个dom
const $style = document.createElement(&quot;style&quot;);
$style.innerHTML = cssCode;

const $html = document.createElement(&quot;div&quot;);
$html.innerHTML = htmlCode;

const $userScript = document.createElement(&quot;script&quot;);
$userScript.textContent = jsCode;</code></pre>
</div><p>紧接着创建<code>iframe</code>将其装进去 就okk了</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::v4z7csjh2580kj4aqyb3pod::--><code>const $iframe = document.createElement(&quot;iframe&quot;);
$iframe.addEventListener(&quot;load&quot;, () =&gt; {
  $iframe.contentDocument?.head.append($style);
  $iframe.contentDocument.body.append($html, $userScript);
});

document.body.append($iframe);</code></pre>
</div><p>如果要引入eruda，咱们需要先等eruda加载完再插入咱们得<code>script</code>，不然捕获不到代码<code>console</code></p>
<p>详细如下</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::igzwps5d0brb0530ab275r::--><code>$iframe.addEventListener(&quot;load&quot;, () =&gt; {
  $iframe.contentDocument.head.append($style);

  // eruda cdn资源
  const $eruda = document.createElement(&quot;script&quot;);
  $eruda.src = &quot;//cdn.jsdelivr.net/npm/eruda&quot;;
  // 打开面板的代码
  const debugExec = document.createElement(&quot;script&quot;);
  debugExec.textContent = `window.eruda.init({
      defaults: {
        displaySize: 25,
        transparency: 0.9,
      }
    })
    eruda.show()
    `;
  $iframe.contentDocument?.body.append($eruda);

  // eruda 加载完再加载HTML与用户脚本
  $eruda.onload = function () {
    $iframe.contentDocument?.body.append(debugExec, $html, $userScript);
  };
});</code></pre>
</div><h3 id="代码格式化" tabindex="-1">代码格式化 <a class="header-anchor" href="#代码格式化" aria-label="Permalink to “代码格式化”">&#8203;</a></h3>
<p>写完代码后，格式化是很有必要的，避免乱糟糟</p>
<p>笔者这里直接采用<code>prettier</code>，啥都提供好了，CV一下就能用</p>
<p>出参入参都比较简单</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::s54oq3pjgieddhmx3m1ql::--><code>import prettier from &#039;prettier/standalone&#039;
import htmlPlugin from &#039;prettier/parser-html&#039;
import cssPlugin from &#039;prettier/parser-postcss&#039;
import jsPlugin from &#039;prettier/parser-babel&#039;

export function formatHTML(html: string) {
  return prettier.format(html, {
    parser: &#039;html&#039;,
    plugins: [htmlPlugin]
  })
}
export function formatJS(tsCode: string) {
  return prettier.format(tsCode, {
    parser: &#039;babel&#039;,
    plugins: [jsPlugin]
  })
}

export function formatCSS(css: string) {
  return prettier.format(css, {
    parser: &#039;css&#039;,
    plugins: [cssPlugin]
  })
}</code></pre>
</div><p>到这里构成应用的几个主要<code>开源库</code>的使用介绍差不多完了</p>
<p><code>前人栽树后人乘凉</code>，对UI/UE要求不高的时候，拼凑出一个新的应用花费时间不高</p>
<p>当有一丝想法的时候，得及时抓住。</p>
<h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p><code>EditorJS</code>还是有很大的可玩性，后面有机会围绕输出一些插件实践，试着整个编辑器替代日常的Markdown</p>
<p>这个在线的Code也会在后续中会把一些想法迭代进去，目前看主要是代码编辑部分不太友好（代码提示这一块），访问了其它的在线编码的，基本都有这个问题（无论怎么搞都达不到本地VS Code的地步）</p>
<p>后面准备另辟蹊径搞一搞，先把Web版的交互优化一下下</p>
<p><strong>三连破X，更新下一期（手动滑稽）</strong></p>
<p>读者对其它实现细节感兴趣的话，可以<a href="https://code.sugarat.top/" target="_blank" rel="noreferrer">试玩后</a>，评论区留言，下一期送上解读</p>
<p>项目完整源码见<a href="https://github.com/ATQQ/onlineDemoEditor" target="_blank" rel="noreferrer">GitHub</a></p>
<p><em>-------------华丽的分割线------------</em></p>
<p>成签约作者了，后面几个月输出可能会稍微频繁一点了，到时候就打扰了，大家不要吝啬3连</p>
<p><img src="./codeNote/MTY2MjE3MTI4OTg5OA==662171289898.png" alt="图片" loading="lazy"></p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/codeNote/MTY2MTY5ODE0NTY2OQ==661698145669.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[实现一个Web UI检测(视觉走查)工具ing]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/ewuit.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/works/ewuit.html</guid>
            <pubDate>Tue, 05 Jul 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[# 实现一个Web UI检测(视觉走查)工具ing

## 演示
废话不多先看效果，目前支持元素的测距，属性查看这两个功能

| H5                                                                                             | PC                                                                                             |
| ]]></description>
            <content:encoded><![CDATA[<h1 id="实现一个web-ui检测-视觉走查-工具ing" tabindex="-1">实现一个Web UI检测(视觉走查)工具ing <a class="header-anchor" href="#实现一个web-ui检测-视觉走查-工具ing" aria-label="Permalink to “实现一个Web UI检测(视觉走查)工具ing”">&#8203;</a></h1>
<h2 id="演示" tabindex="-1">演示 <a class="header-anchor" href="#演示" aria-label="Permalink to “演示”">&#8203;</a></h2>
<p>废话不多先看效果，目前支持元素的测距，属性查看这两个功能</p>
<table tabindex="0">
<thead>
<tr>
<th>H5</th>
<th>PC</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="./ewuit/MTY0OTA4NDk4MDg4Nw==ewuit-h5.gif?s1=https%3A//img.cdn.sugarat.top/mdImg/MTY0OTA4NDk4MDg4Nw%3D%3Dewuit-h5.gif" width="200px" /></td>
<td><img src="./ewuit/MTY0OTA4MzcwNTUzNQ==ewuit-pc.gif?s1=https%3A//img.cdn.sugarat.top/mdImg/MTY0OTA4MzcwNTUzNQ%3D%3Dewuit-pc.gif" width="300px" /></td>
</tr>
</tbody>
</table>
<h2 id="快速体验" tabindex="-1">快速体验 <a class="header-anchor" href="#快速体验" aria-label="Permalink to “快速体验”">&#8203;</a></h2>
<h3 id="方式1" tabindex="-1">方式1 <a class="header-anchor" href="#方式1" aria-label="Permalink to “方式1”">&#8203;</a></h3>
<p>打开一个网站在控制台中执行</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::htdsftz1swtlzav8ydj1x9::--><code>(function () {
    var url = &#039;//unpkg.com/ewuit@latest/dist/index.min.js&#039;
    var script = document.createElement(&#039;script&#039;);
    script.src = url;
    document.body.appendChild(script);
    script.onload = function () { 
        const ewuit = new Ewuit()
        // open a ui tool
        ewuit.openUI()
    }
})();</code></pre>
</div><h3 id="方式2" tabindex="-1">方式2 <a class="header-anchor" href="#方式2" aria-label="Permalink to “方式2”">&#8203;</a></h3>
<p>在你的页面模板中加入如下脚本</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::4o4jphja4bjvndeq40txog::--><code>&lt;script&gt;
(function () {
    var url = &#039;//unpkg.com/ewuit@latest/dist/index.min.js&#039;
    var script = document.createElement(&#039;script&#039;);
    script.src = url;
    document.body.appendChild(script);
    script.onload = function () { 
        const ewuit = new Ewuit()
        // open a ui tool
        ewuit.openUI()
    }
})();
&lt;/script&gt;</code></pre>
</div><h3 id="其它方式" tabindex="-1">其它方式 <a class="header-anchor" href="#其它方式" aria-label="Permalink to “其它方式”">&#8203;</a></h3>
<p>参考 Github 上的<a href="https://github.com/ATQQ/ewuit" target="_blank" rel="noreferrer">README</a></p>
<h2 id="能做什么" tabindex="-1">能做什么 <a class="header-anchor" href="#能做什么" aria-label="Permalink to “能做什么”">&#8203;</a></h2>
<h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to “背景”">&#8203;</a></h2>
<h2 id="功能实现" tabindex="-1">功能实现 <a class="header-anchor" href="#功能实现" aria-label="Permalink to “功能实现”">&#8203;</a></h2>
<h2 id="其它" tabindex="-1">其它 <a class="header-anchor" href="#其它" aria-label="Permalink to “其它”">&#8203;</a></h2>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[实现一个幽灵依赖扫描工具]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/node/phantom-dep-cli.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/node/phantom-dep-cli.html</guid>
            <pubDate>Sun, 15 May 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[# 实现一个幽灵依赖扫描工具

## 什么是幽灵依赖

**项目中使用了一些没有被定义在其 package.json 文件中的包。**

部分地方也被翻译成了”幻影依赖“，在英文文章中一般称为`phantom dependencies`

## 现状
在现有工程里，除 `pnpm` 外使用的最多的包管理工具就是 `yarn` 其次才是 `npm`。

后两者，在完成依赖安装后，都会有一个依赖提升的动作，也就是依赖的 `扁平化`。

于是装一个库 `vue`，不同包管理器的结果如下

|                                     npm                                     |                                    yarn                                     |                                    pnpm                                     |
| :]]></description>
            <content:encoded><![CDATA[<h1 id="实现一个幽灵依赖扫描工具" tabindex="-1">实现一个幽灵依赖扫描工具 <a class="header-anchor" href="#实现一个幽灵依赖扫描工具" aria-label="Permalink to “实现一个幽灵依赖扫描工具”">&#8203;</a></h1>
<h2 id="什么是幽灵依赖" tabindex="-1">什么是幽灵依赖 <a class="header-anchor" href="#什么是幽灵依赖" aria-label="Permalink to “什么是幽灵依赖”">&#8203;</a></h2>
<p><strong>项目中使用了一些没有被定义在其 package.json 文件中的包。</strong></p>
<p>部分地方也被翻译成了”幻影依赖“，在英文文章中一般称为<code>phantom dependencies</code></p>
<h2 id="现状" tabindex="-1">现状 <a class="header-anchor" href="#现状" aria-label="Permalink to “现状”">&#8203;</a></h2>
<p>在现有工程里，除 <code>pnpm</code> 外使用的最多的包管理工具就是 <code>yarn</code> 其次才是 <code>npm</code>。</p>
<p>后两者，在完成依赖安装后，都会有一个依赖提升的动作，也就是依赖的 <code>扁平化</code>。</p>
<p>于是装一个库 <code>vue</code>，不同包管理器的结果如下</p>
<table tabindex="0">
<thead>
<tr>
<th style="text-align:center">npm</th>
<th style="text-align:center">yarn</th>
<th style="text-align:center">pnpm</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="./phantom-dep-cli/MTY1MjYyNDkxNDc0OQ==652624914749.png" alt="图片" loading="lazy"></td>
<td style="text-align:center"><img src="./phantom-dep-cli/MTY1MjYwNDEyMzUwMQ==652604123501.png" alt="图片" loading="lazy"></td>
<td style="text-align:center"><img src="./phantom-dep-cli/MTY1MjYwNDIxODMwMA==652604218300.png" alt="图片" loading="lazy"></td>
</tr>
</tbody>
</table>
<p>由于依赖的<code>扁平化</code>，可以看到前两者会使 <code>node_modules</code> 中多出一些其它的东西</p>
<p>也由于这个特性，很多基于 <code>yarn</code> 的工程化方案，会将许多常用的依赖或者重要依赖去做一个版本的管控和依赖的收敛，于是项目里需要安装的依赖就少了，看上去就十分清晰。</p>
<p>比如安装<code>@xx/vue</code>，同时将相关的<code>lint</code>，<code>test-util</code>，<code>git hooks</code>，<code>lodash</code>，<code>xx-utils</code>等等包都做了安装，这样在工程里只需要装一个包就能使用这些包的能力。这也算是<code>幽灵依赖</code>的好处。</p>
<h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to “背景”">&#8203;</a></h2>
<h3 id="包管理工具切换pnpm" tabindex="-1">包管理工具切换pnpm <a class="header-anchor" href="#包管理工具切换pnpm" aria-label="Permalink to “包管理工具切换pnpm”">&#8203;</a></h3>
<p>随着项目的迭代时间越来越长，工程里的依赖包越来越多。依赖安装时间越来越长，即便有安装缓存，还是觉得非常的慢。于是有了换依赖管理工具的诉求。</p>
<p>一番调研后，选择把包管理工具切换为<code>pnpm</code>。</p>
<h3 id="为什么是-pnpm" tabindex="-1">为什么是 pnpm <a class="header-anchor" href="#为什么是-pnpm" aria-label="Permalink to “为什么是 pnpm”">&#8203;</a></h3>
<p>通过 pnpm <a href="https://www.pnpm.cn/benchmarks" target="_blank" rel="noreferrer">官方的测评数据</a> 可以看出，在大多数场景下</p>
<p>安装速度是 <code>npm/yarn</code> 的 <code>2-3</code>倍，一个项目就算节约<code>几十秒</code>，对于承载上前工程的<code>CI/CD</code>平台来说，几乎时时刻刻都存在发布的情况，每天的收益是很可观的。对于用户来说等待时间也大幅缩短。</p>
<h3 id="为什么做了这个工具" tabindex="-1">为什么做了这个工具 <a class="header-anchor" href="#为什么做了这个工具" aria-label="Permalink to “为什么做了这个工具”">&#8203;</a></h3>
<p>在<code>yarn</code>切换到<code>pnpm</code>,可以通过<code>pnpm import</code>指令实现lock文件的一键转换，避免依赖版本发生变更。</p>
<p>但由于<code>pnpm</code>没有依赖扁平化的动作，大部分项目切换后没发直接正常工作，主要原因就是<code>幽灵依赖</code></p>
<p>需要为pnpm项目单独添加<a href="https://www.pnpm.cn/npmrc#public-hoist-pattern" target="_blank" rel="noreferrer">依赖提升的配置</a></p>
<p>于是就需要一个扫描幽灵依赖的工具，协助做包管理工具的迁移。网上搜索了一番，没有找到能用的就只好自己🐴一个了。</p>
<h2 id="原理介绍" tabindex="-1">原理介绍 <a class="header-anchor" href="#原理介绍" aria-label="Permalink to “原理介绍”">&#8203;</a></h2>
<p>一图胜千言</p>
<p><img src="./phantom-dep-cli/MTY1MjYwODIzODM1NA==652608238354.png" alt="图片" loading="lazy"></p>
<p>总结下就是4步</p>
<ol>
<li>扫文件</li>
<li>提取导入资源路径</li>
<li>提取包名</li>
<li>剔除<code>package.json</code>中存在的</li>
</ol>
<h2 id="具体实现" tabindex="-1">具体实现 <a class="header-anchor" href="#具体实现" aria-label="Permalink to “具体实现”">&#8203;</a></h2>
<p>这里只贴几个关键步骤的代码，代码的组织逻辑即上述流程图所示</p>
<h3 id="获取扫描目标文件" tabindex="-1">获取扫描目标文件 <a class="header-anchor" href="#获取扫描目标文件" aria-label="Permalink to “获取扫描目标文件”">&#8203;</a></h3>
<p>这块利用<code>path</code>与<code>fs</code>模块配合即可实现</p>
<ul>
<li>使用<code>fs.readdirSync</code>读取文件列表，然后递归即可</li>
<li>通过文件后缀<code>ext</code>筛选出需要的文件</li>
</ul>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::tdctv7niyenbc9ir26m3p::--><code>type Exclude = string | RegExp

function scanDirFiles(
  dir: string,
  extList: string[] = [],
  exclude: Exclude | Exclude[] = [&#039;node_modules&#039;, &#039;.git&#039;, &#039;.vscode&#039;]
) {
  const files = readdirSync(dir, { withFileTypes: true })
  const res: string[] = []
  for (const file of files) {
    const filename = join(dir, file.name)
    if (isExclude(filename, exclude)) {
      continue
    }

    if (
      file.isFile() &amp;&amp;
      (extList.length === 0 || extList.includes(parse(filename).ext))
    ) {
      res.push(filename)
    }

    if (file.isDirectory()) {
      res.push(...scanDirFiles(filename, extList, exclude))
    }
  }
  return res
}

function isExclude(value: string, exclude: Exclude | Exclude[]) {
  const patterns = [exclude].flat()
  return patterns.find((v) =&gt;
    typeof v === &#039;string&#039; ? value.includes(v) : v.test(value)
  )
}</code></pre>
</div><p>调用示例</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::t4ofquavh44v298pebhyi::--><code>scanDirFiles(path.join(__dirname))
scanDirFiles(path.join(__dirname), [&#039;.ts&#039;])
scanDirFiles(path.join(__dirname), [&#039;.ts&#039;,&#039;.js&#039;], &#039;test&#039;)</code></pre>
</div><ul>
<li>js 系资源主要包含<code>.js</code>,<code>.jsx</code>,<code>.ts</code>,<code>.tsx</code>四类资源</li>
<li>css 系资源包含<code>.css</code>,<code>.scss</code>,<code>.less</code>,<code>.sass</code></li>
<li>vue 主要就是<code>.vue</code>
<ul>
<li>只需要把 <code>script</code> 和 <code>style</code>内容分别拆开处理即可</li>
</ul>
</li>
</ul>
<h3 id="js资源引入路径提取" tabindex="-1">JS资源引入路径提取 <a class="header-anchor" href="#js资源引入路径提取" aria-label="Permalink to “JS资源引入路径提取”">&#8203;</a></h3>
<p>这里使用 <a href="https://github.com/thx/gogocode" target="_blank" rel="noreferrer">gogocode</a> 操作AST，配合<a href="https://astexplorer.net/" target="_blank" rel="noreferrer">astexplorer</a>着使用，操作起来非常简单</p>
<p>导入模块的方式主要有以下4种</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::2d8el3o5kexwlkllzh9jia::--><code>const x = require(value)

const x = import(value)
const x = () =&gt; import(value)

import x from value
import value

export x from value</code></pre>
</div><p><code>import/export</code>提取</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::ar1uwsec3kftmefa6d4uhr::--><code>import AST, { GoGoAST } from &#039;gogocode&#039;

const sources: string[] = []
const ast = AST(fileText)

const callback = (node: GoGoAST) =&gt; {
  const importPath = node.attr(&#039;source.value&#039;) as string
  sources.push(importPath)
}
ast.find({ type: &#039;ImportDeclaration&#039; }).each(callback)
ast.find({ type: &#039;ExportNamedDeclaration&#039; }).each(callback)</code></pre>
</div><p><code>require/import()</code>提取</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::30nhj24vy7gulxgcfa5vg::--><code>const callback = (node: GoGoAST) =&gt; {
  const importPath = node.match[0][0]?.value
  sources.push(importPath)
}
// 处理import(&#039;&#039;)
ast.find(&#039;import($_$)&#039;).each(callback)
// 处理require(&#039;&#039;)
ast.find(&#039;require($_$)&#039;).each(callback)</code></pre>
</div><h3 id="css资源引入路径提取" tabindex="-1">CSS资源引入路径提取 <a class="header-anchor" href="#css资源引入路径提取" aria-label="Permalink to “CSS资源引入路径提取”">&#8203;</a></h3>
<p>针对css，只考虑<code>@import</code>场景的情况下，使用正则 <code>/^@import\s+['&quot;](.*)?['&quot;]/</code>即可实现提取</p>
<p><img src="./phantom-dep-cli/MTY1MjYxMDQwMjUxNw==652610402517.png" alt="图片" loading="lazy"></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::ylrv895zcrhzzv35vlf5bc::--><code>function getCssFileImportSource(fileText: string) {
  const sources: string[] = []
  const importRegexp = /^@import\s+[&#039;&quot;](.*)?[&#039;&quot;]/
  const lines = fileText.split(&#039;\n&#039;)
  for (const line of lines) {
    const match = line.trim().match(importRegexp)?.[1]
    if (match) {
      sources.push(match)
    }
  }
  return sources
}</code></pre>
</div><h3 id="vue文件中引入路径提取" tabindex="-1">Vue文件中引入路径提取 <a class="header-anchor" href="#vue文件中引入路径提取" aria-label="Permalink to “Vue文件中引入路径提取”">&#8203;</a></h3>
<p>一个<code>.vue</code>文件主要就 <code>template</code>, <code>script</code>, <code>style</code>三部分构成，只需要把<code>脚本</code>与<code>样式</code>拆开处理即可</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::2vobyvzohw2h7urdf9529r::--><code>import AST from &#039;gogocode&#039;

function getVueFileImportSource(fileText: string) {
  const sources: string[] = []
  // 目前发现Vue3 &lt;script lang=&quot;ts&quot; setup&gt; 的无法正常解析，所以在解析前先处理一下setup关键字
  const ast = AST(fileText.replace(/&lt;script(.*)setup(.*)&gt;/, &#039;&lt;script$1$2&gt;&#039;), {
    parseOptions: { language: &#039;vue&#039; }
  })

  // 提取script内容
  const script = ast.find(&#039;&lt;script&gt;&lt;/script&gt;&#039;).generate().trim()
  sources.push(...getJsFileImportSource(script))
  // css直接正则处理
  sources.push(...getCssFileImportSource(fileText))
  return sources
}</code></pre>
</div><h3 id="第三方依赖判断" tabindex="-1">第三方依赖判断 <a class="header-anchor" href="#第三方依赖判断" aria-label="Permalink to “第三方依赖判断”">&#8203;</a></h3>
<p>资源路径提取出来后，就只需要判断路径是否是node_modules下的资源即可了，流程如下</p>
<p><img src="./phantom-dep-cli/MTY1MjYyNDQ2ODAyNw==652624468027.png" alt="图片" loading="lazy"></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::gosftlem3oam7cmvv6nahq::--><code>import path, { parse } from &#039;path&#039;
import { existsSync } from &#039;fs&#039;
function isValidNodeModulesSource(
  filePath: string,
  importSourcePath: string
) {
  const { dir } = parse(filePath)
  if (!importSourcePath) {
    return false
  }
  if (importSourcePath.includes(&#039;node_modules&#039;)) {
    return true
  }
  if (
    [&#039;./&#039;, &#039;../&#039;, &#039;@/&#039;, &#039;~@/&#039;, &#039;`&#039;].some((prefix) =&gt;
      importSourcePath.startsWith(prefix)
    )
  ) {
    return false
  }
  if (
    [&#039;&#039;, ...cssExt, ...jsExt].some((ext) =&gt;
      existsSync(join(dir, `${importSourcePath}${ext}`))
    )
  ) {
    return false
  }
  return true
}</code></pre>
</div><h3 id="提取包名" tabindex="-1">提取包名 <a class="header-anchor" href="#提取包名" aria-label="Permalink to “提取包名”">&#8203;</a></h3>
<p>接下来就是从筛选出来的<code>有效资源路径</code>里提取出包名了，通常就两种场景<code>pkgName</code>和<code>@scope/pkgName</code>，通过几个常用的API就能搞定</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::krt8lcb5bnzb2iy8gtvsd::--><code>function getPkgNameBySourcePath(pkgPath: string) {
  const paths = pkgPath
    .replace(/~/g, &#039;&#039;)
    .replace(/.*node_modules\//, &#039;&#039;)
    .split(&#039;/&#039;)
  return paths[0].startsWith(&#039;@&#039;) ? paths.slice(0, 2).join(&#039;/&#039;) : paths[0]
}</code></pre>
</div><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::699fxc72mlldy55xs08voc::--><code>test(&#039;getPkgNameBySourcePath&#039;, () =&gt; {
  expect(getPkgNameBySourcePath(&#039;fs&#039;)).toBe(&#039;fs&#039;)
  expect(getPkgNameBySourcePath(&#039;@vue/ssr&#039;)).toBe(&#039;@vue/ssr&#039;)
  expect(getPkgNameBySourcePath(&#039;vue/dist/index.js&#039;)).toBe(&#039;vue&#039;)
  expect(getPkgNameBySourcePath(&#039;../node_modules/vue&#039;)).toBe(&#039;vue&#039;)
  expect(getPkgNameBySourcePath(&#039;~@element/ui/dist/index.css&#039;)).toBe(
    &#039;@element/ui&#039;
  )
})</code></pre>
</div><h3 id="过滤掉不合法的包名" tabindex="-1">过滤掉不合法的包名 <a class="header-anchor" href="#过滤掉不合法的包名" aria-label="Permalink to “过滤掉不合法的包名”">&#8203;</a></h3>
<p>上述规则不能涵盖到所有情况，取到的包名可能有不合法的如<code>this.xxx</code>,<code>xx.resolve(yyy)</code>,<code>Node内置的包 fs/path/process/...etc</code></p>
<p>针对Node内置的包可以直接写个正则搞定,当然这段正则来源于<code>Copilot</code>推荐</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::zm6aqaw0v7m88f40i8kv8v::--><code>function isNodeLib(v: string) {
  return /^(?:assert|buffer|child_process|cluster|console|constants|crypto|dgram|dns|domain|events|fs|http|https|module|net|os|path|punycode|querystring|readline|repl|stream|string_decoder|sys|timers|tls|tty|url|util|vm|zlib)$/.test(
    v
  )
}</code></pre>
</div><p>当然也有现成的第三方包可以直接使用 <a href="https://www.npmjs.com/package/validate-npm-package-name" target="_blank" rel="noreferrer">validate-npm-package-name</a> ,这个是官方出品的，用法也就更加简单了</p>
<ul>
<li>不仅仅能过滤掉Node内置包，还能过滤掉不合法命名的包</li>
</ul>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::celibunj81sy3kkw0qtk7g::--><code>import validPkgName from &#039;validate-npm-package-name&#039;

function isValidPkgName(pkgName: string): boolean {
  const { validForNewPackages, validForOldPackages} = validPkgName(pkgName)

  return validForNewPackages
}</code></pre>
</div><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::d43tomlkzikh1zsgkiarwu::--><code>test(&#039;isValidPkgName&#039;, () =&gt; {
  expect(isValidPkgName(&#039;vue&#039;)).toBe(true)
  expect(isValidPkgName(&#039;some-package&#039;)).toBe(true)
  expect(isValidPkgName(&#039;@jane/foo.js&#039;)).toBe(true)
  expect(isValidPkgName(&#039;r.resolve(&quot;custom-token.js&quot;)&#039;)).toBe(false)
  expect(isValidPkgName(&#039;dayjs/dsds/abc.js&#039;)).toBe(false)
})</code></pre>
</div><p>关键一系列方法搞定后，只需要进行逻辑的组织即可，<a href="https://github.com/ATQQ/tools/blob/8e0a79d093b3f03a47adff4d7fc0569f19a398e4/packages/cli/ghost/src/util/index.ts#L15-L81" target="_blank" rel="noreferrer">Github查看最终方法源码</a></p>
<h2 id="上手体验" tabindex="-1">上手体验 <a class="header-anchor" href="#上手体验" aria-label="Permalink to “上手体验”">&#8203;</a></h2>
<p>已将最终实现整成了<code>npm</code>包<code>@sugarat/ghost</code>，项目可引入直接使用</p>
<p>为什么叫<code>ghost</code>而不是<code>phantom</code>？可能大家对<code>ghost</code>👻这个单词的意思更加熟悉一些</p>
<h3 id="cli-工具" tabindex="-1">CLI 工具 <a class="header-anchor" href="#cli-工具" aria-label="Permalink to “CLI 工具”">&#8203;</a></h3>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::catfywo8gpi6ylfiz1phxf::--><code>npm i -g @sugarat/ghost

# default scan src
ghost scan</code></pre>
</div><h3 id="项目中调用" tabindex="-1">项目中调用 <a class="header-anchor" href="#项目中调用" aria-label="Permalink to “项目中调用”">&#8203;</a></h3>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::nrx6or817ddmcllb7l3j2::--><code>npm i @sugarat/ghost
# or
yarn add @sugarat/ghost
# or
pnpm add @sugarat/ghost</code></pre>
</div><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::g08dcly66w5cym5ls0fzvm::--><code>import { findGhost } from &#039;@sugarat/ghost&#039;
// or
import { findPhantom } from &#039;@sugarat/ghost&#039;</code></pre>
</div><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::ykkads3zy8g0lb3a5zz9bb::--><code>const phantomDependency = findGhost(
  path.join(__dirname, &#039;src&#039;),
  path.join(process.cwd(), &#039;package.json&#039;)
)</code></pre>
</div><h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p><code>pnpm</code> 是个好东西，推荐大家可以用起来了</p>
<p>欢迎评论区交流指正，有 <code>case</code> 可以抛出来帮助工具完善得更好</p>
<ul>
<li><a href="https://github.com/ATQQ/tools/tree/main/packages/cli/ghost" target="_blank" rel="noreferrer">项目完整源码</a></li>
</ul>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/phantom-dep-cli/MTY1MjYyNDkxNDc0OQ==652624914749.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[Node侧实现内容压缩(gzip/br/deflate)介绍与实践]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/node/compress-response.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/node/compress-response.html</guid>
            <pubDate>Sat, 05 Mar 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[背景
在查看自己的应用日志时，发现进入日志页面后总是要几秒钟才会加载（接口没做分页），于是打开网络面板查看
这才发现接口返回的数据都没有被压缩，本以为接口用Nginx反向代理了，Nginx会自动帮我做]]></description>
            <content:encoded><![CDATA[<h1 id="node侧实现内容压缩-gzip-br-deflate-介绍与实践" tabindex="-1">Node侧实现内容压缩(gzip/br/deflate)介绍与实践 <a class="header-anchor" href="#node侧实现内容压缩-gzip-br-deflate-介绍与实践" aria-label="Permalink to “Node侧实现内容压缩(gzip/br/deflate)介绍与实践”">&#8203;</a></h1>
<h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to “背景”">&#8203;</a></h2>
<p>在查看自己的<a href="https://ep2.sugarat.top/" target="_blank" rel="noreferrer">应用</a>日志时，发现进入日志页面后总是要几秒钟才会加载（接口没做分页），于是打开网络面板查看</p>
<p><img src="./compress-response/MTY0NjExMjc0NTg3Nw==646112745877.png" alt="图片" loading="lazy"></p>
<p><img src="./compress-response/MTY0NjExMjc1NzE2OA==646112757168.png" alt="图片" loading="lazy"></p>
<p>这才发现接口返回的数据都没有被压缩，本以为接口用Nginx反向代理了，Nginx会自动帮我做这一层（这块后面探究一下，理论上是可行的）</p>
<p>这里的后端是 Node 服务</p>
<p>本文就分享一下 <code>HTTP数据压缩</code>相关知识以及笔者的在<code>Node侧的实践</code></p>
<h2 id="前置知识" tabindex="-1">前置知识 <a class="header-anchor" href="#前置知识" aria-label="Permalink to “前置知识”">&#8203;</a></h2>
<blockquote>
<p>下面的客户端均指浏览器</p>
</blockquote>
<h3 id="accept-encoding" tabindex="-1">accept-encoding <a class="header-anchor" href="#accept-encoding" aria-label="Permalink to “accept-encoding”">&#8203;</a></h3>
<p><img src="./compress-response/MTY0NjExMzE0NjMyNQ==646113146325.png" alt="accept-encoding" loading="lazy"></p>
<p>客户端在向服务端发起请求时，会在请求头(request header)中添加<code>accept-encoding</code>字段，其值标明客户端<code>支持的压缩内容编码</code>格式</p>
<h3 id="content-encoding" tabindex="-1">content-encoding <a class="header-anchor" href="#content-encoding" aria-label="Permalink to “content-encoding”">&#8203;</a></h3>
<p><img src="./compress-response/MTY0NjExMzI0OTczMQ==646113249731.png" alt="content-encoding" loading="lazy"></p>
<p>服务端在对返回内容执行压缩后，通过在响应头（response header）中添加<code>content-encoding</code>，来告诉浏览器内容<code>实际压缩使用的编码算法</code></p>
<h3 id="deflate-gzip-br" tabindex="-1">deflate/gzip/br <a class="header-anchor" href="#deflate-gzip-br" aria-label="Permalink to “deflate/gzip/br”">&#8203;</a></h3>
<p><code>deflate</code>是同时使用了<code>LZ77</code>算法与<code>哈夫曼编码（Huffman Coding）</code>的一个无损数据压缩算法。</p>
<p><code>gzip</code> 是基于 <code>DEFLATE</code> 的算法</p>
<p><code>br</code>指代<code>Brotli</code>，该数据格式旨在进一步提高压缩比，对文本的压缩相对<code>deflate</code>能增加<code>20%</code>的压缩密度，而其压缩与解压缩速度则大致不变</p>
<h2 id="zlib模块" tabindex="-1">zlib模块 <a class="header-anchor" href="#zlib模块" aria-label="Permalink to “zlib模块”">&#8203;</a></h2>
<p>Node.js包含一个<code>zlib 模块</code>，提供了使用 <code>Gzip</code>、<code>Deflate/Inflate</code>、以及 <code>Brotli</code> 实现的压缩功能</p>
<p>这里以<code>gzip</code>为例分场景列举多种使用方式，<code>Deflate/Inflate</code>与<code>Brotli</code>使用方式一样，只是API不一样</p>
<p><strong>基于<code>stream</code>的操作</strong></p>
<p><img src="./compress-response/MTY0NjQ2NjMwMzA4MA==646466303080.png" alt="基于的操作" loading="lazy"></p>
<p><strong>基于<code>buffer</code>的操作</strong></p>
<p><img src="./compress-response/MTY0NjQ2NjY4NDUyMw==646466684523.png" alt="基于的操作" loading="lazy"></p>
<p>引入几个所需的模块</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::w5umahurygk4peduf0pdz::--><code>const zlib = require(&#039;zlib&#039;)
const fs = require(&#039;fs&#039;)
const stream = require(&#039;stream&#039;)
const testFile = &#039;tests/origin.log&#039;
const targetFile = `${testFile}.gz`
const decodeFile = `${testFile}.un.gz`</code></pre>
</div><h2 id="文件的解-压缩" tabindex="-1">文件的解/压缩 <a class="header-anchor" href="#文件的解-压缩" aria-label="Permalink to “文件的解/压缩”">&#8203;</a></h2>
<p>解/压缩结果查看，这里使用<code>du</code>指令直接统计解压缩前后结果</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::sskv0632emxbn8cu6yy4o::--><code># 执行
du -ah tests

# 结果如下
108K    tests/origin.log.gz
2.2M    tests/origin.log
2.2M    tests/origin.log.un.gz
4.6M    tests</code></pre>
</div><h3 id="基于流-stream-的操作" tabindex="-1">基于<code>流(stream)</code>的操作 <a class="header-anchor" href="#基于流-stream-的操作" aria-label="Permalink to “基于流(stream)的操作”">&#8203;</a></h3>
<p>使用<code>createGzip</code>与<code>createUnzip</code></p>
<ul>
<li>注：所有 <code>zlib</code> API，除了那些显式同步的 API，都使用 Node.js 内部线程池，可以看做是异步的</li>
<li>因此下面的示例中的压缩和解压代码应分开执行，否则会报错</li>
</ul>
<p><strong>方式1：</strong> 直接利用实例上的<code>pipe</code>方法传递流</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::scqjtn9gspgzkffepwst5e::--><code>// 压缩
const readStream = fs.createReadStream(testFile)
const writeStream = fs.createWriteStream(targetFile)
readStream.pipe(zlib.createGzip()).pipe(writeStream)

// 解压
const readStream = fs.createReadStream(targetFile)
const writeStream = fs.createWriteStream(decodeFile)
readStream.pipe(zlib.createUnzip()).pipe(writeStream)</code></pre>
</div><p><strong>方式2：</strong> 利用<code>stream</code>上的<code>pipeline</code>，可在回掉中单独做其它的处理</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::p43wo0rqius9orien9895t::--><code>// 压缩
const readStream = fs.createReadStream(testFile)
const writeStream = fs.createWriteStream(targetFile)
stream.pipeline(readStream, zlib.createGzip(), writeStream, err =&gt; {
    if (err) {
        console.error(err);
    }
})

// 解压
const readStream = fs.createReadStream(targetFile)
const writeStream = fs.createWriteStream(decodeFile)
stream.pipeline(readStream, zlib.createUnzip(), writeStream, err =&gt; {
    if (err) {
        console.error(err);
    }
})</code></pre>
</div><p><strong>方式3：</strong> Promise化<code>pipeline</code>方法</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::xwpyro72krpqbnbey56qks::--><code>const { promisify } = require(&#039;util&#039;)
const pipeline = promisify(stream.pipeline)

// 压缩
const readStream = fs.createReadStream(testFile)
const writeStream = fs.createWriteStream(targetFile)
pipeline(readStream, zlib.createGzip(), writeStream)
    .catch(err =&gt; {
        console.error(err);
    })

// 解压
const readStream = fs.createReadStream(targetFile)
const writeStream = fs.createWriteStream(decodeFile)
pipeline(readStream, zlib.createUnzip(), writeStream)
    .catch(err =&gt; {
        console.error(err);
    })</code></pre>
</div><h3 id="基于buffer的操作" tabindex="-1">基于<code>Buffer</code>的操作 <a class="header-anchor" href="#基于buffer的操作" aria-label="Permalink to “基于Buffer的操作”">&#8203;</a></h3>
<p>利用 <code>gzip</code> 与 <code>unzip</code> API，这两个方法包含<code>同步</code>与<code>异步</code>类型</p>
<ul>
<li>压缩
<ul>
<li><code>gzip</code></li>
<li><code>gzipSync</code></li>
</ul>
</li>
<li>解压
<ul>
<li><code>unzip</code></li>
<li><code>unzipSync</code></li>
</ul>
</li>
</ul>
<p><strong>方式1：</strong> 将<code>readStream</code>转<code>Buffer</code>,然后进行进一步操作</p>
<ul>
<li>gzip：异步</li>
</ul>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::xa1ryb2xgmo70q7p77djhr::--><code>// 压缩
const buff = []
readStream.on(&#039;data&#039;, (chunk) =&gt; {
    buff.push(chunk)
})
readStream.on(&#039;end&#039;, () =&gt; {
    zlib.gzip(Buffer.concat(buff), targetFile, (err, resBuff) =&gt; {
        if(err){
            console.error(err);
            process.exit()
        }
        fs.writeFileSync(targetFile,resBuff)
    })
})</code></pre>
</div><ul>
<li>gzipSync：同步</li>
</ul>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::rxj3fmm2l6x34uqk0ed9::--><code>// 压缩
const buff = []
readStream.on(&#039;data&#039;, (chunk) =&gt; {
    buff.push(chunk)
})
readStream.on(&#039;end&#039;, () =&gt; {
    fs.writeFileSync(targetFile,zlib.gzipSync(Buffer.concat(buff)))
})</code></pre>
</div><p><strong>方式2：</strong> 直接通过<code>readFileSync</code>读取</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::mpylqvrgobbrk9fq98et7::--><code>// 压缩
const readBuffer = fs.readFileSync(testFile)
const decodeBuffer = zlib.gzipSync(readBuffer)
fs.writeFileSync(targetFile,decodeBuffer)

// 解压
const readBuffer = fs.readFileSync(targetFile)
const decodeBuffer = zlib.gzipSync(decodeFile)
fs.writeFileSync(targetFile,decodeBuffer)</code></pre>
</div><h2 id="文本内容的解-压缩" tabindex="-1">文本内容的解/压缩 <a class="header-anchor" href="#文本内容的解-压缩" aria-label="Permalink to “文本内容的解/压缩”">&#8203;</a></h2>
<p>除了对文件压缩，有时候也许要对传输的内容进行直接进行解压缩</p>
<p>这里以压缩文本内容为例</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::6zakzm5brhhbmqr7wc5gya::--><code>// 测试数据
const testData = fs.readFileSync(testFile, { encoding: &#039;utf-8&#039; })</code></pre>
</div><h3 id="基于流-stream-操作" tabindex="-1">基于<code>流(stream)</code>操作 <a class="header-anchor" href="#基于流-stream-操作" aria-label="Permalink to “基于流(stream)操作”">&#8203;</a></h3>
<p>这块就考虑 <code>string</code> =&gt;  <code>buffer</code> =&gt; <code>stream</code>的转换就行</p>
<p><code>string</code> =&gt;  <code>buffer</code></p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::2ug31j1wvr264zkwrok8ki::--><code>const buffer = Buffer.from(testData)</code></pre>
</div><p><code>buffer</code> =&gt; <code>stream</code></p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::9xt0pk7s1s5kgioad0j9v::--><code>const transformStream = new stream.PassThrough()
transformStream.write(buffer)

// or
const transformStream = new stream.Duplex()
transformStream.push(Buffer.from(testData))
transformStream.push(null)</code></pre>
</div><p>这里以写入到文件示例，当然也可以写到其它的流里，如<code>HTTP的Response</code>（后面会单独介绍）</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::imfts2oso19pykq6s0r4w::--><code>transformStream
    .pipe(zlib.createGzip())
    .pipe(fs.createWriteStream(targetFile))</code></pre>
</div><h3 id="基于buffer操作" tabindex="-1">基于<code>Buffer</code>操作 <a class="header-anchor" href="#基于buffer操作" aria-label="Permalink to “基于Buffer操作”">&#8203;</a></h3>
<p>同样利用<code>Buffer.from</code>将字符串转<code>buffer</code></p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::pjas99u34agakcr4d1hf6::--><code>const buffer = Buffer.from(testData)</code></pre>
</div><p>然后直接使用同步API进行转换，这里result就是压缩后的内容</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::87qq1r6j0ubc71q77d9z2p::--><code>const result = zlib.gzipSync(buffer)</code></pre>
</div><p>可以写入文件，在<code>HTTP Server</code>中也可直接对压缩后的内容进行返回</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::i3fo07vk7sfaagz1wt4ccc::--><code>fs.writeFileSync(targetFile, result)</code></pre>
</div><h2 id="node-server中的实践" tabindex="-1">Node Server中的实践 <a class="header-anchor" href="#node-server中的实践" aria-label="Permalink to “Node Server中的实践”">&#8203;</a></h2>
<p>这里直接使用Node中 <code>http</code> 模块创建一个简单的 Server 进行演示</p>
<p>在其他的 <code>Node Web</code> 框架中，处理思路类似，当然一般也有现成的插件，一键接入</p>
<p><img src="./compress-response/MTY0NjUzMzExNDE3OQ==646533114179.png" alt="运行结果" loading="lazy"></p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::sfps74j8ys51yi3ky0lmu::--><code>const http = require(&#039;http&#039;)
const { PassThrough, pipeline } = require(&#039;stream&#039;)
const zlib = require(&#039;zlib&#039;)

// 测试数据
const testTxt = &#039;测试数据123&#039;.repeat(1000)

const app = http.createServer((req, res) =&gt; {
    const { url } = req
    // 读取支持的压缩算法
    const acceptEncoding = req.headers[&#039;accept-encoding&#039;].match(/(br|deflate|gzip)/g)

    // 默认响应的数据类型
    res.setHeader(&#039;Content-Type&#039;, &#039;application/json; charset=utf-8&#039;)

    // 几个示例的路由
    const routes = [
        [&#039;/gzip&#039;, () =&gt; {
            if (acceptEncoding.includes(&#039;gzip&#039;)) {
                res.setHeader(&#039;content-encoding&#039;, &#039;gzip&#039;)
                // 使用同步API直接压缩文本内容
                res.end(zlib.gzipSync(Buffer.from(testTxt)))
                return
            }
            res.end(testTxt)
        }],
        [&#039;/deflate&#039;, () =&gt; {
            if (acceptEncoding.includes(&#039;deflate&#039;)) {
                res.setHeader(&#039;content-encoding&#039;, &#039;deflate&#039;)
                // 基于流的单次操作
                const originStream = new PassThrough()
                originStream.write(Buffer.from(testTxt))
                originStream.pipe(zlib.createDeflate()).pipe(res)
                originStream.end()
                return
            }
            res.end(testTxt)
        }],
        [&#039;/br&#039;, () =&gt; {
            if (acceptEncoding.includes(&#039;br&#039;)) {
                res.setHeader(&#039;content-encoding&#039;, &#039;br&#039;)
                res.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=utf-8&#039;)
                // 基于流的多次写操作
                const originStream = new PassThrough()
                pipeline(originStream, zlib.createBrotliCompress(), res, (err) =&gt; {
                    if (err) {
                        console.error(err);
                    }
                })
                originStream.write(Buffer.from(&#039;&lt;h1&gt;BrotliCompress&lt;/h1&gt;&#039;))
                originStream.write(Buffer.from(&#039;&lt;h2&gt;测试数据&lt;/h2&gt;&#039;))
                originStream.write(Buffer.from(testTxt))
                originStream.end()
                return
            }
            res.end(testTxt)
        }]
    ]
    const route = routes.find(v =&gt; url.startsWith(v[0]))
    if (route) {
        route[1]()
        return
    }

    // 兜底
    res.setHeader(&#039;Content-Type&#039;, &#039;text/html; charset=utf-8&#039;)
    res.end(`&lt;h1&gt;404: ${url}&lt;/h1&gt;
    &lt;h2&gt;已注册路由&lt;/h2&gt;
    &lt;ul&gt;
        ${routes.map(r =&gt; `&lt;li&gt;&lt;a href=&quot;${r[0]}&quot;&gt;${r[0]}&lt;/a&gt;&lt;/li&gt;`).join(&#039;&#039;)}
    &lt;/ul&gt;
    `)
    res.end()
})

app.listen(3000)</code></pre>
</div><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to “参考”">&#8203;</a></h2>
<ul>
<li><a href="https://juejin.cn/post/6844903618441641991#heading-2" target="_blank" rel="noreferrer">掘金:Node.js 流（stream）：你需要知道的一切</a></li>
<li><a href="https://juejin.cn/post/6844904062974951437#heading-1" target="_blank" rel="noreferrer">掘金:Node.js实战--资源压缩与zlib模块</a></li>
<li><a href="https://segmentfault.com/a/1190000009374437" target="_blank" rel="noreferrer">segmentfault:使用Brotli提高网站访问速度</a></li>
<li><a href="https://tech.meituan.com/2021/01/07/pack-gzip-zstd-lz4.html" target="_blank" rel="noreferrer">美团技术团队:速度与压缩比如何兼得？压缩算法在构建部署中的优化</a></li>
<li><a href="http://nodejs.cn/api/zlib.html#zlib" target="_blank" rel="noreferrer">Node.js v16.14.0 文档:zlib</a></li>
<li><a href="https://github.com/ayqy/string-to-file-stream/blob/2f43145ca9515345fb0b9b697414bcfd0effe276/index.js" target="_blank" rel="noreferrer">Github:ayqy/string-to-file-stream</a></li>
</ul>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/compress-response/MTY0NjExMjc0NTg3Nw==646112745877.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[配置SSH免密登录服务器]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/ssh-no-pwd-login.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/ssh-no-pwd-login.html</guid>
            <pubDate>Sat, 12 Feb 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[最近服务器从阿里云换到了腾讯云，需要把服务进行一次整体的迁移
为了方便资源的部署，需要配置一下SSH的免密登录，避免频繁的输入密码
 取得本地公钥
先查看本地是否存在`id_rsa.pub`文件
``]]></description>
            <content:encoded><![CDATA[<h1 id="本地配置ssh免密远程登录服务器" tabindex="-1">本地配置SSH免密远程登录服务器 <a class="header-anchor" href="#本地配置ssh免密远程登录服务器" aria-label="Permalink to “本地配置SSH免密远程登录服务器”">&#8203;</a></h1>
<p>最近服务器从阿里云换到了腾讯云，需要把服务进行一次整体的迁移</p>
<p>为了方便资源的部署，需要配置一下SSH的免密登录，避免频繁的输入密码</p>
<h2 id="取得本地公钥" tabindex="-1">取得本地公钥 <a class="header-anchor" href="#取得本地公钥" aria-label="Permalink to “取得本地公钥”">&#8203;</a></h2>
<p>先查看本地是否存在<code>id_rsa.pub</code>文件</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::e0865ex848sh6wou87je9s::--><code>ls ~/.ssh</code></pre>
</div><p>不存在可以通过如下指令创建（一路回车即可）</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::w9bsxync3s8rjo3mgkk3bt::--><code>ssh-keygen -t rsa</code></pre>
</div><h2 id="服务器添加信任" tabindex="-1">服务器添加信任 <a class="header-anchor" href="#服务器添加信任" aria-label="Permalink to “服务器添加信任”">&#8203;</a></h2>
<h3 id="上传公钥" tabindex="-1">上传公钥 <a class="header-anchor" href="#上传公钥" aria-label="Permalink to “上传公钥”">&#8203;</a></h3>
<p>将本地公钥上传到远程服务器</p>
<ul>
<li>其中 <code>$host</code>换成目标服务器绑定的 <strong>域名</strong> 或 <strong>IP</strong> 即可</li>
</ul>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::h2onks48vp49sh50ulhcg::--><code>scp ~/.ssh/id_rsa.pub root@$host:~/

# 如
scp ~/.ssh/id_rsa.pub root@baidu.com:~/
scp ~/.ssh/id_rsa.pub root@39.156.66.18:~/</code></pre>
</div><h3 id="添加信任" tabindex="-1">添加信任 <a class="header-anchor" href="#添加信任" aria-label="Permalink to “添加信任”">&#8203;</a></h3>
<p>先检查服务器上是<code>root</code>用户是否存在<code>.ssh</code>目录</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::gvsl30hbrqiof7nvshyanr::--><code>ssh -p22 root@$host &quot;ls -al&quot;</code></pre>
</div><p>不存在则运行上述一样的方式进行创建</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::ub11l8blx3hw8bnlouc33::--><code>ssh -p22 root@$host &quot;ssh-keygen -t rsa&quot;</code></pre>
</div><p>添加信任</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::hsuy806zkx4ue985p30h5e::--><code>ssh -p22 root@$host &quot;cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys&quot;</code></pre>
</div><h2 id="重启ssh" tabindex="-1">重启ssh <a class="header-anchor" href="#重启ssh" aria-label="Permalink to “重启ssh”">&#8203;</a></h2>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::r89r64vl4ireqecsch12t9::--><code>ssh -p22 root@$host &quot;service sshd restart&quot;</code></pre>
</div><h2 id="免密登录root" tabindex="-1">免密登录root <a class="header-anchor" href="#免密登录root" aria-label="Permalink to “免密登录root”">&#8203;</a></h2>
<p>配置完成后即可进行免密登录</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::tcb5j705zaksxume7cosyf::--><code>ssh root@$host</code></pre>
</div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[新年快乐，虎虎生威]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/_configDoc/newyear/2022.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/_configDoc/newyear/2022.html</guid>
            <pubDate>Mon, 31 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[给大家送上`红包封面`和`红包`
新的一年祝大家新年快乐，虎年大吉，虎虎生威，如虎添翼，恭喜发财，财源滚滚
微信`扫码领取`红包`封面`
支付宝搜索`红包`,选择`收口令红包`
输入`粥里有勺糖01`]]></description>
            <content:encoded><![CDATA[<h1 id="新年快乐-虎虎生威" tabindex="-1">新年快乐，虎虎生威 <a class="header-anchor" href="#新年快乐-虎虎生威" aria-label="Permalink to “新年快乐，虎虎生威”">&#8203;</a></h1>
<p>给大家送上<code>红包封面</code>和<code>红包</code></p>
<p>新的一年祝大家新年快乐，虎年大吉，虎虎生威，如虎添翼，恭喜发财，财源滚滚</p>
<p>微信<code>扫码领取</code>红包<code>封面</code></p>
<p><img src="https://img.cdn.sugarat.top/mdImg/MTY0MzYzMTQ2MjY5OQ==643631462699" alt="图片" loading="lazy"></p>
<p>支付宝搜索<code>红包</code>,选择<code>收口令红包</code></p>
<p><img src="https://img.cdn.sugarat.top/mdImg/MTY0MzYzMTg5MDgzNA==643631890834" alt="图片" loading="lazy"></p>
<p>输入<code>粥里有勺糖01</code>领取<code>红包</code></p>
<p><img src="https://img.cdn.sugarat.top/mdImg/MTY0MzcyMDEyMzQyMw==643720123423" alt="图片" loading="lazy"></p>
]]></content:encoded>
            <enclosure url="https://img.cdn.sugarat.top/mdImg/MTY0MzYzMTQ2MjY5OQ==643631462699" length="0" type="image//mdImg/MTY0MzYzMTQ2MjY5OQ==643631462699"/>
        </item>
        <item>
            <title><![CDATA[移动端阻止弹窗下层页面被滑动]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/fixed-page.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/fixed-page.html</guid>
            <pubDate>Sat, 22 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[移动端阻止弹窗下层页面被滑动
在做H5开发时，很多场景下都需要弹窗
当出现弹窗时，大部分场景下是期望弹窗下层页面不能被滑动的
当然也不期望弹窗被滑动
近期肝页面又碰到了这个问题
下面介绍几种最常用的方]]></description>
            <content:encoded><![CDATA[<h1 id="移动端阻止弹窗下层页面被滑动" tabindex="-1">移动端阻止弹窗下层页面被滑动 <a class="header-anchor" href="#移动端阻止弹窗下层页面被滑动" aria-label="Permalink to “移动端阻止弹窗下层页面被滑动”">&#8203;</a></h1>
<p>在做H5开发时，很多场景下都需要弹窗</p>
<p>当出现弹窗时，大部分场景下是期望弹窗下层页面不能被滑动的</p>
<p>当然也不期望弹窗被滑动</p>
<p>近期肝页面又碰到了这个问题</p>
<p>下面介绍几种最常用的方式，以及一些边界情况与应对策略</p>
<h2 id="overflow-hidden" tabindex="-1">overflow:hidden <a class="header-anchor" href="#overflow-hidden" aria-label="Permalink to “overflow:hidden”">&#8203;</a></h2>
<p>流传最广的方式就是 给元素设置 <code>overflow:hidden</code></p>
<p>给<code>body</code>设置，就能达到阻止页面滑动的目的</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::oz2mgrksycxcgsk7vv1qa::--><code>document.body.style.overflow = &#039;hidden&#039;
document.body.style.overflow = &#039;visible&#039;</code></pre>
</div><p>大部分情况下这个是能有效果的</p>
<p>但在<code>部分机器上，这个是不生效的</code>:</p>
<h2 id="弹窗遮罩" tabindex="-1">弹窗遮罩 <a class="header-anchor" href="#弹窗遮罩" aria-label="Permalink to “弹窗遮罩”">&#8203;</a></h2>
<p>还有一种情况如下，<code>页面部分元素有局部滑动</code></p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::p4q91yg4vvq4w6su6eqm7u::--><code>&lt;body style=&quot;overflow:hidden;&quot;&gt;
  &lt;div style=&quot;overflow:scroll;height:100%;&quot;&gt;
    &lt;!-- more element --&gt;
  &lt;/div&gt;
&lt;/body&gt;</code></pre>
</div><p>当前情况给<code>body</code>设置 <code>overflow:hidden</code>依旧是无效果的</p>
<p>此时给弹窗加上遮罩如下，正常情况下，下层元素就不会收到<code>touchmove</code>事件</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::igeq784i0tmzl5b5so8be::--><code>&lt;body style=&quot;overflow:hidden;&quot;&gt;
  &lt;div style=&quot;overflow:scroll;height:100%;&quot;&gt;
    &lt;!-- more element --&gt;
  &lt;/div&gt;

  &lt;!-- dialog --&gt;
  &lt;div class=&quot;dialog&quot;&gt;
    &lt;!-- 遮罩 --&gt;
    &lt;div class=&quot;mask&quot; style=&quot;position:fixed;inset:0;&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;</code></pre>
</div><p>其中<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/inset" target="_blank" rel="noreferrer">inset</a>属性是<code>left,top,right,bottom</code>的简写</p>
<p>但在部分机型下，下层元素仍然会收到<code>touchmove</code>事件，因此会跟着滑动</p>
<p>于是需要祭出下面的方法</p>
<h2 id="prevent-touchmove" tabindex="-1">prevent touchmove <a class="header-anchor" href="#prevent-touchmove" aria-label="Permalink to “prevent touchmove”">&#8203;</a></h2>
<p>阻止触摸滑动事件<code>touchmove</code>的默认行为</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::b0t7x0c8az4jwxkmwf99gf::--><code>const touchHandle = function(e) {
  e.preventDefault()
}

// 弹窗的事件
{
  onShow(){
    document.body.addEventListener(&#039;touchmove&#039;, preventDefault, {
      passive: false,
    });
  },
  onHide(){
    document.body.removeEventListener(&#039;touchmove&#039;, preventDefault);
  }
}</code></pre>
</div><p>在弹窗打开时直接阻止目标元素的滑动事件的默认行为</p>
<p>弹窗内容是不可滑动的话，那么这种方法是最省事高效的</p>
<p>如果弹窗中有可滑动的内容，且滑动的内容比较复杂</p>
<p>那么通过<code>touchmove</code>去细力度的控制阻止滑动事件时就很麻烦</p>
<h2 id="position-fixed" tabindex="-1">position:fixed <a class="header-anchor" href="#position-fixed" aria-label="Permalink to “position:fixed”">&#8203;</a></h2>
<p>还有一种常用的就是<code>position:fixed</code></p>
<p>在弹窗打开时，将目标元素进行固定，在关闭时恢复</p>
<p>由于定位会改变元素在页面上的位置，所以需要再<code>fixed</code>前记录元素的位置</p>
<p>取消<code>fixed</code>之后将元素又滚动到原来的位置</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::gq81106hflarzsz6mvup6r::--><code>// 弹窗的事件
{
  onShow(){
    document.body.style.top = `${
      document.body.getClientRects()[0].top
    }px`;
    document.body.style.position = &#039;fixed&#039;;
    document.body.style.left = &#039;0&#039;;
    document.body.style.right = &#039;0&#039;;
  },
  onHide(){
    document.body.style.position = &#039;visible&#039;;
    window.scrollTo(
      0,
      Math.abs(+document.body.style.top.replace(&#039;px&#039;, &#039;&#039;))
    );
  }
}</code></pre>
</div><h2 id="使用class代替style" tabindex="-1">使用class代替style <a class="header-anchor" href="#使用class代替style" aria-label="Permalink to “使用class代替style”">&#8203;</a></h2>
<p>这个也是碰巧发现的，在<code>iOS</code>低端机将上述方式都尝试后</p>
<p>仍发现一个问题，现象如下（TODO：补图）</p>
<p>下层页面不会被滑动了，但遮罩和弹窗整体还能被下拉</p>
<p>弹窗是一个下拉列表弹窗，其出现的位置需要动态的计算，如下结构</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::fbl08kgcmxmcnvuyvwg82i::--><code>&lt;body style=&quot;overflow:hidden;&quot;&gt;
  &lt;!-- dialog --&gt;
  &lt;div class=&quot;dialog&quot; style=&quot;top:88px;&quot;&gt;
    &lt;!-- 遮罩 --&gt;
    &lt;div class=&quot;mask&quot; style=&quot;position:fixed;inset:0;&quot;&gt;&lt;/div&gt;
    &lt;!-- 内容 --&gt;
    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;</code></pre>
</div><p>最终发现是由于<code>style</code>与<code>class</code>设置的样式在这个机型上展示虽然一致</p>
<p>但实际交互起来的表现却不一致</p>
<p>修复后的<code>html</code>结构如下,在元素里插入了一个<code>style</code>标签，使用<code>class</code>选择器与<code>!important</code>重载这个距离的样式</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::cx3tqsnp1ou3cbdhiisf43::--><code>&lt;body style=&quot;overflow:hidden;&quot;&gt;
  &lt;!-- dialog --&gt;
  &lt;div class=&quot;dialog&quot; style=&quot;top:88px;&quot;&gt;
    &lt;!-- 遮罩 --&gt;
    &lt;div class=&quot;mask&quot; style=&quot;position:fixed;inset:0;&quot;&gt;&lt;/div&gt;
    &lt;!-- 内容 --&gt;
    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;
    &lt;style&gt;
      .dialog{
        top:88px !important;
      }
    &lt;/style&gt;
  &lt;/div&gt;
&lt;/body&gt;</code></pre>
</div><p>代码如下</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::yhrnvfc3qiks1ibm4p3t::--><code>{
  onShow(){
    setTimeout(() =&gt; {
      const dialogEl = document.querySelector&lt;HTMLElement&gt;(&#039;.dialog&#039;)
      if (!dialogEl) {
        return
      }
      const style = document.createElement(&#039;style&#039;)
      style.textContent = `
      .dialog{
        top:${dialogEl.style.top} !important;
      }
      `
      dialogEl.append(style)
    }, 200)
  }
}</code></pre>
</div><p>非常令人迷惑的一个操作，但就是解决了问题</p>
<h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to “小结”">&#8203;</a></h2>
<p>针对移动端弹窗下层页面可被滑动的异常场景</p>
<p>本文介绍了<code>4种常见</code>解决方法，与<code>1种&quot;谜之操作&quot;</code></p>
<h2 id="demo演示" tabindex="-1">demo演示 <a class="header-anchor" href="#demo演示" aria-label="Permalink to “demo演示”">&#8203;</a></h2>
<p><img src="./fixed-page/MTY0MjkzODA2NTUyNA==642938065524.png" alt="图片" loading="lazy"></p>
<ul>
<li><a href="https://test-demo-6gd4lnn3e3ca39f5-1256505457.tcloudbaseapp.com/dialog-h5-fixed-case/" target="_blank" rel="noreferrer">demo地址</a></li>
<li>PC扫码体验
<ul>
<li><img src="./fixed-page/MTY0MjkzODExOTA1MQ==642938119051.png" alt="图片" loading="lazy"></li>
</ul>
</li>
<li><a href="https://stackblitz.com/edit/vitejs-vite-xgqbt6?file=src%2Fmain.ts&amp;terminal=dev" target="_blank" rel="noreferrer">demo源码地址</a></li>
</ul>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/fixed-page/MTY0MjkzODA2NTUyNA==642938065524.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[小技巧：for of中获取index]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/forof-idx.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/forof-idx.html</guid>
            <pubDate>Mon, 17 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[日常开发中在遍历数据时经常使用`for...of`,`forEach`
前者使用时能够配合`async await`,`continue`,`break`等等
```ts
const data = []]></description>
            <content:encoded><![CDATA[<h1 id="小技巧-for-of中获取index" tabindex="-1">小技巧：for of中获取index <a class="header-anchor" href="#小技巧-for-of中获取index" aria-label="Permalink to “小技巧：for of中获取index”">&#8203;</a></h1>
<p>日常开发中在遍历数据时经常使用<code>for...of</code>,<code>forEach</code></p>
<p>前者使用时能够配合<code>async await</code>,<code>continue</code>,<code>break</code>等等</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::gw7h5cccz125gcoldbpiw::--><code>const data = [
  { name: &#039;xm1&#039;, age: 1 },
  { name: &#039;xm2&#039;, age: 4 },
  { name: &#039;xm3&#039;, age: 5 },
  { name: &#039;xm4&#039;, age: 9 }
]

function sleep(s){
  const end = s * 1000 + Date.now()
  while(Date.now() &lt; end){}
}
async function fn(){
  for (const people of data) {
    if (people.age === 9) {
      break
    }
    if (people.age % 2 !== 0) {
      continue
    }
    await sleep(people.age)
    console.log(people.name);
  }
} 
fn() // xm2</code></pre>
</div><p>但有时候想获取元素的<code>idx</code>，有哪些简单的方式呢</p>
<h2 id="_1-array-prototype-map" tabindex="-1">1-Array.prototype.map <a class="header-anchor" href="#_1-array-prototype-map" aria-label="Permalink to “1-Array.prototype.map”">&#8203;</a></h2>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::aldcb29chmtp153m76855::--><code>function MapWithIdx(arr){
    return arr.map((v, idx) =&gt; ([idx, v]))
}

for (const [idx, v] of MapWithIdx(data)) {
  console.log(idx, v);
}</code></pre>
</div><h2 id="_2-array-prototype-entries" tabindex="-1">2-Array.prototype.entries <a class="header-anchor" href="#_2-array-prototype-entries" aria-label="Permalink to “2-Array.prototype.entries”">&#8203;</a></h2>
<p>这个方法是ES6新增的API</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::zzf4k2slulu127qjo5s6d::--><code>for (const [idx, v] of data.entries()) {
  console.log(idx, v);
}</code></pre>
</div><h2 id="_3-array-prototype-keys" tabindex="-1">3-Array.prototype.keys <a class="header-anchor" href="#_3-array-prototype-keys" aria-label="Permalink to “3-Array.prototype.keys”">&#8203;</a></h2>
<p>这个方法也是ES6新增的API</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::10l9pyrr43jpo4aw1hsjhi::--><code>for (const idx of data.keys()) {
    const v = data[idx]
    console.log(idx, v);
}</code></pre>
</div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[关于自己]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/aboutme.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/aboutme.html</guid>
            <pubDate>Sat, 11 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[
# 关于我

]]></description>
            <content:encoded><![CDATA[<h1 id="关于我" tabindex="-1">关于我 <a class="header-anchor" href="#关于我" aria-label="Permalink to “关于我”">&#8203;</a></h1>
<hr>
<p>码农大叔, 爱开源与分享</p>
<p>就职于 <code>宇宙大药厂</code></p>
<p><img src="./th2.jpg" alt="图片" loading="lazy"></p>
<h2 id="在做什么" tabindex="-1">✨在做什么 <a class="header-anchor" href="#在做什么" aria-label="Permalink to “在做什么”">&#8203;</a></h2>
<h3 id="公司" tabindex="-1">公司 <a class="header-anchor" href="#公司" aria-label="Permalink to “公司”">&#8203;</a></h3>
<ul>
<li>2014 - ing：<a href="https://www.dmsrs.org/" target="_blank" rel="noreferrer">项目管理</a></li>
<li>2012 - 2014：<a href="https://www.dmsrs.org" target="_blank" rel="noreferrer">热计量与收费</a></li>
<li>2008 - 2010：<a href="https://www.dmsrs.org" target="_blank" rel="noreferrer">DNA研发与应用平台</a></li>
<li>2006 - 2008：<a href="https://www.dmsrs.org" target="_blank" rel="noreferrer">三级联网安全监控</a></li>
</ul>
<h3 id="技术" tabindex="-1">技术 <a class="header-anchor" href="#技术" aria-label="Permalink to “技术”">&#8203;</a></h3>
<ul>
<li>
<p>C# &amp; dotnet</p>
</li>
<li>
<p>Java &amp; Spring &amp; JSP</p>
</li>
<li>
<p>Html、Css、Javascript、Vue、JQuery、vite*</p>
</li>
<li>
<p>Python</p>
</li>
</ul>
<h3 id="开源" tabindex="-1">开源 <a class="header-anchor" href="#开源" aria-label="Permalink to “开源”">&#8203;</a></h3>
<ul>
<li></li>
<li></li>
<li>。。。</li>
</ul>
<h2 id="当下" tabindex="-1">🚀当下 <a class="header-anchor" href="#当下" aria-label="Permalink to “当下”">&#8203;</a></h2>
<p>沉淀技术，广度与深度3/7分，打磨自己做的一些小应用，确定自己最终深挖的领域。</p>
<h2 id="座右铭" tabindex="-1">📝座右铭 <a class="header-anchor" href="#座右铭" aria-label="Permalink to “座右铭”">&#8203;</a></h2>
<p>天道酬勤，恒以致遠😄</p>
<h2 id="联系我" tabindex="-1">☎️联系我 <a class="header-anchor" href="#联系我" aria-label="Permalink to “联系我”">&#8203;</a></h2>
<p><strong>邮箱</strong>：calmripple@dmsrs.org</p>
<p><strong>微信</strong>：</p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/mp-code.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[webpack项目接入Vite的通用方案介绍]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/webapck2vite.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/webapck2vite.html</guid>
            <pubDate>Sat, 04 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[愿景
希望通过本文，能给读者提供一个存/增量项目（包含但不限于webpack工程）接入Vite的点子，起抛砖引玉的作用，减少这方面能力的建设成本
在阐述过程中同时也会逐渐完善webpack-vite-]]></description>
            <content:encoded><![CDATA[<h1 id="webpack-项目接入vite的通用方案介绍" tabindex="-1">webpack 项目接入Vite的通用方案介绍 <a class="header-anchor" href="#webpack-项目接入vite的通用方案介绍" aria-label="Permalink to “webpack 项目接入Vite的通用方案介绍”">&#8203;</a></h1>
<h2 id="愿景" tabindex="-1">愿景 <a class="header-anchor" href="#愿景" aria-label="Permalink to “愿景”">&#8203;</a></h2>
<p>希望通过本文，能给读者提供一个存/增量项目（包含但不限于webpack工程）接入Vite的点子，起抛砖引玉的作用，减少这方面能力的建设成本</p>
<p>在阐述过程中同时也会逐渐完善<a href="https://github.com/ATQQ/webpack-vite-serve" target="_blank" rel="noreferrer">webpack-vite-serve</a>这个工具</p>
<p>读者可直接fork这个工具仓库，针对个人/公司项目场景进行定制化的二次开发，也可在issues中留言遇到的问题</p>
<h2 id="_1-背景" tabindex="-1">1 背景 <a class="header-anchor" href="#_1-背景" aria-label="Permalink to “1 背景”">&#8203;</a></h2>
<h3 id="_1-1-现状-vite诞生背景" tabindex="-1">1.1 现状 - Vite诞生背景 <a class="header-anchor" href="#_1-1-现状-vite诞生背景" aria-label="Permalink to “1.1 现状 - Vite诞生背景”">&#8203;</a></h3>
<blockquote>
<p>引用自<a href="https://cn.vitejs.dev/guide/why.html" target="_blank" rel="noreferrer">Vite官方文档</a>的介绍</p>
</blockquote>
<p>在浏览器支持 ES 模块之前，JavaScript 并没有提供的原生机制让开发者以模块化的方式进行开发。这也正是我们对 “打包” 这个概念熟悉的原因：使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件。</p>
<p>时过境迁，我们见证了诸如 webpack、Rollup 和 Parcel 等工具的变迁，它们极大地改善了前端开发者的开发体验。</p>
<p>然而，当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。</p>
<p>我们开始遇到性能瓶颈 —— 使用 JavaScript 开发的工具通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用 HMR，文件修改后的效果也需要几秒钟才能在浏览器中反映出来。</p>
<p>如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。</p>
<p><strong>Vite 旨在利用生态系统中的新进展解决上述问题</strong></p>
<ul>
<li>浏览器开始原生支持 ES 模块</li>
<li>越来越多 JavaScript 工具使用编译型语言编写。</li>
</ul>
<h3 id="_1-2-当下流行趋势" tabindex="-1">1.2 当下流行趋势 <a class="header-anchor" href="#_1-2-当下流行趋势" aria-label="Permalink to “1.2 当下流行趋势”">&#8203;</a></h3>
<h4 id="_1-2-1-swc与esbuild" tabindex="-1">1.2.1 SWC与esbuild <a class="header-anchor" href="#_1-2-1-swc与esbuild" aria-label="Permalink to “1.2.1 SWC与esbuild”">&#8203;</a></h4>
<p>突破Node.js的性能瓶颈，出现了用其它语言写的工具，帮助构建/开发提效，如 <a href="https://github.com/swc-project/swc" target="_blank" rel="noreferrer">SWC（Rust）</a>，<a href="https://github.com/evanw/esbuild" target="_blank" rel="noreferrer">esbuild（Go）</a>，在部分场景下能替代传统Node.js工具工作，并表现非常好。</p>
<table-base src="swc-esbuild"/><h4 id="_1-2-2-vite与snowpack" tabindex="-1">1.2.2 Vite与snowpack <a class="header-anchor" href="#_1-2-2-vite与snowpack" aria-label="Permalink to “1.2.2 Vite与snowpack”">&#8203;</a></h4>
<p>另一种火热的方案是bundleless，利用浏览器原生支持 ES Module 的特性，让浏览器接管&quot;打包&quot;的部分工作，工具只负责对请求的资源进行简单的转换，从而极大的减少服务的启动时间，提升开发体验与开发幸福感</p>
<p>比较出名的两个产品就是 snowpack 与 Vite</p>
<table-base src="vite-snowpack"/><h3 id="_1-3-问题与诉求" tabindex="-1">1.3 问题与诉求 <a class="header-anchor" href="#_1-3-问题与诉求" aria-label="Permalink to “1.3 问题与诉求”">&#8203;</a></h3>
<p>开发者或技术团队为保持框架技术的先进性，将会接入vite，从而提升开发者的工作效率</p>
<h4 id="_1-3-1-问题" tabindex="-1">1.3.1 问题 <a class="header-anchor" href="#_1-3-1-问题" aria-label="Permalink to “1.3.1 问题”">&#8203;</a></h4>
<p>在当下的业务开发中处处可见<a href="https://webpack.docschina.org/concepts/" target="_blank" rel="noreferrer">webpack</a>的身影，大部分的业务项目采用的构建工具也都是它，但随着时间的推移，存量老项目体积越来越大，开发启动(dev)/构建(build) 需要的时间越来越长。</p>
<p>存量webpack项目数目庞大，同时项目体积也不小。围绕webpack所建立的周边也是比vite更加丰富，老项目对其依赖性强。</p>
<p>从webpack直接迁移到vite，迁移和回归测试成本都非常大。</p>
<h4 id="_1-3-2-诉求" tabindex="-1">1.3.2 诉求 <a class="header-anchor" href="#_1-3-2-诉求" aria-label="Permalink to “1.3.2 诉求”">&#8203;</a></h4>
<p>期望提供一个低成本甚至一键接入Vite方案，开发者按需开启使用，无需进行额外的配置，与webpack共存。</p>
<h3 id="_1-4-为什么选vite-而不是snowpack" tabindex="-1">1.4 为什么选Vite，而不是snowpack <a class="header-anchor" href="#_1-4-为什么选vite-而不是snowpack" aria-label="Permalink to “1.4 为什么选Vite，而不是snowpack”">&#8203;</a></h3>
<h4 id="_1-4-1-生产构建" tabindex="-1">1.4.1 生产构建 <a class="header-anchor" href="#_1-4-1-生产构建" aria-label="Permalink to “1.4.1 生产构建”">&#8203;</a></h4>
<p>Snowpack</p>
<ul>
<li>默认构建输出是未打包的：它将每个文件转换为单独的构建模块，然后将这些模块提供给执行实际绑定的不同“优化器”。这么做的好处是，你可以选择不同终端打包器，以适应不同需求（例如 webpack, Rollup，甚至是 ESbuild）</li>
<li>缺点是体验有些支离破碎 —— 例如，esbuild 优化器仍然是不稳定的，Rollup 优化器也不是官方维护，而不同的优化器又有不同的输出和配置。</li>
</ul>
<p>Vite</p>
<ul>
<li>选择了与单个打包器（Rollup）进行更深入的集成。</li>
<li>支持一套通用插件API 扩展了 Rollup 的插件接口，开发和构建两种模式都适用。</li>
</ul>
<h4 id="_1-4-2-vite支持更多的特性" tabindex="-1">1.4.2 Vite支持更多的特性 <a class="header-anchor" href="#_1-4-2-vite支持更多的特性" aria-label="Permalink to “1.4.2 Vite支持更多的特性”">&#8203;</a></h4>
<p>支持目前在 Snowpack 构建优化器中不可用的多种功能：</p>
<ul>
<li>多页面应用支持</li>
<li>库模式</li>
<li>自动分割 CSS 代码</li>
<li>预优化的异步 chunk 加载</li>
<li>对动态导入自动 polyfill</li>
<li>官方 兼容模式插件 打包为现代/传统两种产物，并根据浏览器支持自动交付正确的版本。</li>
<li>更快的依赖预构建</li>
<li>Monorepo 支持</li>
<li>CSS 预处理器支持。。。</li>
</ul>
<h2 id="_2-目标" tabindex="-1">2 目标 <a class="header-anchor" href="#_2-目标" aria-label="Permalink to “2 目标”">&#8203;</a></h2>
<p><strong>为webpack项目开发环境提供最简单的Vite接入方案</strong></p>
<p>待接入项目只需要做极小的变动就能享受到<code>Vite</code>带来的开发乐趣</p>
<p><strong>通过CLI工具为项目提供一个一键接入Vite能力</strong></p>
<p>Tips：大部分框架都有自己的CLI工具，没有CLI工具也可以CLI工具的形式提供使用Vite的能力，方便维护与升级</p>
<h2 id="_3-实现方案介绍" tabindex="-1">3 实现方案介绍 <a class="header-anchor" href="#_3-实现方案介绍" aria-label="Permalink to “3 实现方案介绍”">&#8203;</a></h2>
<h3 id="_3-1-再次思考vite是什么" tabindex="-1">3.1 再次思考Vite是什么 <a class="header-anchor" href="#_3-1-再次思考vite是什么" aria-label="Permalink to “3.1 再次思考Vite是什么”">&#8203;</a></h3>
<ul>
<li>官方：下一代前端开发与构建工具 （feature：💡极速的服务启动、⚡️轻量快速的热重载）</li>
<li>祖师爷(yyx)：上层的工具链方案，对标 （webpack + 针对 web 的常用配置 + webpack-dev-server）</li>
<li>笔者：一个非常Nice的前端构建工具，能够提高开发者编码幸福感与舒适度</li>
</ul>
<h3 id="_3-2-vite原理介绍" tabindex="-1">3.2 Vite原理介绍 <a class="header-anchor" href="#_3-2-vite原理介绍" aria-label="Permalink to “3.2 Vite原理介绍”">&#8203;</a></h3>
<p>官方文档中有提到</p>
<ul>
<li>Vite使用原生 ESM 文件，无需打包!</li>
<li>Vite 将 index.html 视为源码和模块图的一部分。</li>
<li>Vite 解析 <code>&lt;script type=&quot;module&quot; src=&quot;...&quot;&gt;</code>，这个标签指向你的 JavaScript 源码。</li>
</ul>
<h4 id="_3-2-1-script-module" tabindex="-1">3.2.1 script module <a class="header-anchor" href="#_3-2-1-script-module" aria-label="Permalink to “3.2.1 script module”">&#8203;</a></h4>
<p>浏览器原生支持的JS的模块能力，遵循ES Module规范，从 <a href="https://caniuse.com/?search=script%20module" target="_blank" rel="noreferrer">caniuse</a> 上的数据来看，大约95%的浏览器都支持</p>
<p><img src="./webapck2vite/MTYzODYwMjk4NDc1Mg==638602984752.png" alt="图片" loading="lazy"></p>
<p>使用示例</p>
<p><img src="./webapck2vite/MTYzODYwMzAwMDc5Nw==638603000797.png" alt="图片" loading="lazy"></p>
<h4 id="_3-2-2-vite快的原因" tabindex="-1">3.2.2 Vite快的原因 <a class="header-anchor" href="#_3-2-2-vite快的原因" aria-label="Permalink to “3.2.2 Vite快的原因”">&#8203;</a></h4>
<table-base src="vite-webpack"/><p>有了浏览器提供模块化的基础，Vite只需要做静态资源的转化工作就可</p>
<ul>
<li>ts,jsx转换</li>
<li>node_modules资源处理</li>
<li>。。。and more</li>
</ul>
<h4 id="_3-2-3-实现mini-vite开发服务器" tabindex="-1">3.2.3 实现mini Vite开发服务器 <a class="header-anchor" href="#_3-2-3-实现mini-vite开发服务器" aria-label="Permalink to “3.2.3 实现mini Vite开发服务器”">&#8203;</a></h4>
<p>Vite基本原理就是通过Node启动一个HttpServer，拦截浏览器的ES Module请求，根据资源/模块请求路径，在工作目录中查找到对应的文件，再转换成ES Module的形式返回给浏览器。</p>
<p><img src="./webapck2vite/MTYzODYwMzY4OTYxNQ==vite-mini.png" alt="图片" loading="lazy"></p>
<p>包含 scss/css/ts 的资源处理的一个demo。<a href="https://stackblitz.com/edit/node-qt2m2e?file=README.md" target="_blank" rel="noreferrer">在线体验地址（包含源码）</a></p>
<p><img src="./webapck2vite/MTYzODYwMzczNDA3Mw==638603734073.png" alt="图片" loading="lazy"></p>
<p><img src="./webapck2vite/MTYzODYwMzc0NjE2Mg==638603746163.png" alt="图片" loading="lazy"></p>
<p>demo的目录结构如下</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::qug8s8ghx5ogrd9zvuuvg::--><code>├── src
|  ├── App.ts
|  ├── assets
|  |  ├── app.css
|  |  └── app.scss
|  └── main.ts
├── index.html</code></pre>
</div><p>开发服务器的实现如下</p>
<ul>
<li>通过 http 模块，创建一个服务器实例，监听3000端口</li>
<li>请求头包含 'text/html', 'application/xhtml+xml' 则认定为请求html文档</li>
<li>其余资源，交由 esbuild 与 sass 做进一步处理</li>
</ul>
<my-details title="点击查看完整源码与实现步骤">
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::b8vz53bvteap0wtlfm1fte::--><code>// vite.js
const http = require(&#039;http&#039;);
const { readFileSync } = require(&#039;fs&#039;);
const { getSourceType, transformSource } = require(&#039;./utils&#039;)

const server = http.createServer((req, res) =&gt; {
  const htmlAccepts = [&#039;text/html&#039;, &#039;application/xhtml+xml&#039;];
  const isHtml = !!htmlAccepts.find((a) =&gt; req.headers?.accept?.includes(a));
  // HTML文档
  if (isHtml) {
    res.end(readFileSync(&#039;./index.html&#039;));
    return;
  }
  const url = new URL(req.url, &#039;http://localhost&#039;);
  const { pathname } = url
  // 其它资源
  const type = getSourceType(pathname)
  res.setHeader(&#039;content-type&#039;,&#039;application/javascript&#039;)
  res.end(transformSource(type, pathname));
});

server.listen(3000);</code></pre>
</div><p>esbuild 处理js（jsx,ts,cjs,mjs等等）相关的文件</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::4dopgxquvam7xs3913id2v::--><code>const { transformSync } = require(&#039;esbuild&#039;)
const res = transformSync(sourceCode, {
    format: &#039;esm&#039;,
    minify: true,
    loader: &#039;ts&#039;
}).code</code></pre>
</div><p>sass 负责 scss文件的转换</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::1nkap8eyvvma0ju49v39c::--><code>const sass = require(&#039;sass&#039;)
const css = sass.renderSync({
    data: code
}).css.toString()</code></pre>
</div><p>资源处理逻辑如下：</p>
<ul>
<li>根据请求资源路径，判断资源可能的类型</li>
<li>利用对应的转换器，将资源<strong>转换成浏览器可识别的js代码</strong></li>
</ul>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::m96io97grgsni2sgn5b4::--><code>// utils.js
const { readFileSync, existsSync } = require(&#039;fs&#039;);
const path = require(&#039;path&#039;);
const sass = require(&#039;sass&#039;)
const { transformSync } = require(&#039;esbuild&#039;)

const resolved = (...p) =&gt; path.join(process.cwd(), ...p);

/**
 * 获取资源类型
 */
function getSourceType(pathname) {
    // TODO: 省略 tsx,jsx
    const jsSourceType = [&#039;ts&#039;, &#039;js&#039;]
    // TODO：还有很多其它资源
    const sourceType = [...jsSourceType, &#039;css&#039;, &#039;scss&#039;]
    let type = sourceType.find(t =&gt; pathname.endsWith(`.${t}`))

    if (!type &amp;&amp; !/\..+$/.test(pathname)) {
        type = jsSourceType.find(t =&gt; {
            return existsSync(resolved(`${pathname}.${t}`))
        })
    }
    return type
}

/**
 * 获取资源的源码
 * @returns
 */
function getSourceCode(type, pathname) {
    if (existsSync(resolved(pathname))) {
        return readFileSync(resolved(pathname), { encoding: &#039;utf-8&#039; })
    }
    if (existsSync(resolved(`${pathname}.${type}`))) {
        return readFileSync(resolved(`${pathname}.${type}`), { encoding: &#039;utf-8&#039; })
    }
    return &#039;&#039;
}

/**
 * 添加内联样式表
 */
function addInlineStyle(code) {
    return `{
        const style = document.createElement(&#039;style&#039;)
        style.textContent = \`${code}\`
        document.head.appendChild(style)
    }
    `
}
/**
 * 转换资源
 */
function transformSource(type, pathname) {
    const sourceCode = getSourceCode(type, pathname)

    const ops = {
        css(code) {
            return addInlineStyle(code)
        },
        scss(code) {
            const css = sass.renderSync({
                data: code
            }).css.toString()
            return this.css(css)
        },
        ts(code) {
            return transformSync(code, {
                format: &#039;esm&#039;,
                minify: true,
                loader: &#039;ts&#039;
            }).code
        },
        js(code) {
            return transformSync(code, {
                format: &#039;esm&#039;,
                minify: true,
                loader: &#039;js&#039;
            }).code
        },
    }
    return ops[type] ? ops[type](sourceCode) : sourceCode
}

module.exports = {
    resolved,
    getSourceType,
    transformSource
}</code></pre>
</div></my-details>
<h3 id="_3-3-vite插件系统简介" tabindex="-1">3.3 Vite插件系统简介 <a class="header-anchor" href="#_3-3-vite插件系统简介" aria-label="Permalink to “3.3 Vite插件系统简介”">&#8203;</a></h3>
<p>Vite 插件扩展了设计出色的 Rollup 接口，带有一些 Vite 独有的配置项。</p>
<p><img src="./webapck2vite/MTYzODYwNDI5OTQwOQ==vite-plugin.png" alt="图片" loading="lazy"></p>
<h3 id="_3-4-方案概述" tabindex="-1">3.4 方案概述 <a class="header-anchor" href="#_3-4-方案概述" aria-label="Permalink to “3.4 方案概述”">&#8203;</a></h3>
<h4 id="_3-4-1-要解决的问题" tabindex="-1">3.4.1 要解决的问题 <a class="header-anchor" href="#_3-4-1-要解决的问题" aria-label="Permalink to “3.4.1 要解决的问题”">&#8203;</a></h4>
<p>解决这些问题也是方案实现的关键点</p>
<table-base src="vite-problem"/><h4 id="_3-4-2-cli结构" tabindex="-1">3.4.2 CLI结构 <a class="header-anchor" href="#_3-4-2-cli结构" aria-label="Permalink to “3.4.2 CLI结构”">&#8203;</a></h4>
<p><img src="./webapck2vite/MTYzODYwNTMyOTExNg==638605329116.png" alt="图片" loading="lazy"></p>
<ul>
<li>通过Plugin拓展Vite的能力，将常用插件全部内置
<ul>
<li>内置框架相关的Plugin</li>
<li>内置业务常用Plugin</li>
</ul>
</li>
<li>将Vite相关的配置全部收敛于插件内，同时支持用户通过外部配置文件 vite.conig.ts 修改&amp;拓展Vite能力</li>
<li>内部通过配置转换插件自动将Webpack配置转化为Vite配置</li>
<li>通过CLI工具，封装Vite的能力</li>
</ul>
<h2 id="_4-方案实现" tabindex="-1">4 方案实现 <a class="header-anchor" href="#_4-方案实现" aria-label="Permalink to “4 方案实现”">&#8203;</a></h2>
<p>能力优先通过VIte插件提供，然后将实现的插件进行内置。</p>
<h3 id="_4-1-dev-html模板处理" tabindex="-1">4.1 Dev-HTML模板处理 <a class="header-anchor" href="#_4-1-dev-html模板处理" aria-label="Permalink to “4.1 Dev-HTML模板处理”">&#8203;</a></h3>
<p><img src="./webapck2vite/MTYzODYwNTQzODg3Mg==638605438872.png" alt="图片" loading="lazy"></p>
<p>Vite默认是将启动目录下的 index.html的文件，作为启动入口，而在传统的webpack项目中，这个模板文件是在 public/index.html或者src/pages/pageName下</p>
<p>所以需要优先处理Html模板的问题</p>
<h4 id="_4-1-1-初始化模板内容" tabindex="-1">4.1.1 初始化模板内容 <a class="header-anchor" href="#_4-1-1-初始化模板内容" aria-label="Permalink to “4.1.1 初始化模板内容”">&#8203;</a></h4>
<p>首先通过 configureServer 钩子注册一个自定义的中间件。处理开发服务器的资源请求</p>
<p>当请求头包含 text/html 与 application/xhtml+xml，可以认定为是请求的HTML文档</p>
<p>紧接着根据请求的资源路径查找本地文档</p>
<my-details title="点击展开源码">
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::q4rnxkoagthnhi4c195ag::--><code>export default function HtmlTemplatePlugin(): PluginOption {
  return {
    name: &#039;wvs-html-tpl&#039;,
    apply: &#039;serve&#039;,
    configureServer(server) {
      const { middlewares: app } = server;
      app.use(async (req, res, next) =&gt; {
        const htmlAccepts = [&#039;text/html&#039;, &#039;application/xhtml+xml&#039;];
        const isHtml = !!htmlAccepts.find((a) =&gt; req.headers?.accept?.includes(a));
        if (isHtml) {
          const originHtml = loadHtmlContent(req.url);
          const html = await server.transformIndexHtml(req.url, originHtml, req.originalUrl);
          res.end(html);
          return;
        }
        next();
      });
    },
    transformIndexHtml(html) {
      return transformTpl(html);
    },
  };
}</code></pre>
</div></my-details>
<p>SPA 默认使用 public/index.html</p>
<p>MPA默认按照如下路径进行查找</p>
<ul>
<li>src/pages/${entryName}/${entryName}.html</li>
<li>src/pages/${entryName}/index.html</li>
<li>public/${entryName}.html</li>
<li>public/index.html</li>
</ul>
<my-details title="点击展开源码">
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::erodwircn7k1umvc3pwhn::--><code>/**
 * 获取原始模板
 */
function loadHtmlContent(reqPath:string) {
  // 兜底页面
  const pages = [path.resolve(__dirname, &#039;../../public/index.html&#039;)];
  // 单页/多页默认 public/index.html
  pages.unshift(resolved(&#039;public/index.html&#039;));
  // 多页应用可以根据请求的 路径 作进一步的判断
  if (isMPA()) {
    const entryName = getEntryName(reqPath);
    if (entryName) {
    // src/pages/${entryName}/${entryName}.html
    // src/pages/${entryName}/index.html
    // public/${entryName}.html
      pages.unshift(resolved(`public/${entryName}.html`));
      pages.unshift(resolved(`src/pages/${entryName}/index.html`));
      pages.unshift(resolved(`src/pages/${entryName}/${entryName}.html`));
    }
  }
  // TODO：根据框架的配置寻找，可自行进一步拓展
  const page = pages.find((v) =&gt; existsSync(v));
  return readFileSync(page, { encoding: &#039;utf-8&#039; });
}</code></pre>
</div></my-details>
<p>获取到原始的模板内容后，通常原始模板中可能会包含一些EJS的语法</p>
<p>可以通过 transformIndexHtml 钩子对模板内容进行一个进一步的处理</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::6hlq0sxvbn64e4gnegxqi::--><code>export default function HtmlTemplatePlugin(): PluginOption {
  return {
    transformIndexHtml(html) {
      return transformTpl(html);
    },
  };
}</code></pre>
</div><p>transformTpl方法的实现，可以根据具体的场景进行实现，这里提供一个简单的正则替换实现</p>
<my-details title="点击展开源码">
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::ly144pewk9bf8ea6frubck::--><code>export function transformTpl(tplStr:string, data = {}, ops?:{
 backup?:string
 matches?:RegExp[]
}) {
  data = {
    PUBLIC_URL: &#039;.&#039;,
    BASE_URL: &#039;./&#039;,
    htmlWebpackPlugin: {
      options: {
        title: &#039;App&#039;,
      },
    },
    ...data,
  };
  const { backup = &#039;&#039;, matches = [] } = ops || {};
  // match %Name% &lt;%Name%&gt;
  return [/&lt;?%=?(.*)%&gt;?/g].concat(matches).reduce((tpl, r) =&gt; tpl.replace(r, (_, $1) =&gt; {
    const keys = $1.trim().split(&#039;.&#039;);
    const v = keys.reduce((pre, k) =&gt; (pre instanceof Object ? pre[k] : pre), data);
    return (v === null || v === undefined) ? backup : v;
  }), tplStr);
}</code></pre>
</div></my-details>
<h4 id="_4-1-2-插入entryjs" tabindex="-1">4.1.2 插入entryJs <a class="header-anchor" href="#_4-1-2-插入entryjs" aria-label="Permalink to “4.1.2 插入entryJs”">&#8203;</a></h4>
<p>模板处理完成后，需要再模板中通过 script 标签引入entryJs才能正常的进行工作</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::bkj26gqi59wz1q01txbd4c::--><code>&lt;script type=&quot;module&quot; src=&quot;$entryPath&quot;&gt;&lt;/script&gt;
&lt;!--例如--&gt;
&lt;script type=&quot;module&quot; src=&quot;/src/main&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;module&quot; src=&quot;/src/pages/pageName/index&quot;&gt;&lt;/script&gt;</code></pre>
</div><p>这部分的处理相对简单，只需要调用 transformIndexHtml 钩子即可</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::rvz6fdpny5px1f1z1ae6i::--><code>export default function pageEntryPlugin(): PluginOption {
  return {
    name: &#039;wvs-page-entry&#039;,
    apply: &#039;serve&#039;,
    transformIndexHtml(html, ctx) {
      const entry = getPageEntry(ctx.originalUrl);
      if (!entry) {
        return html;
      }
      return html.replace(&#039;&lt;/body&gt;&#039;, `&lt;script type=&quot;module&quot; src=&quot;${path.join(&#039;/&#039;, entry)}&quot;&gt;&lt;/script&gt;
        &lt;/body&gt;
        `);
    },
  };
}</code></pre>
</div><p>entryJs的获取逻辑如下：</p>
<ul>
<li>entry命名通过正则 <code>/(index|main)\.[jt]sx?$/</code> 进行筛选</li>
<li>SPA查找目录 <code>src</code></li>
<li>MPA查找目录 <code>src/pages/pageName</code></li>
</ul>
<my-details title="点击展开源码">
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::ig6rll1h14g22xjt6mt5s9::--><code>function getPageEntry(reqUrl) {
  if (isMPA()) {
    const pageName = getPageName(reqUrl);
    return !!pageName &amp;&amp; getEntryFullPath(`src/pages/${pageName}`);
  }
  // 其它场景跟MPA处理类似

  // 默认SPA
  const SPABase = &#039;src&#039;;
  return getEntryFullPath(SPABase);
}

function getEntryFullPath(dirPath) {
  if (!existsSync(resolved(dirPath))) {
    return false;
  }
  // main|index.js|ts|jsx|tsx
  const entryName = /(index|main)\.[jt]sx?$/;
  const entryNames = readdirSync(resolved(dirPath), { withFileTypes: true })
    .filter((v) =&gt; {
      entryName.lastIndex = 0;
      return v.isFile() &amp;&amp; entryName.test(v.name);
    });
  return entryNames.length &gt; 0 ? path.join(dirPath, entryNames[0].name) : false;
}</code></pre>
</div></my-details>
<p>其中 pageName 根据请求的资源路径，使用 “/ ” 分割，对每个分割内容进行文件目录的存在与否进行判断</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::ndvzg2jrxznpugnphw4sn9::--><code>export function getPageName(reqUrl:string) {
  // TODO：兼容webpack配置 historyRewrites
  const { pathname } = new URL(reqUrl, &#039;http://localhost&#039;);
  const paths = pathname.split(&#039;/&#039;).filter((v) =&gt; !!v);
  const entryName = paths.find((p) =&gt; existsSync(path.join(getCWD(), &#039;src/pages&#039;, p)));
  return entryName || &#039;&#039;;
}</code></pre>
</div><h3 id="_4-2-production-build" tabindex="-1">4.2 Production-Build <a class="header-anchor" href="#_4-2-production-build" aria-label="Permalink to “4.2 Production-Build”">&#8203;</a></h3>
<p><img src="./webapck2vite/MTYzODYwNjI2NTQyMA==638606265420.png" alt="图片" loading="lazy"></p>
<p>vite构建的入口也是 html，通过 build.rollup.input 属性设置</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::ltpgzz8reqcaxyfqej365a::--><code>// vite.config.ts
import { defineConfig } from &#039;vite&#039;;

export default defineConfig({
  build: {
    rollupOptions: {
      input: {
        index: &#039;src/pages/index/index.html&#039;,
        second: &#039;src/pages/second/second.html&#039;,
      },
    },
  },
});</code></pre>
</div><p>按照如上配置，构建产物中的html目录将会如下</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::6615bd6d167rn122ckwi7::--><code>* dist
  * src/pages/index/index.html
  * src/pages/second/second.html
  * assets</code></pre>
</div><p>不太符合通常的习惯，常规格式如下</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::h44xjjhsuro342jclz2x9p::--><code>* dist
  * index.html
  * second.html
  * assets</code></pre>
</div><p>所以需要通过插件 处理构建入口文件 和 调整构建后的产物位置</p>
<h4 id="_4-2-1-插件结构" tabindex="-1">4.2.1 插件结构 <a class="header-anchor" href="#_4-2-1-插件结构" aria-label="Permalink to “4.2.1 插件结构”">&#8203;</a></h4>
<p>通过 configResolved 钩子获取最终配置，配置提供给其它钩子使用</p>
<p>约定pageEntry的目录</p>
<ul>
<li>SPA：src</li>
<li>MPA：src/pages</li>
</ul>
<my-details title="点击展开源码">
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::9uitg54oos28qevvrvbx7::--><code>export default function BuildPlugin(): PluginOption {
  let userConfig:ResolvedConfig = null;
  return {
    name: &#039;wvs-build&#039;,
    // 只在构建阶段生效
    apply: &#039;build&#039;,
    // 获取最终配置
    configResolved(cfg) {
      userConfig = cfg;
    },
    // 插件配置处理
    config() {

    },
    resolveId(id) {

    },
    load(id) {

    },
    // 构建完成后
    closeBundle() {

    },
  };
}</code></pre>
</div></my-details>
<h4 id="_4-2-2-获取所有的entry" tabindex="-1">4.2.2 获取所有的entry <a class="header-anchor" href="#_4-2-2-获取所有的entry" aria-label="Permalink to “4.2.2 获取所有的entry”">&#8203;</a></h4>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::bv1o1rfh67wze6zia2vd::--><code>const entry = [];
if (isMPA()) {
  entry.push(...getMpaPageEntry());
} else {
  // 单页应用
  entry.push({
    entryName: &#039;index&#039;,
    entryHtml: &#039;public/index.html&#039;,
    entryJs: getEntryFullPath(&#039;src&#039;),
  });
}</code></pre>
</div><p>MPA的pageEntry逻辑获取如下:</p>
<ol>
<li>先获取所有的entryName</li>
<li>再查询遍历每个page对应的 entryJs 与 entryHtml</li>
</ol>
<my-details title="点击展开源码">
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::7oi5a3b0nnn0j98x8ijqy9i::--><code>export function getMpaPageEntry(baseDir = &#039;src/pages&#039;) {
  // 获取所有的EntryName
  const entryNameList = readdirSync(resolved(baseDir), { withFileTypes: true })
    .filter((v) =&gt; v.isDirectory())
    .map((v) =&gt; v.name);

  return entryNameList
    .map((entryName) =&gt; ({ entryName, entryHtml: &#039;&#039;, entryJs: getEntryFullPath(path.join(baseDir, entryName)) }))
    .filter((v) =&gt; !!v.entryJs)
    .map((v) =&gt; {
      const { entryName } = v;
      const entryHtml = [
        // src/pages/${entryName}/${entryName}.html
        resolved(`src/pages/${entryName}/${entryName}.html`),
        // src/pages/${entryName}/index.html
        resolved(`src/pages/${entryName}/index.html`),
        // public/${entryName}.html
        resolved(`public/${entryName}.html`),
        // 应用兜底
        resolved(&#039;public/index.html&#039;),
        // CLI兜底页面
        path.resolve(__dirname, &#039;../index.html&#039;),
      ].find((html) =&gt; existsSync(html));
      return {
        ...v,
        entryHtml,
      };
    });
}</code></pre>
</div></my-details>
<h4 id="_4-2-3-生成build所需配置" tabindex="-1">4.2.3 生成Build所需配置 <a class="header-anchor" href="#_4-2-3-生成build所需配置" aria-label="Permalink to “4.2.3 生成Build所需配置”">&#8203;</a></h4>
<p>根据获取的所有 entry生成最终构建所需的配置</p>
<ul>
<li>获取每个 entryHtml 的内容,然后使用 map 进行临时的存储</li>
<li>构建入口模板路径取 entryJs 的目录加index.html</li>
</ul>
<my-details title="点击展开源码">
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::vlqdf8eoohmh04qw45d8ue::--><code>const htmlContentMap = new Map();
// 省略其它无关代码
{
  config() {
    const input = entry.reduce((pre, v) =&gt; {
      const { entryName, entryHtml, entryJs } = v;
      const html = getEntryHtml(resolved(entryHtml), path.join(&#039;/&#039;, entryJs));
      const htmlEntryPath = resolved(path.parse(entryJs).dir, tempHtmlName);
      // 存储内容
      htmlContentMap.set(htmlEntryPath, html);
      pre[entryName] = htmlEntryPath;
      return pre;
    }, {});
    return {
      build: {
        rollupOptions: {
          input,
        },
      },
    };
  }
}</code></pre>
</div></my-details>
<h4 id="_4-2-4-入口html内容生成" tabindex="-1">4.2.4 入口HTML内容生成 <a class="header-anchor" href="#_4-2-4-入口html内容生成" aria-label="Permalink to “4.2.4 入口HTML内容生成”">&#8203;</a></h4>
<p>实际上htmlEntryPath这个路径并不是真实存在的（不存在这个文件）</p>
<p>需要通过 resolveId 与 load 钩子，利用 htmlContentMap 存储的内容进行进一步的处理</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::xhdimgp9abqfzcszsvife4::--><code>{
  load(id) {
    if (id.endsWith(&#039;.html&#039;)) {
      return htmlContentMap.get(id);
    }
    return null;
  },
  resolveId(id) {
    if (id.endsWith(&#039;.html&#039;)) {
      return id;
    }
    return null;
  },
}</code></pre>
</div><p>其中 id 为资源请求的路径，直接从 htmlContentMap 取出模板的内容即可</p>
<p>构建完成后，需要调整html文档的位置，使其符合预期</p>
<h4 id="_4-2-5-产物目录调整" tabindex="-1">4.2.5 产物目录调整 <a class="header-anchor" href="#_4-2-5-产物目录调整" aria-label="Permalink to “4.2.5 产物目录调整”">&#8203;</a></h4>
<p>使用 closeBundle 钩子，在构建完成后，服务关闭前进行文件调整</p>
<ul>
<li>遍历<code>entry</code>将<code>dist/src/pages/pageName/index.html</code>移动到<code>dist</code>下</li>
<li>移除<code>dist/src</code>下的内容</li>
</ul>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::5t9vn894r53fcopip62h55::--><code>closeBundle() {
  const { outDir } = userConfig.build;
  // 目录调整
  entry.forEach((e) =&gt; {
    const { entryName, entryJs } = e;
    const outputHtmlPath = resolved(outDir, path.parse(entryJs).dir, tempHtmlName);
    writeFileSync(resolved(outDir, `${entryName}.html`), readFileSync(outputHtmlPath));
  });
  // 移除临时资源
  rmdirSync(resolved(outDir, &#039;src&#039;), { recursive: true });
}</code></pre>
</div><h3 id="_4-3-vite配置处理" tabindex="-1">4.3 Vite配置处理 <a class="header-anchor" href="#_4-3-vite配置处理" aria-label="Permalink to “4.3 Vite配置处理”">&#8203;</a></h3>
<h4 id="_4-3-1-读取用户配置" tabindex="-1">4.3.1 读取用户配置 <a class="header-anchor" href="#_4-3-1-读取用户配置" aria-label="Permalink to “4.3.1 读取用户配置”">&#8203;</a></h4>
<p>Vite 提供了一个现成的方法用于读取与解析Vite的配置文件</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::9rzei7e9zage960664fg0m::--><code>import { loadConfigFromFile, ConfigEnv } from &#039;vite&#039;;

export function getUserConfig(configEnv:ConfigEnv, suffix = &#039;&#039;) {
  const configName = &#039;vite.config&#039;;
  const _suffix = [&#039;ts&#039;, &#039;js&#039;, &#039;mjs&#039;, &#039;cjs&#039;];
  if (suffix) {
    _suffix.unshift(suffix);
  }
  const configFile = _suffix.map((s) =&gt; `${configName}.${s}`).find((s) =&gt; existsSync(s));
  return loadConfigFromFile(configEnv, configFile);
}</code></pre>
</div><p>获取配置后通过 config 钩子，将配置并入最终的配置之中</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::bg66669ir0oxvm5i0997w8::--><code>import type { PluginOption } from &#039;vite&#039;;
import { getUserConfig } from &#039;../utils&#039;;

export default function UserConfigPlugin(): PluginOption {
  return {
    name: &#039;wvs-config&#039;,
    async config(cfg, env) {
      const userConfig = await getUserConfig(env);
      return {
        ...userConfig?.config,
      };
    },
  };
}</code></pre>
</div><h4 id="_4-3-2-转换webpack配置" tabindex="-1">4.3.2 转换webpack配置 <a class="header-anchor" href="#_4-3-2-转换webpack配置" aria-label="Permalink to “4.3.2 转换webpack配置”">&#8203;</a></h4>
<p>目前社区已经有一个CLI工具，<a href="https://github.com/tnfe/wp2vite" target="_blank" rel="noreferrer">wp2vite</a> 支持常规Vue/React项目的<a href="https://www.webpackjs.com/configuration/" target="_blank" rel="noreferrer">webpack配置</a>的自动转换到<a href="https://cn.vitejs.dev/config/" target="_blank" rel="noreferrer">vite配置</a></p>
<p><img src="./webapck2vite/MTYzODYwNzE1ODI2OA==638607158268.png" alt="图片" loading="lazy"></p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::b8j0waj8hwv7zd0r11j6lh::--><code>npm install -g wp2vite</code></pre>
</div><p>根目录执行 wp2vite 即可自动转换</p>
<ul>
<li>但由于是一个CLI工具，并没有将内部转换配置的方法暴露出来</li>
<li>工具是开源的。使用方可以对其进行二次的定制，复用其部分能力</li>
<li>获取到转换后的配置后，同上通过config钩子并入最终配置即可</li>
</ul>
<h3 id="_4-4-cli工具支持" tabindex="-1">4.4 CLI工具支持 <a class="header-anchor" href="#_4-4-cli工具支持" aria-label="Permalink to “4.4 CLI工具支持”">&#8203;</a></h3>
<p>Vite支持在启动命令中指定配置文件的路径，这为CLI内置Vite能力提供了便利</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::zca9ufnhfdn5pxyc42r5e::--><code>vite -c configFilePath</code></pre>
</div><p><img src="./webapck2vite/MTYzODYwNzU3MDIwMQ==638607570201.png" alt="图片" loading="lazy"></p>
<p>CLI内部可以通过 spawn 创建子进程启动，也可使用vite对外暴露的<code>createServer</code>方法</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::xkiz9z28alb6q19y4efgr::--><code>import spawn from &#039;cross-spawn&#039;;
// 或者
import { spawn } from &#039;child_process&#039;;

const configPath = require.resolve(&#039;./../config/vite.js&#039;);
const params = [&#039;--config&#039;, configPath];

if (debug) {
  // 标志debug
  process.env.DEBUG = &#039;true&#039;;

  // vite debug
  params.push(&#039;--debug&#039;);
  if (typeof debug === &#039;string&#039;) {
    params.push(debug);
  }
}

const viteService = spawn(&#039;vite&#039;, params, {
  cwd: process.cwd(),
  stdio: &#039;inherit&#039;,
});</code></pre>
</div><h2 id="_5-效果-接入vite前后对比" tabindex="-1">5 效果 - 接入Vite前后对比 <a class="header-anchor" href="#_5-效果-接入vite前后对比" aria-label="Permalink to “5 效果 - 接入Vite前后对比”">&#8203;</a></h2>
<p>启动提速≈70% - 80% HMR速度碾压</p>
<h3 id="_5-1-vue-spa" tabindex="-1">5.1 Vue SPA <a class="header-anchor" href="#_5-1-vue-spa" aria-label="Permalink to “5.1 Vue SPA”">&#8203;</a></h3>
<p><img src="./webapck2vite/MTYzNTE2OTU0MzgyMA==vue.gif?s1=https://img.cdn.sugarat.top/mdImg/MTYzNTE2OTU0MzgyMA==vue.gif" alt="图片" loading="lazy"></p>
<h3 id="_5-2-react-spa" tabindex="-1">5.2 React SPA <a class="header-anchor" href="#_5-2-react-spa" aria-label="Permalink to “5.2 React SPA”">&#8203;</a></h3>
<p><img src="./webapck2vite/MTYzNTA3MDM3NDkyMQ==react-demo2.gif?s1=https://img.cdn.sugarat.top/mdImg/MTYzNTA3MDM3NDkyMQ==react-demo2.gif" alt="图片" loading="lazy"></p>
<h2 id="_6-总结与展望" tabindex="-1">6 总结与展望 <a class="header-anchor" href="#_6-总结与展望" aria-label="Permalink to “6 总结与展望”">&#8203;</a></h2>
<h3 id="_6-1-总结" tabindex="-1">6.1 总结 <a class="header-anchor" href="#_6-1-总结" aria-label="Permalink to “6.1 总结”">&#8203;</a></h3>
<p>本文主要讲述了，项目（包含但不限于webpack工程）接入Vite的通用方案与核心部分逻辑的实现。</p>
<p>为读者提供了一种Web工程接入Vite的思路。</p>
<p>企业：大部分是拥有自己的研发框架，在研发框架中只需要加入一个Vite启动的CLI指令，这样对接入方的影响与使用成本是最小的</p>
<p>个人：喜欢折腾/不想改动原来的代码，可以按上述流程自己接一下，新项目可以直接使用Vite官方模板开发</p>
<p>总之：<strong>开发中使用<code>Vite</code>还是很香的</strong></p>
<h3 id="_6-2-未来展望" tabindex="-1">6.2 未来展望 <a class="header-anchor" href="#_6-2-未来展望" aria-label="Permalink to “6.2 未来展望”">&#8203;</a></h3>
<p>Vite是一颗冉冉升起的前端新星，相信随着周边的不断完善。工程使用Vite作为构建工具的比例会大大的增加。</p>
<p>在只兼容现代浏览器的前提下，bundleless方案将会大放异彩，极大的提升产物的构建速度，再也不用发一次版要等几分钟甚至几十分钟才能Build完成，尤其是在需要频繁部署的测试环境之中。</p>
<h2 id="后续规划" tabindex="-1">后续规划 <a class="header-anchor" href="#后续规划" aria-label="Permalink to “后续规划”">&#8203;</a></h2>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" id="cbx_0" disabled="true"><label for="cbx_0"> 目前<code>wp2vite</code>在配置转换这一块，还不能太满足使用要求，准备提PR增强一下</label></li>
<li class="task-list-item"><input type="checkbox" id="cbx_1" disabled="true"><label for="cbx_1"> 将内部能力抽成一个个单独的vite插件</label></li>
<li class="task-list-item"><input type="checkbox" id="cbx_2" disabled="true"><label for="cbx_2"> 将日常所需能力进行内置</label></li>
<li class="task-list-item"><input type="checkbox" id="cbx_3" disabled="true"><label for="cbx_3"> 将常见问题的解决方案进行内置</label></li>
<li class="task-list-item"><input type="checkbox" id="cbx_4" disabled="true"><label for="cbx_4"> 减小包体积，加快下载速度</label></li>
<li class="task-list-item"><input type="checkbox" id="cbx_5" disabled="true"><label for="cbx_5"> 完善文档</label></li>
</ul>
<h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to “参考资料”">&#8203;</a></h2>
<ul>
<li><a href="https://juejin.cn/post/7010585760642367496#heading-1" target="_blank" rel="noreferrer">掘金：js打包时间缩短90%，bundleless生产环境实践总结</a></li>
<li><a href="https://juejin.cn/post/7026616296426962958" target="_blank" rel="noreferrer">掘金：可能是最完善的 React+Vite 解决方案，阿里飞冰团队发布 icejs 2.0 版本</a></li>
<li><a href="https://juejin.cn/post/7010922819143860261" target="_blank" rel="noreferrer">近 20k Star的项目说不做就不做了，但总结的内容值得借鉴</a></li>
<li><a href="https://www.zhihu.com/question/477139054/answer/2156019180" target="_blank" rel="noreferrer">知乎：Vite 的目标不是要干掉 webpack</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/139219361" target="_blank" rel="noreferrer">知乎：彻底告别编译 OOM，用 esbuild 做压缩器</a></li>
<li><a href="https://cn.vitejs.dev/guide/why.html" target="_blank" rel="noreferrer">Vite官方中文文档</a></li>
</ul>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/webapck2vite/MTYzODYwMjk4NDc1Mg==638602984752.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[webpack项目接入Vite的通用方案介绍-草稿]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/webapck2vite2.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/webapck2vite2.html</guid>
            <pubDate>Sun, 14 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[愿景
希望通过此系列文章，能给读者提供一个存/增量项目接入Vite的点子，起抛砖引玉的作用，减少这方面能力的建设成本
在阐述过程中同时也会逐渐完善webpack-vite-serve这个工具
读者可直]]></description>
            <content:encoded><![CDATA[<h1 id="webpack-项目接入vite的通用方案介绍-草稿" tabindex="-1">webpack 项目接入Vite的通用方案介绍-草稿 <a class="header-anchor" href="#webpack-项目接入vite的通用方案介绍-草稿" aria-label="Permalink to “webpack 项目接入Vite的通用方案介绍-草稿”">&#8203;</a></h1>
<h2 id="愿景" tabindex="-1">愿景 <a class="header-anchor" href="#愿景" aria-label="Permalink to “愿景”">&#8203;</a></h2>
<p>希望通过此系列文章，能给读者提供一个存/增量项目接入Vite的点子，起抛砖引玉的作用，减少这方面能力的建设成本</p>
<p>在阐述过程中同时也会逐渐完善<a href="https://github.com/ATQQ/webpack-vite-serve" target="_blank" rel="noreferrer">webpack-vite-serve</a>这个工具</p>
<p>读者可直接fork这个工具仓库，针对个人/公司项目场景进行定制化的二次开发</p>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>在<a href="./webapck2vite.html">上一期的文章</a>中，大概介绍了webpack项目接入Vite的处理思路，大体就是以下步骤：</p>
<ul>
<li>html模板处理</li>
<li>entryJs处理</li>
<li><a href="https://www.webpackjs.com/configuration/" target="_blank" rel="noreferrer">webpack配置</a>向<a href="https://cn.vitejs.dev/config/" target="_blank" rel="noreferrer">vite配置</a>迁移</li>
<li>替代webpack插件的vite插件</li>
</ul>
<p>这些内容的处理都是可以通过<a href="https://cn.vitejs.dev/guide/api-plugin.html" target="_blank" rel="noreferrer">vite插件</a>实现</p>
<h2 id="webpack-vite-serve介绍" tabindex="-1">webpack-vite-serve介绍 <a class="header-anchor" href="#webpack-vite-serve介绍" aria-label="Permalink to “webpack-vite-serve介绍”">&#8203;</a></h2>
<p>这段时间就在不断完善这个库的功能，下面先简单介绍一下其使用，再阐述一些插件的实现原理</p>
<p>目标：<strong>为webpack项目提供一键接入Vite的能力</strong></p>
<h3 id="安装依赖" tabindex="-1">安装依赖 <a class="header-anchor" href="#安装依赖" aria-label="Permalink to “安装依赖”">&#8203;</a></h3>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::va9936sl9erq488siwg9::--><code>npm install webpack-vite-serve -D
# or
yarn add webpack-vite-serve -D
# or
pnpm add webpack-vite-serve -D</code></pre>
</div><h3 id="添加启动指令" tabindex="-1">添加启动指令 <a class="header-anchor" href="#添加启动指令" aria-label="Permalink to “添加启动指令”">&#8203;</a></h3>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::zke662r2bvpt21tu2pn4nn::--><code># devServer
wvs start [options]
# build
wvs build [options]</code></pre>
</div><h3 id="可选参数" tabindex="-1">可选参数 <a class="header-anchor" href="#可选参数" aria-label="Permalink to “可选参数”">&#8203;</a></h3>
<ul>
<li><code>-f,--framework &lt;type&gt;</code>：指定使用的业务框架 (vue，react)，自动引入业务框架相关的基础插件</li>
<li><code>-s,--spa</code>：按照单页应用目录结构处理 <code>src/${entryJs}</code></li>
<li><code>-m,--mpa</code>：按照多页应用目录结构处理 <code>src/pages/${entryName}/${entryJs}</code></li>
<li><code>-d,--debug [feat]</code>：打印debug信息</li>
<li><code>-w,--wp2vite</code>：使用 <a href="https://github.com/tnfe/wp2vite" target="_blank" rel="noreferrer">wp2vite</a> 自动转换webpack文件</li>
</ul>
<h3 id="其它说明" tabindex="-1">其它说明 <a class="header-anchor" href="#其它说明" aria-label="Permalink to “其它说明”">&#8203;</a></h3>
<p>项目遵循常规的 单页/多页应用 项目的目录结构即可</p>
<p>vite配置通过官方的<code>vite.config.[tj]s</code>配置文件拓展即可</p>
<h3 id="效果" tabindex="-1">效果 <a class="header-anchor" href="#效果" aria-label="Permalink to “效果”">&#8203;</a></h3>
<p><img src="./webapck2vite2/MTYzNjg3MzM4NzQzMQ==636873387431.png" alt="图片" loading="lazy"></p>
<p>在线体验demo地址：已创建<a href="https://stackblitz.com/edit/atqq-webpack-vite-serve-mstatq?devtoolsheight=33&amp;file=README.md" target="_blank" rel="noreferrer">stackblitz</a></p>
<p>如由于网络原因无法访问，可clone仓库访问其中demo体验</p>
<h2 id="mpa支持" tabindex="-1">MPA支持 <a class="header-anchor" href="#mpa支持" aria-label="Permalink to “MPA支持”">&#8203;</a></h2>
<h3 id="dev-页面模板" tabindex="-1">Dev-页面模板 <a class="header-anchor" href="#dev-页面模板" aria-label="Permalink to “Dev-页面模板”">&#8203;</a></h3>
<p>首先是<code>devServer</code>环境的页面模板处理</p>
<p>根据请求路径获取<code>entryName</code></p>
<ul>
<li>使用<code>/</code>拆分请求路径得到<code>paths</code></li>
<li>遍历寻找第一个<code>src/pages/${path}</code>存在的<code>path</code>,此path即为<code>entryName</code></li>
</ul>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::few9s6fe6htzmoils3raut::--><code>function getEntryName(reqUrl:string, cfg?:any) {
  const { pathname } = new URL(reqUrl, &#039;http://localhost&#039;);
  const paths = pathname.split(&#039;/&#039;).filter((v) =&gt; !!v);
  const entryName = paths.find((p) =&gt; existsSync(path.join(getCWD(), &#039;src/pages&#039;, p)));
  if (!entryName) {
    console.log(pathname, &#039;not match any entry&#039;);
  }
  return entryName || &#039;&#039;;
}</code></pre>
</div><p>寻找模板文件，按照如下顺序探寻</p>
<ul>
<li><code>src/pages/${entryName}/${entryName}.html</code></li>
<li><code>src/pages/${entryName}/index.html</code></li>
<li><code>public/${entryName}.html</code></li>
<li><code>public/index.html</code></li>
</ul>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::d8pqsffrndm49pe81gxisd::--><code>function loadHtmlContent(reqPath:string) {
  // 兜底页面
  const pages = [path.resolve(__dirname, &#039;../../public/index.html&#039;)];

  // 单页/多页默认 public/index.html
  pages.unshift(resolved(&#039;public/index.html&#039;));

  // 多页应用可以根据请求的 路径 作进一步的判断
  if (isMPA()) {
    const entryName = getEntryName(reqPath);
    if (entryName) {
      pages.unshift(resolved(`public/${entryName}.html`));
      pages.unshift(resolved(`src/pages/${entryName}/index.html`));
      pages.unshift(resolved(`src/pages/${entryName}/${entryName}.html`));
    }
  }
  const page = pages.find((v) =&gt; existsSync(v));
  return readFileSync(page, { encoding: &#039;utf-8&#039; });
}</code></pre>
</div><h3 id="dev-entryjs" tabindex="-1">Dev-entryJs <a class="header-anchor" href="#dev-entryjs" aria-label="Permalink to “Dev-entryJs”">&#8203;</a></h3>
<p>多页应用的<code>entryJs</code>就按约定读取<code>src/pages/${entryName}/${main|index}</code>文件</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::olhfx9v0nh3gw4oul4kge::--><code>function getPageEntry(reqUrl) {
  if (isMPA()) {
    const entryName = getEntryName(reqUrl);
    return !!entryName &amp;&amp; getEntryFullPath(`src/pages/${entryName}`);
  }
  // 默认SPA
  const SPABase = &#039;src&#039;;
  return getEntryFullPath(SPABase);
}</code></pre>
</div><h2 id="build" tabindex="-1">Build <a class="header-anchor" href="#build" aria-label="Permalink to “Build”">&#8203;</a></h2>
<p>vite构建的入口是<code>html</code>模板，可以通过<code>build.rollup.input</code>属性设置</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::qwvxgfu0n3nm4ja5x8c28::--><code>// vite.config.ts
import { defineConfig } from &#039;vite&#039;;

export default defineConfig({
  build: {
    rollupOptions: {
      input: {
        index: &#039;src/pages/index/index.html&#039;,
        second: &#039;src/pages/second/second.html&#039;,
      },
    },
  },
});</code></pre>
</div><p>按照如上配置，构建产物中的html目录将会如下</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::bzmvtsdda1t5ywvis0kq6a::--><code>* dist
  * src/pages/index/index.html
  * src/pages/second/second.html
  * assets</code></pre>
</div><p>不太符合通常的习惯，常规格式如下</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::0oo8rgf9fluhxt3z249vcvn::--><code>* dist
  * index.html
  * second.html
  * assets</code></pre>
</div><p>所以需要通过插件<code>处理构建入口文件</code>和<code>调整构建后的产物位置</code></p>
<h3 id="插件结构" tabindex="-1">插件结构 <a class="header-anchor" href="#插件结构" aria-label="Permalink to “插件结构”">&#8203;</a></h3>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::avhseip1qrrkz18hifo8t::--><code>export default function BuildPlugin(): PluginOption {
  let userConfig:ResolvedConfig = null;
  return {
    name: &#039;wvs-build&#039;,
    // 只在构建阶段生效
    apply: &#039;build&#039;,
    // 获取最终配置
    configResolved(cfg) {
      userConfig = cfg;
    },
    // 插件配置处理
    config() {

    },
    resolveId(id) {

    },
    load(id) {

    },
    // 构建完成后
    closeBundle() {

    },
  };
}</code></pre>
</div><p>通过<code>configResolved</code>钩子获取最终配置，配置提供给其它钩子使用</p>
<h3 id="获取entry" tabindex="-1">获取entry <a class="header-anchor" href="#获取entry" aria-label="Permalink to “获取entry”">&#8203;</a></h3>
<p>首先获取<code>src/pages</code>下所有的entry</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::oc79nsj121ltwwkbrjj02i::--><code>const entry = [];
if (isMPA()) {
  entry.push(...getMpaEntry());
} else {
  // 单页应用
  entry.push({
    entryName: &#039;index&#039;,
    entryHtml: &#039;public/index.html&#039;,
    entryJs: getEntryFullPath(&#039;src&#039;),
  });
}</code></pre>
</div><p>entry的定义为</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::e796jegmz95johaupb1fn::--><code>interface Entry{
  entryHtml:string
  entryName:string
  entryJs:string
}</code></pre>
</div><p>获取逻辑如下</p>
<ul>
<li>先获取所有的<code>EntryName</code></li>
<li>在遍历获取每个entry对应的<code>entryJs</code>与<code>entryHtml</code></li>
</ul>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::5nzlxke785pdnbzy4j3qih::--><code>export function getMpaEntry(baseDir = &#039;src/pages&#039;) {
  const entryNameList = readdirSync(resolved(baseDir), { withFileTypes: true })
    .filter((v) =&gt; v.isDirectory())
    .map((v) =&gt; v.name);

  return entryNameList
    .map((entryName) =&gt; ({ entryName, entryHtml: &#039;&#039;, entryJs: getEntryFullPath(path.join(baseDir, entryName)) }))
    .filter((v) =&gt; !!v.entryJs)
    .map((v) =&gt; {
      const { entryName } = v;
      const entryHtml = [
        resolved(`src/pages/${entryName}/${entryName}.html`),
        resolved(`src/pages/${entryName}/index.html`),
        resolved(`public/${entryName}.html`),
        resolved(&#039;public/index.html&#039;),
        path.resolve(__dirname, &#039;../../public/index.html&#039;),
      ].find((html) =&gt; existsSync(html));
      return {
        ...v,
        entryHtml,
      };
    });
}</code></pre>
</div><h3 id="生成构建配置" tabindex="-1">生成构建配置 <a class="header-anchor" href="#生成构建配置" aria-label="Permalink to “生成构建配置”">&#8203;</a></h3>
<p>根据得到的<code>entry</code>生成 <code>build.rollup.input</code></p>
<ul>
<li>获取每个<code>entryHtml</code>的内容,然后使用<code>map</code>进行临时的存储</li>
<li>构建入口模板路径<code>htmlEntryPath</code>取<code>entryJs</code>的目录加<code>index.html</code></li>
</ul>
<p>实际上<code>htmlEntryPath</code>这个路径并不存在任何文件</p>
<p>所以需要通过其它钩子，利用<code>htmlContentMap</code>存储的内容进行进一步的处理</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::yp2ud40osafr92y6xq2i::--><code>const htmlContentMap = new Map();
// 省略其它无关代码
{
  config() {
    const input = entry.reduce((pre, v) =&gt; {
      const { entryName, entryHtml, entryJs } = v;
      const html = getEntryHtml(resolved(entryHtml), path.join(&#039;/&#039;, entryJs));
      const htmlEntryPath = resolved(path.parse(entryJs).dir, tempHtmlName);
      // 存储内容
      htmlContentMap.set(htmlEntryPath, html);
      pre[entryName] = htmlEntryPath;
      return pre;
    }, {});
    return {
      build: {
        rollupOptions: {
          input,
        },
      },
    };
  }
}</code></pre>
</div><h3 id="构建入口内容生成" tabindex="-1">构建入口内容生成 <a class="header-anchor" href="#构建入口内容生成" aria-label="Permalink to “构建入口内容生成”">&#8203;</a></h3>
<p>其中<code>resolveId</code>与<code>load</code>钩子一起完成入口文件的处理</p>
<ul>
<li>其中<code>id</code>即为资源请求的路径</li>
<li>接着直接从<code>htmlContentMap</code>去除模板的内容即可</li>
</ul>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::0cszmcxj8znpgeq5vxehvkf::--><code>{
  load(id) {
    if (id.endsWith(&#039;.html&#039;)) {
      return htmlContentMap.get(id);
    }
    return null;
  },
  resolveId(id) {
    if (id.endsWith(&#039;.html&#039;)) {
      return id;
    }
    return null;
  },
}</code></pre>
</div><h3 id="产物目录调整" tabindex="-1">产物目录调整 <a class="header-anchor" href="#产物目录调整" aria-label="Permalink to “产物目录调整”">&#8203;</a></h3>
<p>使用<code>closeBundle</code>钩子，在构建完成后，服务关闭前进行文件调整</p>
<ul>
<li>遍历<code>entry</code>将<code>dist/src/pages/entryName/index.html</code>移动到<code>dist</code>下</li>
<li>移除<code>dist/src</code>下的内容</li>
</ul>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::fkgiuw1k50uvj6uxomqc7l::--><code>closeBundle() {
  const { outDir } = userConfig.build;
  // 目录调整
  entry.forEach((e) =&gt; {
    const { entryName, entryJs } = e;
    const outputHtmlPath = resolved(outDir, path.parse(entryJs).dir, tempHtmlName);
    writeFileSync(resolved(outDir, `${entryName}.html`), readFileSync(outputHtmlPath));
  });
  // 移除临时资源
  rmdirSync(resolved(outDir, &#039;src&#039;), { recursive: true });
}</code></pre>
</div><h2 id="webpack配置转换" tabindex="-1">webpack配置转换 <a class="header-anchor" href="#webpack配置转换" aria-label="Permalink to “webpack配置转换”">&#8203;</a></h2>
<p>目前社区有一个CLI工具：<a href="https://github.com/tnfe/wp2vite" target="_blank" rel="noreferrer">wp2vite</a>支持了这个功能，所以笔者不打算从0-1再建设一个</p>
<p>由于是cli工具，没有提供一些直接调用的方法去获取转换前后的配置，所以<strong>接入插件中的使用体验还不是很好，后续准备提PR改造一下这个工具</strong></p>
<p>接入wp2vite的插件实现如下</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::njbuzxpud4hh7cxdrtxcu5::--><code>import wp2vite from &#039;wp2vite&#039;;
// 省略不重要的 import
export default function wp2vitePlugin(): PluginOption {
  return {
    name: &#039;wvs-wp2vite&#039;,
    enforce: &#039;pre&#039;,
    async config(_, env) {
      const cfgFile = resolved(&#039;vite.config.js&#039;);
      const tplFile = resolved(&#039;index.html&#039;);
      const contentMap = new Map([[cfgFile, &#039;&#039;], [tplFile, &#039;&#039;]]);
      const files = [cfgFile, tplFile];

      console.time(&#039;wp2vite&#039;);
      // 判断是否存在vite.config.js 、index.html
      // 避免 wp2vite 覆盖
      files.forEach((f) =&gt; {
        if (existsSync(f)) {
          contentMap.set(f, readFileSync(f, { encoding: &#039;utf-8&#039; }));
        }
      });

      // 转换出配置文件vite.config.js
      await wp2vite.start(getCWD(), {
        force: false,
        // 统一开启debug
        debug: !!process.env.DEBUG,
      });

      // TODO:提PR优化
      // 转换耗时计算
      console.timeEnd(&#039;wp2vite&#039;);

      // 获取wp2vite转换出的配置
      const cfg = await getUserConfig(env, &#039;js&#039;);

      contentMap.forEach((v, k) =&gt; {
        if (v) {
          // 如果修改了内容，还原内容
          writeFileSync(k, v);
        } else {
          // 移除创建的文件
          unlinkSync(k);
        }
      });

      if (cfg.config) {
        const { config } = cfg || {};
        // 留下需要的配置
        return {
          resolve: config?.resolve,
          server: config?.server,
          css: config?.css,
        };
      }

      return null;
    },
  };
}</code></pre>
</div><p>wp2vite，对外暴露了一个<code>start</code>方法调用</p>
<p>调用后会根据项目的webpack配置生成2个新文件(<code>vite.config.js</code>，<code>index.html</code>)，并修改<code>package.json</code>添加指令与依赖</p>
<p>所以在生成前如果项目中存在这些文件则需要先将这些内容存储起来</p>
<p>其中获取用户配置的<code>getUserConfig</code>实现如下</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::q4nfusbmjmpcxg29wed4xq::--><code>import { loadConfigFromFile, ConfigEnv } from &#039;vite&#039;;

export function getUserConfig(configEnv:ConfigEnv, suffix = &#039;&#039;) {
  const configName = &#039;vite.config&#039;;
  const _suffix = [&#039;ts&#039;, &#039;js&#039;, &#039;mjs&#039;, &#039;cjs&#039;];
  if (suffix) {
    _suffix.unshift(suffix);
  }
  const configFile = _suffix.map((s) =&gt; `${configName}.${s}`).find((s) =&gt; existsSync(s));
  return loadConfigFromFile(configEnv, configFile);
}</code></pre>
</div><p>vite提供了<code>loadConfigFromFile</code>方法，只需要在此方法中做一层简单的封装即可直接使用，方法内部使用esbuild自动对ts与es语法进行了转换</p>
<h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">&#8203;</a></h2>
<p>到目前为止，建设的能力已基本能够满足常规项目的开发</p>
<p>能力未及之处用户亦可直接在工程中添加<code>vite</code>配置文件进行自行的拓展</p>
<h2 id="后续规划" tabindex="-1">后续规划 <a class="header-anchor" href="#后续规划" aria-label="Permalink to “后续规划”">&#8203;</a></h2>
<ol>
<li>目前<code>wp2vite</code>在配置转换这一块，还不能太满足使用要求，准备提PR增强一下</li>
<li>将内部能力抽成一个个单独的vite插件</li>
</ol>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/webapck2vite2/MTYzNjg3MzM4NzQzMQ==636873387431.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[ES6+的一些新语法糖和方法整理]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/js/es6+.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/js/es6+.html</guid>
            <pubDate>Wed, 13 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[只列举了比较实用的而又鲜为人知的一些，并不绝对全面
 ESNext
 ES2022
 ES2021
 ES2020
 1. 号创建类的私有变量
```ts
class p{
    name='xia]]></description>
            <content:encoded><![CDATA[<h1 id="es6-的一些新语法糖和方法整理" tabindex="-1">ES6+的一些新语法糖和方法整理 <a class="header-anchor" href="#es6-的一些新语法糖和方法整理" aria-label="Permalink to “ES6+的一些新语法糖和方法整理”">&#8203;</a></h1>
<p><strong>只列举了比较实用的而又鲜为人知的一些，并不绝对全面</strong></p>
<h2 id="esnext" tabindex="-1">ESNext <a class="header-anchor" href="#esnext" aria-label="Permalink to “ESNext”">&#8203;</a></h2>
<h2 id="es2022" tabindex="-1">ES2022 <a class="header-anchor" href="#es2022" aria-label="Permalink to “ES2022”">&#8203;</a></h2>
<h2 id="es2021" tabindex="-1">ES2021 <a class="header-anchor" href="#es2021" aria-label="Permalink to “ES2021”">&#8203;</a></h2>
<h2 id="es2020" tabindex="-1">ES2020 <a class="header-anchor" href="#es2020" aria-label="Permalink to “ES2020”">&#8203;</a></h2>
<h3 id="_1-号创建类的私有变量" tabindex="-1">1. #号创建类的私有变量 <a class="header-anchor" href="#_1-号创建类的私有变量" aria-label="Permalink to “1. #号创建类的私有变量”">&#8203;</a></h3>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::3gvun9dzf7m6wqgj0ymbkj::--><code>class p{
    #name=&#039;xiaoming&#039;
    getName(){
        return this.#name
    }
}
let a = new p()
console.log(a.getName());
// Property &#039;#name&#039; is not accessible outside class &#039;p&#039; because it has a private identifier.
console.log(a.#name);// error</code></pre>
</div><h3 id="_2-promise-allselected" tabindex="-1">2. Promise.allSelected <a class="header-anchor" href="#_2-promise-allselected" aria-label="Permalink to “2. Promise.allSelected”">&#8203;</a></h3>
<p>可以在回调中取到所有的promise的返回值与状态，包括rject的</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::ycenv4v9f9dqol7yaqrrw::--><code>class p {
    #name = &#039;xiaoming&#039;
    getName() {
        return this.#name
    }
}
let a = new p()
console.log(a.getName());
// console.log(a.#name);

const p1 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000, &#039;success&#039;))
const p2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 1000, &#039;fail&#039;))

Promise.allSettled([p1, p2]).then(res =&gt; {
    console.log(res);
    // [
    //     {status: &quot;fulfilled&quot;, value: &quot;success&quot;}
    //     {status: &quot;rejected&quot;, reason: &quot;fail&quot;}
    // ]
})</code></pre>
</div><h3 id="_3-空值运算符" tabindex="-1">3. 空值运算符?? <a class="header-anchor" href="#_3-空值运算符" aria-label="Permalink to “3. 空值运算符??”">&#8203;</a></h3>
<p>开发中通常会用||去做变量或者值初始化，但是对于空串和0这些有意义值，会有一些意料之外的结果此时就可以用??去替代</p>
<p>?? 运算符只会把 null 和 undefined 判断为 false</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::nctupcrytbbfw7qkcx3sz4::--><code>const user = {
    name: &#039;xiaoming&#039;,
    age: &#039;&#039;,
    height: 0
};
console.log(user.name || &#039;abc&#039;); // xiaoming
console.log(user.age || 18); // 18
console.log(user.height || 180); // 180
// 使用??
console.log(user.name ?? &#039;abc&#039;); // xiaoming
console.log(user.age ?? 18); // 
console.log(user.height ?? 180); // 0</code></pre>
</div><h3 id="_4-可选链运算符" tabindex="-1">4. 可选链运算符?. <a class="header-anchor" href="#_4-可选链运算符" aria-label="Permalink to “4. 可选链运算符?.”">&#8203;</a></h3>
<p>当需要访问嵌套在对象内部好几层的属性时,为了避免出现undefind的报错会使用&amp;&amp;去处理代码</p>
<p>使用可选链可让代码更加简洁明了</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::vzjlhhvrq4tgq5z6ji4tzm::--><code>let data = {}
// &amp;&amp;
console.log(data &amp;&amp; data.a &amp;&amp; data.a.b);

// ?.
console.log(data?.a?.b);</code></pre>
</div><h3 id="_5-globalthis" tabindex="-1">5. globalThis <a class="header-anchor" href="#_5-globalthis" aria-label="Permalink to “5. globalThis”">&#8203;</a></h3>
<p>globalThis 目的就是提供一种标准化方式访问全局对象，有了 globalThis 后，你可以在任意上下文，任意时刻都能获取到全局对象</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::7v66ui6r8bazihexzkyxf::--><code>// worker.js
globalThis === self
// node.js
globalThis === global
// browser.js
globalThis === window</code></pre>
</div><h2 id="es2019-es10" tabindex="-1">ES2019/ES10 <a class="header-anchor" href="#es2019-es10" aria-label="Permalink to “ES2019/ES10”">&#8203;</a></h2>
<h3 id="_1-array-flat" tabindex="-1">1. Array.flat <a class="header-anchor" href="#_1-array-flat" aria-label="Permalink to “1. Array.flat”">&#8203;</a></h3>
<p>展开数组</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::5xsfa0qvh53yhe078z4vzi::--><code>let arr = [1, 2, 3, [4, 5, 6, [7, 8, 9, [10, 11, 12]]]];

arr.flat(); // [1, 2, 3, 4, 5, 6, Array(4)];

arr.flat().flat(); // [1, 2, 3, 4, 5, 6, 7, 8, 9, Array(3)];

arr.flat(3); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

// 展开任意层级
arr.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</code></pre>
</div><h3 id="_2-array-flatmap" tabindex="-1">2. Array.flatMap <a class="header-anchor" href="#_2-array-flatmap" aria-label="Permalink to “2. Array.flatMap”">&#8203;</a></h3>
<p>与ES6Array.Map()方法相同，但同时也支持展平。该Array.flatMap()方法首先使用映射函数映射每个元素，然后将结果展平为新数组</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::z79j0xn8gbhnxt6gmxhn2b::--><code>let arr = [1, 2, 3, 4, 5];

arr.map(x =&gt; [x, x * 2]);
// [Array(2), Array(2), Array(2)]
// 0: (2)[1, 2]
// 1: (2)[2, 4]
// 2: (2)[3, 6]

arr.flatMap(v =&gt; [v, v * 2]);
// [1, 2, 2, 4, 3, 6, 4, 8, 5, 10]</code></pre>
</div><h3 id="_3-string-trimstart-string-trimend" tabindex="-1">3. String.trimStart() &amp; String.trimEnd() <a class="header-anchor" href="#_3-string-trimstart-string-trimend" aria-label="Permalink to “3. String.trimStart() &amp; String.trimEnd()”">&#8203;</a></h3>
<p>String.trimStart()可用于从字符串的开头去掉空白。String.trimEnd()可用于从字符串的尾部去掉空白</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::57idjoz3iaogbm9pise7k::--><code>let  greeting =  &quot;    Hello everyone&quot;;

console.log(greeting.trimStart());
// &quot;Hello everyone&quot;</code></pre>
</div><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::4p094oty5v7lujpvot8myd::--><code>let greeting = &quot;Hello world    &quot;;

console.log(greeting.trimEnd());
// &quot;Hello world&quot;</code></pre>
</div><h3 id="_4-可选-catch-binding" tabindex="-1">4. 可选 Catch Binding <a class="header-anchor" href="#_4-可选-catch-binding" aria-label="Permalink to “4. 可选 Catch Binding”">&#8203;</a></h3>
<p>允许开发人员在catch块中，不使用error参数的情况下使用try/catch</p>
<p>ES2019之前</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::lii0c3ofof8dcyp3znonz7::--><code>try {
  // some code
}
catch (err) {
  // error handling code
}</code></pre>
</div><p>现在可以</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::y8tca54jrkd4hpbpfytq5x::--><code>try  {
  // some code
}
catch {
  // error handling code
}</code></pre>
</div><h3 id="_5-object-fromentries" tabindex="-1">5. Object.fromEntries <a class="header-anchor" href="#_5-object-fromentries" aria-label="Permalink to “5. Object.fromEntries”">&#8203;</a></h3>
<p>Object.fromEntries()创建一个对象或将键值对转换为一个对象。它只接受Iterable</p>
<p>例如：Object.fromEntries(someIterable)</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::dgy7ltgtw47au6zd8r5hau::--><code>let entries = new Map([[&quot;name&quot;, &quot;john&quot;], [&quot;age&quot;, 22]]);

console.log(Object.fromEntries(entries));
// { name: &#039;john&#039;, age: 22 }</code></pre>
</div><h3 id="_6-symbol-description" tabindex="-1">6. Symbol.description <a class="header-anchor" href="#_6-symbol-description" aria-label="Permalink to “6. Symbol.description”">&#8203;</a></h3>
<p>只读描述属性，是一个返回Symbol对象的可选描述的字符串</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::rzl9zp0htiqdlgxnmf35jb::--><code>let mySymbol = `My Symbol`;

let symObj = Symbol(mySymbol);

console.log(symObj) // Symbol(mySymbol);

console.log(String(symObj) === `Symbol(${mySymbol})`); // true

console.log(symObj.description); // &quot;My Symbol&quot;</code></pre>
</div><h2 id="es2018-es9" tabindex="-1">ES2018/ES9 <a class="header-anchor" href="#es2018-es9" aria-label="Permalink to “ES2018/ES9”">&#8203;</a></h2>
<h3 id="_1-for-await-of" tabindex="-1">1. for await of <a class="header-anchor" href="#_1-for-await-of" aria-label="Permalink to “1. for await of”">&#8203;</a></h3>
<p>for of方法能够遍历具有Symbol.iterator接口的同步迭代器数据，但是不能遍历异步迭代器</p>
<p>for await of可以用来遍历具有Symbol.asyncIterator方法的数据结构，也就是异步迭代</p>
<p><strong>for of遍历</strong></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::jh462rdk66l6ykx1ws796v::--><code>function d(timeout: number) {
    return new Promise((res, rej) =&gt; {
        setTimeout(() =&gt; {
            res(timeout)
        }, timeout)
    })
}
let data = [d(1000), d(500), d(1200)]

for (const v of data) {
    v.then(console.log)
}
// 500
// 1000
// 1200</code></pre>
</div><p><strong>for await of</strong></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::a3a1eulkwmaq3q833z5j8::--><code>function d(timeout: number) {
    return new Promise((res, rej) =&gt; {
        setTimeout(() =&gt; {
            res(timeout)
        }, timeout)
    })
}
let data = [d(1000), d(500), d(1200)]
async function test() {
    for await (const v of data) {
        console.log(v);
    }
}
test();
// 1000
// 500
// 1200</code></pre>
</div><h3 id="_2-新的正则表达式特性" tabindex="-1">2. 新的正则表达式特性 <a class="header-anchor" href="#_2-新的正则表达式特性" aria-label="Permalink to “2. 新的正则表达式特性”">&#8203;</a></h3>
<p><strong>2.1 s(dotAll)模式</strong></p>
<p>元字符<code>.</code>无法匹配换行符,可以通过 s(doAll)flag解决</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::zgsiilomhg8q1hcjueu3g::--><code>console.log(/foo.bar/.test(&#039;foo\nbar&#039;)); // false

// 使用 s
console.log(/foo.bar/s.test(&#039;foo\nbar&#039;)); // true</code></pre>
</div><p><strong>2.2 命名捕获组</strong></p>
<p>在一些正则表达式模式中，使用数字进行匹配可能会令人混淆</p>
<p>命名捕获组，允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::sdhi1mrzfpj26lddr92x08i::--><code>const re = /(\d{4})-(\d{2})-(\d{2})/;
const match= re.exec(&#039;2020-01-01&#039;);
console.log(match[0]);    // 2020-01-01
console.log(match[1]);    // 2020
console.log(match[2]);    // 01
console.log(match[3]);    // 01</code></pre>
</div><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::rnko9eunsbrur5rkx9dlk::--><code>const re = /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/;
const match = re.exec(&#039;2020-01-01&#039;);
console.log(match.groups);          // { year: &#039;2020&#039;, month: &#039;01&#039;, day: &#039;01&#039; }
console.log(match.groups.year);     // 2020
console.log(match.groups.month);    // 01
console.log(match.groups.day);      // 01</code></pre>
</div><p>使用replace</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::npv4nsod9eku9qgyxucn::--><code>const re = /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/
console.log(&#039;2020-09-01&#039;.replace(re, &#039;$&lt;month&gt;-$&lt;day&gt;-$&lt;year&gt;&#039;)) // 09-01-2020</code></pre>
</div><h2 id="es2017-es8" tabindex="-1">ES2017/ES8 <a class="header-anchor" href="#es2017-es8" aria-label="Permalink to “ES2017/ES8”">&#8203;</a></h2>
<h3 id="_1-object-values-object-entries" tabindex="-1">1. Object.values()，Object.entries() <a class="header-anchor" href="#_1-object-values-object-entries" aria-label="Permalink to “1. Object.values()，Object.entries()”">&#8203;</a></h3>
<p>Object.values方法返回一个数组，其值由对象的值组成</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::78jcnb8sciez8m4fydl69i::--><code>const obj = { a: &#039;1&#039;, b: &#039;2&#039; }
console.log(Object.values(obj));
// [ &#039;1&#039;, &#039;2&#039; ]</code></pre>
</div><p>Object.entries()方法返回一个数组,其值为[key,value]</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::hpqfxo7zcgpf68uuj5t3lq::--><code>const obj = { a: &#039;1&#039;, b: &#039;2&#039; }
console.log(Object.entries(obj));
// [ [ &#039;a&#039;, &#039;1&#039; ], [ &#039;b&#039;, &#039;2&#039; ] ]</code></pre>
</div><h3 id="_2-string-padding" tabindex="-1">2. String padding <a class="header-anchor" href="#_2-string-padding" aria-label="Permalink to “2. String padding”">&#8203;</a></h3>
<p><strong>String.prototype.padStart</strong></p>
<p>在字符串之前补全字符</p>
<p><strong>String.prototype.padEnd</strong></p>
<p>在字符串之后补全</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::7bchkgh5ssn1fn75nnxyz::--><code>console.log(&#039;llo&#039;.padStart(5, &#039;hello&#039;)); // hello
console.log(&#039;0&#039;.padEnd(5, &#039;123&#039;)); // 01231</code></pre>
</div><h3 id="_3-object-getownpropertydescriptors" tabindex="-1">3 Object.getOwnPropertyDescriptors() <a class="header-anchor" href="#_3-object-getownpropertydescriptors" aria-label="Permalink to “3 Object.getOwnPropertyDescriptors()”">&#8203;</a></h3>
<p>获取指定对象的属性描述符</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::b3momzw305ytzmbyi3sl::--><code>const obj = { a: 1 };
console.log(Object.getOwnPropertyDescriptor(obj, &#039;a&#039;));
// { value: 1, writable: true, enumerable: true, configurable: true }</code></pre>
</div><h2 id="es2016-es7" tabindex="-1">ES2016/ES7 <a class="header-anchor" href="#es2016-es7" aria-label="Permalink to “ES2016/ES7”">&#8203;</a></h2>
<h3 id="_1-求幂运算符" tabindex="-1">1. 求幂运算符** <a class="header-anchor" href="#_1-求幂运算符" aria-label="Permalink to “1. 求幂运算符**”">&#8203;</a></h3>
<p>效果跟<code>Math.pow(x,y)</code>一致</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::od5usesq7aqsa66em21uff::--><code>console.log(2**10); // 1024
console.log(Math.pow(2,10)); // 1024</code></pre>
</div><h3 id="_2-array-prototype-includes" tabindex="-1">2. Array.prototype.includes <a class="header-anchor" href="#_2-array-prototype-includes" aria-label="Permalink to “2. Array.prototype.includes”">&#8203;</a></h3>
<p>用法跟String.prototype.includes一致，可读性高于indexOf()</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::51ysub2u026w5mwczfp5k::--><code>const arr = [1, 2, &#039;hello&#039;]
console.log(arr.includes(&#039;hello&#039;)); // true</code></pre>
</div><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to “参考”">&#8203;</a></h2>
<ul>
<li><a href="https://www.digitalocean.com/community/tutorials/js-es2020" target="_blank" rel="noreferrer">What's new in ECMAScript 2020 (ES2020)</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/js-es2019" target="_blank" rel="noreferrer">What's new in ECMAScript 2019 (ES2019) / ES10</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for-await...of" target="_blank" rel="noreferrer">for await...of</a></li>
<li><a href="https://2ality.com/2017/05/regexp-named-capture-groups.html" target="_blank" rel="noreferrer">ES2018: RegExp named capture groups</a></li>
<li><a href="https://github.com/tc39/proposal-regexp-named-groups" target="_blank" rel="noreferrer">TC39:RegExp Named Capture Groups</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials?q=String+padding" target="_blank" rel="noreferrer">String padding</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" target="_blank" rel="noreferrer">Object.getOwnPropertyDescriptor()</a></li>
<li><a href="https://kangax.github.io/compat-table/es2016plus/" target="_blank" rel="noreferrer">compat-table/es2016plus/</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[解决Vite-React项目中js使用jsx语法报错的问题]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/vite-react-js.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/vite-react-js.html</guid>
            <pubDate>Tue, 12 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[背景
在做存量项目接入Vite测试时发现，存量（老）项目中很多是直接在js中书写jsx语法，使用Vite启动时就会抛出一堆问题`Failed to parse source`。
不嫌麻烦可以跑个脚本批]]></description>
            <content:encoded><![CDATA[<h1 id="解决vite-react项目中js使用jsx语法报错的问题" tabindex="-1">解决Vite-React项目中js使用jsx语法报错的问题 <a class="header-anchor" href="#解决vite-react项目中js使用jsx语法报错的问题" aria-label="Permalink to “解决Vite-React项目中js使用jsx语法报错的问题”">&#8203;</a></h1>
<h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to “背景”">&#8203;</a></h2>
<p>在做存量项目接入Vite测试时发现，存量（老）项目中很多是直接在js中书写jsx语法，使用Vite启动时就会抛出一堆问题<code>Failed to parse source</code>。</p>
<p>不嫌麻烦可以跑个脚本<strong>批量修改文件类型，这是一个解决办法</strong>。</p>
<p>为了刨根知底，同时为了存量项目最低成本的接入Vite使用，尽力避免修改业务代码。得寻找其它办法解决一下。</p>
<p>报错截图如下</p>
<p><img src="./vite-react-js/MTYzNDAxNjYxMzEyNg==634016613126.png" alt="图片" loading="lazy"></p>
<h2 id="复现问题" tabindex="-1">复现问题 <a class="header-anchor" href="#复现问题" aria-label="Permalink to “复现问题”">&#8203;</a></h2>
<p>初始化demo项目</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::9c44hhlp3i6cf8sm761p3::--><code># npm 6.x
npm init vite@latest my-react-app --template react-ts

# npm 7+, extra double-dash is needed:
npm init vite@latest my-react-app -- --template react-ts

# yarn
yarn create vite my-react-app --template react-ts</code></pre>
</div><p>目录如下</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::043of0uiciz9gwsc3urn3b9::--><code>├── index.html
├── package.json
├── src
|  ├── App.css
|  ├── App.tsx
|  ├── favicon.svg
|  ├── index.css
|  ├── logo.svg
|  ├── main.tsx
|  └── vite-env.d.ts
├── tsconfig.json
└── vite.config.ts</code></pre>
</div><p>启动</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::rx2l399sa3ik1z2yv201o::--><code>npm run dev</code></pre>
</div><p><img src="./vite-react-js/MTYzNDAxNTk3NjAwNQ==634015976005.png" alt="图片" loading="lazy"></p>
<p>页面正常，接下来将<code>App.tsx</code>修改为<code>App.js</code></p>
<p>将会得到上述的报错</p>
<p><img src="./vite-react-js/MTYzNDAxNjA0ODYwMw==634016048603.png" alt="图片" loading="lazy"></p>
<h2 id="原因" tabindex="-1">原因 <a class="header-anchor" href="#原因" aria-label="Permalink to “原因”">&#8203;</a></h2>
<ol>
<li>Vite在启动时会做<a href="https://cn.vitejs.dev/guide/dep-pre-bundling.html#the-why" target="_blank" rel="noreferrer">依赖的预构建</a></li>
<li><code>预构建</code>，<code>运行时</code>默认都只会对<code>jsx</code>与<code>tsx</code>做语法转换。不会对js做jsx的语法转换。</li>
</ol>
<p><img src="./vite-react-js/MTYzNDAxNjg3ODYwMg==634016878602.png" alt="图片" loading="lazy"></p>
<h2 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to “解决方案”">&#8203;</a></h2>
<ol>
<li>修改依赖预构建的配置</li>
<li>使用babel插件<code>@babel/plugin-transform-react-jsx</code>，让Vite在运行时对js文件转换</li>
</ol>
<p><img src="./vite-react-js/MTYzNDAxNzQyNDM2Mg==634017424362.png" alt="图片" loading="lazy"></p>
<p>按照文档描述在配置文件添加一点配置</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::2vr74uee7lv6fk90w3pey::--><code>export default defineConfig({
  build:{
    rollupOptions:{
      input:[]
    }
  },
  optimizeDeps: {
    entries: [],
  },
})</code></pre>
</div><p>通过阅读<code>@vite/plugin-react</code>的<a href="https://github.com/vitejs/vite/tree/main/packages/plugin-react" target="_blank" rel="noreferrer">文档</a>,发现其支持传入babel插件</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::ixzitucq6fjt2ac3vam2f::--><code>npm i @babel/plugin-transform-react-jsx</code></pre>
</div><p>添加插件</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::a39dg5iav7ctxf2inllqdo::--><code>import { defineConfig } from &#039;vite&#039;
import react from &#039;@vitejs/plugin-react&#039;

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react({
      babel: {
        plugins: [&#039;@babel/plugin-transform-react-jsx&#039;],
      },
  })],
})</code></pre>
</div><p>再次启动验证,发现一个报错</p>
<p><img src="./vite-react-js/MTYzNDAxNzg4NjY4OQ==634017886689.png" alt="图片" loading="lazy"></p>
<p>原因是没有在App.js中引入<code>React</code>,咱们引入一下</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::867vee7y3qjy48rqtvmum::--><code>import React,{ useState } from &#039;react&#039;</code></pre>
</div><p>大功告成</p>
<p><img src="./vite-react-js/MTYzNDAxODAxNTMxMw==634018015313.png" alt="图片" loading="lazy"></p>
<h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">&#8203;</a></h2>
<p>两种处理方案</p>
<ol>
<li>文件后缀 js =&gt; jsx</li>
<li>修改依赖预构建配置，再添加babel插件<code>@babel/plugin-transform-react-jsx</code></li>
</ol>
<p>第二种方法会一定程度影响项目的启动速度。读者可以根据实际项目情况pick方案</p>
<h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>欢迎大家在评论区共享/交流在开发过程中接入Vite时遇到的一些问题与总结的经验</p>
<ul>
<li><a href="https://github.com/ATQQ/demos/tree/main/vite-react-js" target="_blank" rel="noreferrer">源码地址</a></li>
</ul>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/vite-react-js/MTYzNDAxNjYxMzEyNg==634016613126.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[模板工程搭建：Web-SDK/Library]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/tpl/web-sdk-tpl.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/tpl/web-sdk-tpl.html</guid>
            <pubDate>Tue, 05 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[此系列会与时俱进的不断更新
包含Node/Web SDK，单组件，组件库，Eslint插件，Webpack插件，Vite插件，MonoRepo等等工程化相关能力的模板建设
 前言
在Web开发中，通常]]></description>
            <content:encoded><![CDATA[<h1 id="模板工程搭建-web-sdk-library" tabindex="-1">模板工程搭建：Web-SDK/Library <a class="header-anchor" href="#模板工程搭建-web-sdk-library" aria-label="Permalink to “模板工程搭建：Web-SDK/Library”">&#8203;</a></h1>
<p>此系列会与时俱进的不断更新</p>
<p>包含Node/Web SDK，单组件，组件库，Eslint插件，Webpack插件，Vite插件，MonoRepo等等工程化相关能力的模板建设</p>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>在Web开发中，通常会把一些常用的方法，一个技术产品做成一个SDK或者Library（库）的形式，方便调用方直接接入使用</p>
<p>其中库/SDK又分为框架相关和框架无关的，本文主要介绍<strong>框架无关的 Web JS SDK/Library</strong>工程模板搭建，下文统称为<code>Lib（库）</code></p>
<h2 id="一点定义" tabindex="-1">一点定义 <a class="header-anchor" href="#一点定义" aria-label="Permalink to “一点定义”">&#8203;</a></h2>
<p>产品定位是SDK还是工具库，取决于构建产物的功能与适用范围，两者之间的定位不绝对，工具库在不断的迭代过程中也可变为一个SDK</p>
<h3 id="sdk-软件开发工具包" tabindex="-1">SDK（软件开发工具包） <a class="header-anchor" href="#sdk-软件开发工具包" aria-label="Permalink to “SDK（软件开发工具包）”">&#8203;</a></h3>
<p>包含一些列功能的库，这些功能通常由多个库或者sdk组合提供</p>
<p>如一个获取天气的SDK，可能包含定位sdk，网络请求库，资源处理库，数据库操作sdk等</p>
<h3 id="lib-库" tabindex="-1">Lib（库） <a class="header-anchor" href="#lib-库" aria-label="Permalink to “Lib（库）”">&#8203;</a></h3>
<p>库是功能的集合，如<code>chalk</code>,<code>loadsh</code>,<code>debug</code>等等常用工具库，包含了一系列的工具方法或者某一类功能的方法集合</p>
<h2 id="库运行环境" tabindex="-1">库运行环境 <a class="header-anchor" href="#库运行环境" aria-label="Permalink to “库运行环境”">&#8203;</a></h2>
<p>通常是在浏览器或者Webview控件中</p>
<h2 id="使用方法" tabindex="-1">使用方法 <a class="header-anchor" href="#使用方法" aria-label="Permalink to “使用方法”">&#8203;</a></h2>
<h3 id="cdn" tabindex="-1">CDN <a class="header-anchor" href="#cdn" aria-label="Permalink to “CDN”">&#8203;</a></h3>
<blockquote>
<p>静态资源通常使用<code>OSS</code>存储，通过<code>CDN</code>下发，所以通常叫做<code>通过CDN引入资源</code></p>
</blockquote>
<p>在<code>html</code>模板中通过<code>script</code>引入库的js资源，某些还需引入相应的css资源</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::8iv74mvtxkuq43gvqr2ap::--><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.example.com/path/sdk-version/sdk-name/style.css&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.example.com/path/sdk-version/sdk-name.css&quot;&gt;

&lt;script src=&quot;//cdn.example.com/path/sdk-version/sdk-name/index.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;//cdn.example.com/path/sdk-version/sdk-name/index.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;//cdn.example.com/path/sdk-version/sdk-name.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;//cdn.example.com/path/sdk-version/sdk-name.min.js&quot;&gt;&lt;/script&gt;</code></pre>
</div><h3 id="npm-package" tabindex="-1">NPM Package <a class="header-anchor" href="#npm-package" aria-label="Permalink to “NPM Package”">&#8203;</a></h3>
<p>现代前端开发通常都会使用前端构建工具</p>
<p>因此除了通过CDN引入外，就是通过<code>包管理工具</code>将库的依赖安装到项目中，然后在源码中进行引入使用</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::99qjdxc5dnn9k78ob0otl::--><code>import pkgName, { methodName } from &#039;pkgName&#039;
import &#039;pkgName/dist/style.css&#039;</code></pre>
</div><h2 id="准备工作" tabindex="-1">准备工作 <a class="header-anchor" href="#准备工作" aria-label="Permalink to “准备工作”">&#8203;</a></h2>
<h3 id="项目初始化" tabindex="-1">项目初始化 <a class="header-anchor" href="#项目初始化" aria-label="Permalink to “项目初始化”">&#8203;</a></h3>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::hakiit5hfrdgz8yj4efyo::--><code>mkdir web-lib-template

cd web-lib-template

npm init  -y</code></pre>
</div><h3 id="git初始化" tabindex="-1">Git初始化 <a class="header-anchor" href="#git初始化" aria-label="Permalink to “Git初始化”">&#8203;</a></h3>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::4uhg2o9m24g8ogvmiisaf9::--><code>git init</code></pre>
</div><p><code>.gitignore</code>内容</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::2fg8n2wldrixa2qetsmgw::--><code>node_modules
dist</code></pre>
</div><h3 id="安装依赖" tabindex="-1">安装依赖 <a class="header-anchor" href="#安装依赖" aria-label="Permalink to “安装依赖”">&#8203;</a></h3>
<p>这里使用新一代的包管理工具 <a href="https://www.pnpm.cn/" target="_blank" rel="noreferrer">pnpm</a></p>
<p>安装pnpm指令</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::ou3o70g5zoy22eb8uj2bd::--><code>npm install -g pnpm</code></pre>
</div><p>装依赖</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::edgim252ulq7j5f97elk::--><code>pnpm add -D typescript rimraf vite eslint tslib core-js @rollup/plugin-typescript @microsoft/api-extractor</code></pre>
</div><ul>
<li><code>@microsoft/api-extractor</code>：汇总产物中的类型定义</li>
<li><code>@rollup/plugin-typescript</code>：用于构建阶段TS的转换</li>
<li><code>core-js</code>：用于js polyfill支持</li>
<li><code>tslib</code>：为TS提供一些辅助方法，Runtime library for TypeScript helper functions</li>
<li><code>eslint</code>：代码规范</li>
<li><code>vite</code>：开发阶段测试，与库的最终构建（Rollup提供构建能力）</li>
<li><code>rimraf</code>：替代<code>rm -rf</code>指令用于清理不需要的资源</li>
<li><code>typescript</code>：TS支持</li>
</ul>
<h3 id="typescript配置" tabindex="-1">typescript配置 <a class="header-anchor" href="#typescript配置" aria-label="Permalink to “typescript配置”">&#8203;</a></h3>
<p>创建<code>tsconfig.json</code>配置文件</p>
<p>只包含一些基础配置信息，其中</p>
<ul>
<li><code>declarationDir</code>：标识类型定文件的输出目录</li>
</ul>
<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre><!--::markdown-it-async::wyd8e0oog5whsjnutdcg::--><code>{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;ESNext&quot;,
    &quot;module&quot;: &quot;ESNext&quot;,
    &quot;lib&quot;: [&quot;ESNext&quot;, &quot;DOM&quot;],
    &quot;moduleResolution&quot;: &quot;Node&quot;,
    &quot;strict&quot;: true,
    &quot;sourceMap&quot;: true,
    &quot;resolveJsonModule&quot;: true,
    &quot;esModuleInterop&quot;: true,
    &quot;noImplicitThis&quot;: false,
    &quot;noImplicitAny&quot;: false,
    &quot;declaration&quot;: true,
    &quot;declarationDir&quot;: &quot;./dist&quot;,
    &quot;noUnusedLocals&quot;: true,
    &quot;noUnusedParameters&quot;: true,
    &quot;noImplicitReturns&quot;: true,
    &quot;downlevelIteration&quot;: true,
  },
  &quot;include&quot;: [
    &quot;src/**/*&quot;,
   ],
  &quot;exclude&quot;: [
    &quot;node_modules&quot;
  ]
}</code></pre>
</div><h3 id="初始化src源码目录" tabindex="-1">初始化src源码目录 <a class="header-anchor" href="#初始化src源码目录" aria-label="Permalink to “初始化src源码目录”">&#8203;</a></h3>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::828sar3uunf9lmgxfyt58l::--><code>src
├── constants
|  └── index.ts
├── index.ts
├── lib
|  └── pkg.ts
├── styles
|  ├── index.css
|  └── second.css
├── types
|  └── index.ts
└── utils
   └── index.ts</code></pre>
</div><p>一点说明</p>
<ul>
<li><code>文件 src/index.ts</code>：主要用于模块内容的导出</li>
<li><code>目录 src/lib</code>：主要用于存放库的核心源码</li>
<li><code>目录 src/types</code>：TS定义文件</li>
<li><code>目录 src/styles</code>：样式文件</li>
<li><code>目录 src/constants</code>：常量</li>
<li><code>目录 src/utils</code>：工具方法</li>
</ul>
<p>简单添加一些源码，完整请移步<a href="https://github.com/ATQQ/web-lib-template" target="_blank" rel="noreferrer">GitHub</a></p>
<p><code>src/index.ts</code></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::llm5fvfrugo5riab82kzyx::--><code>export { default } from &#039;./lib/pkg&#039;;
export type { DataItem } from &#039;./types/index&#039;;</code></pre>
</div><h2 id="构建相关配置" tabindex="-1">构建相关配置 <a class="header-anchor" href="#构建相关配置" aria-label="Permalink to “构建相关配置”">&#8203;</a></h2>
<h3 id="vite配置" tabindex="-1">Vite配置 <a class="header-anchor" href="#vite配置" aria-label="Permalink to “Vite配置”">&#8203;</a></h3>
<p><code>vite.config.js</code>文件</p>
<ul>
<li>Vite构建能力由Rollup提供，因此大部分Rollup插件可以直接复用</li>
</ul>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::l1mkvgm286tjj0z9ej1d::--><code>const path = require(&#039;path&#039;);
const typescript = require(&#039;@rollup/plugin-typescript&#039;);
const { defineConfig } = require(&#039;vite&#039;);

const libName = &#039;LibName&#039;;
const bundlePrefix = &#039;index&#039;;

// 入口
const entry = path.resolve(__dirname, &#039;src/index.ts&#039;);

module.exports = defineConfig({
  plugins: [
    typescript({
      target: &#039;es5&#039;,
      include: [&#039;src/**/*.ts&#039;],
      esModuleInterop: true,
      module: &#039;esnext&#039;,
    }),
  ],
  build: {
    sourcemap: true,
    outDir: &#039;dist&#039;,
    minify: &#039;esbuild&#039;,
    lib: {
      entry,
      name: libName,
      formats: [&#039;umd&#039;, &#039;cjs&#039;, &#039;es&#039;],
      fileName: (format) =&gt; {
        if (format === &#039;umd&#039;) {
          return `${bundlePrefix}.min.js`;
        }
        return `${bundlePrefix}.${format}.js`;
      },
    },
    rollupOptions: {
      input: entry,
      output: {
        exports: &#039;auto&#039;,
      },
    },
  },
  server: {
    host: &#039;0.0.0.0&#039;,
  },
});</code></pre>
</div><p><code>build</code>下的配置释义</p>
<ul>
<li>outDir：构建输出目录</li>
<li>lib
<ul>
<li>entry：构建入口文件<code>src/index.ts</code></li>
<li>name：库的名称，挂载在<code>globalThis</code>上的名称</li>
<li>formats：产物包含的格式，这里指定了常见的4种</li>
<li>fileName：针对不同格式，修改一下产物的名称</li>
</ul>
</li>
</ul>
<h3 id="完善pkg-json" tabindex="-1">完善pkg.json <a class="header-anchor" href="#完善pkg-json" aria-label="Permalink to “完善pkg.json”">&#8203;</a></h3>
<p><code>package.json</code></p>
<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre><!--::markdown-it-async::kwfrhy2mcpm5fute1tv18y::--><code>{
  &quot;main&quot;: &quot;dist/index.cjs.js&quot;,
  &quot;module&quot;: &quot;dist/index.es.js&quot;,
  &quot;types&quot;: &quot;dist/index.d.ts&quot;,
  &quot;scripts&quot;: {
    &quot;build:dev&quot;: &quot;vite build -w&quot;,
    &quot;build&quot;: &quot;rimraf dist &amp;&amp; vite build&quot;,
  },
}</code></pre>
</div><ol>
<li>添加构建相关指令
<ul>
<li>其中 <code>build:dev</code>主要用于开发调试，监听文件变更，有变更自动进行重新构建</li>
</ul>
</li>
<li>表明入口文件信息
<ul>
<li><code>main</code>：设置cjs规范的文件</li>
<li><code>module</code>；设置ESM规范的文件</li>
</ul>
</li>
</ol>
<h3 id="执行构建" tabindex="-1">执行构建 <a class="header-anchor" href="#执行构建" aria-label="Permalink to “执行构建”">&#8203;</a></h3>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::w4asv3yi6dn73h70yvxfg7::--><code>npm run build:dev</code></pre>
</div><h3 id="产物说明" tabindex="-1">产物说明 <a class="header-anchor" href="#产物说明" aria-label="Permalink to “产物说明”">&#8203;</a></h3>
<p>构建产物如下</p>
<p><img src="./web-sdk-tpl/MTYzMzUzMjA5MTQ4MQ==633532091481.png" alt="图片" loading="lazy"></p>
<ul>
<li>*.cjs.js：构建工具引用</li>
<li>*.es.js：支持ESM的构建工具使用</li>
<li>index.min.js：CDN引入使用，其中UMD兼容AMD，commonJS，全局引用等等方式</li>
</ul>
<h3 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to “注意事项”">&#8203;</a></h3>
<p>针对<code>index.min.js</code>（CDN引入使用）的一点说明</p>
<p>入口文件除类型导出外，如果只包含<code>export default VarName1</code>，那么<code>globalThis.LibName</code>就等于<code>VarName1</code></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::beuwo3c25yefsor2xsxfle::--><code>export type { DataItem } from &#039;./types/index&#039;;
export default function Demo1() {}

// 编译后
(function(global, factory) {
  typeof exports === &quot;object&quot; &amp;&amp; typeof module !== &quot;undefined&quot; ? module.exports = factory() : typeof define === &quot;function&quot; &amp;&amp; define.amd ? define(factory) : (global = typeof globalThis !== &quot;undefined&quot; ? globalThis : global || self, global.LibName = factory());
})(this, function() {
  &quot;use strict&quot;;
  function Demo1() {
  }
  return Demo1;
});</code></pre>
</div><p>如果包含其它导出<code>export const vaeName2</code>，那么<code>globalThis.LibName</code>就等于<code>VarName1.default</code></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::renadyc90oruz185w31kk::--><code>export type { DataItem } from &#039;./types/index&#039;;
export default function Demo1() {}
export function Demo2() {}

// 编译后
(function(global, factory) {
  typeof exports === &quot;object&quot; &amp;&amp; typeof module !== &quot;undefined&quot; ? factory(exports) : typeof define === &quot;function&quot; &amp;&amp; define.amd ? define([&quot;exports&quot;], factory) : (global = typeof globalThis !== &quot;undefined&quot; ? globalThis : global || self, factory(global.LibName = {}));
})(this, function(exports2) {
  &quot;use strict&quot;;
  function Demo1() {
  }
  function Demo2() {
  }
  exports2.Demo2 = Demo2;
  // 关键代码
  exports2[&quot;default&quot;] = Demo1;
  Object.defineProperty(exports2, &quot;__esModule&quot;, { value: true });
  exports2[Symbol.toStringTag] = &quot;Module&quot;;
});</code></pre>
</div><p>如果的确需要有导出多个，那么建议</p>
<ul>
<li>方式1：都是具名的导出</li>
<li>方式2：通过default导出一个对象，里面包含LibName</li>
</ul>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::8ifrk06ezu5szv02tcqju::--><code>// 方式1
export function fun1(){}
export const var1 = 1
export class LibName{

}

// 方式2
class LibName{

}
export default {
  fun1(){},
  var1:1,
  libName
}</code></pre>
</div><h2 id="开发测试" tabindex="-1">开发测试 <a class="header-anchor" href="#开发测试" aria-label="Permalink to “开发测试”">&#8203;</a></h2>
<h3 id="pkg" tabindex="-1">PKG <a class="header-anchor" href="#pkg" aria-label="Permalink to “PKG”">&#8203;</a></h3>
<p>在工程中执行如下指令，在全局创建一个软链接（执行一次即可）</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::rv8qwr6pi5lquq8f674pi::--><code>npm link</code></pre>
</div><p><img src="./web-sdk-tpl/MTYzMzUwMzk3NDAzOA==633503974038.png" alt="图片" loading="lazy"></p>
<p>在要测试的项目中引用</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::7u1aqs3v7ua9b5j3953on::--><code>npm link pkgName</code></pre>
</div><p><img src="./web-sdk-tpl/MTYzMzUwNDM0NDkwMQ==633504344901.png" alt="图片" loading="lazy"></p>
<p>运行示例</p>
<p><img src="./web-sdk-tpl/MTYzMzUwNDYyMDY3Mg==633504620672.png" alt="图片" loading="lazy"></p>
<h3 id="cdn-1" tabindex="-1">CDN <a class="header-anchor" href="#cdn-1" aria-label="Permalink to “CDN”">&#8203;</a></h3>
<p>本地在./dist目录下起一个Server服务，推荐使用<code>http-server</code></p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::12bswwm21hrlw3eymokb72::--><code># 安装http-server
npm i -g http-server</code></pre>
</div><p>在 dist目录下执行<code>http-server</code></p>
<p><img src="./web-sdk-tpl/MTYzMzUwNDkzMDA5Nw==633504930097.png" alt="图片" loading="lazy"></p>
<p>测试页面中引入</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::bi1o5uybzhn19houdimfh8::--><code>&lt;script src=&quot;http://127.0.0.1:8080/index.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  new LibName(&#039;test&#039;).sayHello()
&lt;/script&gt;</code></pre>
</div><p><img src="./web-sdk-tpl/MTYzMzUzMjk5MTk0MA==633532991940.png" alt="图片" loading="lazy"></p>
<h3 id="vite" tabindex="-1">Vite <a class="header-anchor" href="#vite" aria-label="Permalink to “Vite”">&#8203;</a></h3>
<p>vite本身就是一个支持ESM的Server，在项目中测试使用完全没问题他</p>
<p>根目录创建一个<code>index.html</code>,在其中加入以下代码</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::xd84luew54e9py7nok9fc::--><code>&lt;body&gt;
    &lt;script type=&quot;module&quot;&gt;
        import PkG from &#039;./src/index.ts&#039;
        new PkG().sayHello()
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
</div><p><code>pkg.json</code>中加入启动指令</p>
<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre><!--::markdown-it-async::xxe4taswthd7nd30ajicqx::--><code>{
  &quot;scripts&quot;: {
    &quot;serve&quot;: &quot;vite&quot;,
  },
}</code></pre>
</div><p>启动</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::5013j8i60weqwd1eyxggk::--><code>pnpm serve</code></pre>
</div><h2 id="css资源处理" tabindex="-1">CSS资源处理 <a class="header-anchor" href="#css资源处理" aria-label="Permalink to “CSS资源处理”">&#8203;</a></h2>
<p>css资源的处理方式有很多种，下面介绍几种常见的</p>
<p>测试样式</p>
<div class="language-css"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre><!--::markdown-it-async::0hi3ibmfdorhbzh946fpjv::--><code>h1{
  font-size:48px;
  color:red;
}</code></pre>
</div><h3 id="外部样式表" tabindex="-1">外部样式表 <a class="header-anchor" href="#外部样式表" aria-label="Permalink to “外部样式表”">&#8203;</a></h3>
<p>直接在入口文件<code>src/index.ts</code>中引入</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::p0mt1evwb30wkkrqycwnb::--><code>import &#039;./styles/demo.css&#039;;</code></pre>
</div><p><code>build</code>产物包含一个<code>style.css</code>文件，里面即为书写的样式</p>
<p>于是此种方式引入sdk的话，还需要额外引入一个css资源</p>
<h3 id="style-标签" tabindex="-1">style 标签 <a class="header-anchor" href="#style-标签" aria-label="Permalink to “style 标签”">&#8203;</a></h3>
<p>可以算作<strong>css in js</strong>的一种</p>
<p>先编写2个工具方法</p>
<ul>
<li>h：简化创建标签</li>
<li>addStyleDom：向指定Dom下插入<code>style</code>标签</li>
</ul>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::gd2f7jcmb4uubmel1v20rl::--><code>/**
 * 创建HtmlElement
 * @param tag 标签名
 * @returns
 */
export function h(tag: string) {
  return document.createElement(tag)
}

/**
 * 通过style标签向目标DOM添加css样式
 * @param target 目标DOM
 * @param style 样式
 */
export function addStyleDom(target: HTMLElement, style: string) {
  const styleDom = h(&#039;style&#039;)
  styleDom.textContent = style
  target.append(styleDom)
}</code></pre>
</div><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::hxacennvuhldunvgus4pvc::--><code>import style from &#039;./styles/demo.css&#039;;
import { addStyleDom } from &#039;./utils&#039;;

addStyleDom(document.documentElement, style);</code></pre>
</div><p>于是此种方式会将css内容写入到js代码中，在运行时自动通过style节点插入到文档节点中</p>
<p><img src="./web-sdk-tpl/MTYzMzc1NzUzNDYzNg==633757534636.png" alt="图片" loading="lazy"></p>
<h3 id="scss-less支持" tabindex="-1">scss/less支持 <a class="header-anchor" href="#scss-less支持" aria-label="Permalink to “scss/less支持”">&#8203;</a></h3>
<p>Vite内置对这两个预处理语言的支持，只需要安装相应的依赖就行</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::zued6up96d1d67sl7y4ji::--><code>pnpm add -D less sass</code></pre>
</div><p>使用</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::9wnbgkt077mnk2etp9qlsb::--><code>import &#039;./styles/demo.scss&#039;;
import style from &#039;./styles/demo.less&#039;;</code></pre>
</div><h2 id="发布" tabindex="-1">发布 <a class="header-anchor" href="#发布" aria-label="Permalink to “发布”">&#8203;</a></h2>
<p>要让别人使用，那就得将npm包发布上线</p>
<h3 id="npm" tabindex="-1">NPM <a class="header-anchor" href="#npm" aria-label="Permalink to “NPM”">&#8203;</a></h3>
<p>线上<a href="https://www.npmjs.com/" target="_blank" rel="noreferrer">npm</a>注册一个账号，调用<code>npm login</code>进行登录</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::jbbsntxlhpjw0fowpscy2r::--><code>npm login</code></pre>
</div><p>发布前记得先build，然后commit暂存区的代码，清理工作区的变动</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::w3g73lou08gx8alw189x::--><code>npm run build</code></pre>
</div><p>接着升级版本</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::7r2zsk2r9q3jyfotq149dg::--><code>npm version patch</code></pre>
</div><p><img src="./web-sdk-tpl/MTYzMzc1ODgzNzI3OA==633758837278.png" alt="图片" loading="lazy"></p>
<p>发布</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::dwjw1gnaqahrby7ax0gtr::--><code>npm publish</code></pre>
</div><p><img src="./web-sdk-tpl/MTYzMzg0NTE0MDEzMQ==633845140131.png" alt="图片" loading="lazy"></p>
<h3 id="cdn资源" tabindex="-1">CDN资源 <a class="header-anchor" href="#cdn资源" aria-label="Permalink to “CDN资源”">&#8203;</a></h3>
<p>简单一点就使用<a href="https://unpkg.com/" target="_blank" rel="noreferrer">UNPKG</a>,可以读取发布到npm上的静态资源</p>
<p>为了速度更快的话可以将资源上传到大陆的<code>OSS</code>上，再通过<code>CDN</code>下发</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::shyok9csjyofpgo8fjozri::--><code>&lt;script src=&quot;https://unpkg.com/tpl-web-lib@0.0.1/dist/index.min.js&quot;&gt;&lt;/script&gt;</code></pre>
</div><h2 id="demo" tabindex="-1">Demo <a class="header-anchor" href="#demo" aria-label="Permalink to “Demo”">&#8203;</a></h2>
<h3 id="效果" tabindex="-1">效果 <a class="header-anchor" href="#效果" aria-label="Permalink to “效果”">&#8203;</a></h3>
<p>会向你的页面中心位置添加一个<code>tag</code></p>
<p><img src="./web-sdk-tpl/MTYzMzg1NDMyNjkzNw==633854326937.png" alt="图片" loading="lazy"></p>
<h3 id="npm-1" tabindex="-1">npm <a class="header-anchor" href="#npm-1" aria-label="Permalink to “npm”">&#8203;</a></h3>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::9ujzua4m4qh13zjhit0sr2m::--><code># npm
npm i tpl-web-lib

# yarn
yarn add tpl-web-lib

# pnpm
pnpm add tpl-web-lib</code></pre>
</div><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::58gbjo4r64cq1kiztaa7n::--><code>import libName from &#039;tpl-web-lib&#039;
new libName()</code></pre>
</div><h3 id="cdn-2" tabindex="-1">cdn <a class="header-anchor" href="#cdn-2" aria-label="Permalink to “cdn”">&#8203;</a></h3>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::4x0ianbddhqr9lfw9ygzvo::--><code>&lt;script src=&quot;https://unpkg.com/tpl-web-lib@latest/dist/index.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    new LibName()
&lt;/script&gt;</code></pre>
</div><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">&#8203;</a></h2>
<p>文章比较详细的介绍了整个搭建过程，笔者水平有限，如有错误还请斧正</p>
<p>经过一些思考（文章篇幅与相关性），关于一些工程通用的能力，如<code>eslint</code>，<code>api-extractor</code>，<code>prettier</code>，<code>jest</code>，<code>husky</code>等等将会在后续文章中专门介绍</p>
<blockquote>
<p>文中所涉及<a href="https://github.com/ATQQ/web-lib-template" target="_blank" rel="noreferrer">源码仓库</a>地址：<a href="https://github.com/ATQQ/web-lib-template" target="_blank" rel="noreferrer">https://github.com/ATQQ/web-lib-template</a></p>
</blockquote>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/web-sdk-tpl/MTYzMzUzMjA5MTQ4MQ==633532091481.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[为什么'\x1B'.length===1？\x与\u知识延伸]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/ux.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/ux.html</guid>
            <pubDate>Mon, 04 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[背景
先讲一下背景，再说原因
大多数库都会在日志中使用`chalk`库为console的内容进行上色
被`chalk`处理后，其原本的内容会被‘\x1B...’所包裹
```js
console.lo]]></description>
            <content:encoded><![CDATA[<h1 id="为什么-x1b-length-1-x与-u知识延伸" tabindex="-1">为什么'\x1B'.length === 1？\x与\u知识延伸 <a class="header-anchor" href="#为什么-x1b-length-1-x与-u知识延伸" aria-label="Permalink to “为什么'\x1B'.length === 1？\x与\u知识延伸”">&#8203;</a></h1>
<h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to “背景”">&#8203;</a></h2>
<p>先讲一下背景，再说原因</p>
<p>大多数库都会在日志中使用<code>chalk</code>库为console的内容进行上色</p>
<p>被<code>chalk</code>处理后，其原本的内容会被‘\x1B...’所包裹</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::4ybwzkbhtggwql9u1pava::--><code>console.log(chalk.blue(&#039;green&#039;));
console.log([chalk.blue(&#039;green&#039;)]);</code></pre>
</div><p><img src="./ux/MTYzMzE1NzQ3MjA5OQ==633157472099.png" alt="图片" loading="lazy"></p>
<p>在开发<a href="https://github.com/ATQQ/vite-plugin-monitor" target="_blank" rel="noreferrer">vite-plugin-monitor</a>时，为了获取原始的日志内容（上色之前），需要将上色后的字符串还原</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::5h2knep0wa4ixac5gxt5a::--><code>\x1B[34mgreen\x1B[39m =&gt; green</code></pre>
</div><p>在使用正则处理内容的时候发现了一个问题</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::9smmas48wepia68qvjjkm::--><code>&#039;\x1B&#039;.replace(/\\x/,&#039;&#039;) // 结果？？</code></pre>
</div><p>通过<code>.length</code>查看其长度，结果就如标题所示</p>
<p><img src="./ux/MTYzMzE1ODMwMzk5Ng==633158303996.png" alt="图片" loading="lazy"></p>
<h2 id="原因" tabindex="-1">原因 <a class="header-anchor" href="#原因" aria-label="Permalink to “原因”">&#8203;</a></h2>
<p>反斜杠<code>&quot;\&quot;</code>通常标识转义字符，如<code>\n(换行符)</code>,<code>\t(制表符)</code></p>
<p>而<code>\x</code>就标识16进制，后面跟上两位16进制数</p>
<p>与此同时还有<code>\u</code>也是标识16进制，但其后面需跟上4位16进制数</p>
<p>因此这里的<code>\x1B</code>实际上就是一个字符</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::beccqip3ymuk4seq8daauq::--><code>&#039;\x41&#039; === &#039;A&#039;   // true
&#039;A&#039; === &#039;\u0041&#039; // true</code></pre>
</div><h2 id="x" tabindex="-1">\x <a class="header-anchor" href="#x" aria-label="Permalink to “\x”">&#8203;</a></h2>
<p><code>\xhh</code>匹配一个以两位十六进制数（<code>\x00</code>-<code>\xFF</code>）表示的字符</p>
<p>主要用于<a href="https://tool.oschina.net/commons?type=4" target="_blank" rel="noreferrer">ASCII码</a>的表示</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::2eqljtan8d3plczaww1xd::--><code>&#039;\x41&#039; === ‘A’
&#039;A&#039; === String.fromCharCode(65)

&#039;\x61&#039; === ‘a’
&#039;a&#039; === String.fromCharCode(97)</code></pre>
</div><p><code>\x</code>后必须跟着两位16进制的字符，否则会报错，其中 <code>A</code>-<code>F</code> 不区分大小写</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::6drg2vpvczx0iqtuar79wih::--><code>&#039;\x1&#039; // Uncaught SyntaxError: Invalid hexadecimal escape sequence
&#039;\xfg&#039; // Uncaught SyntaxError: Invalid hexadecimal escape sequence</code></pre>
</div><h2 id="u" tabindex="-1">\u <a class="header-anchor" href="#u" aria-label="Permalink to “\u”">&#8203;</a></h2>
<p><code>\uhhhh</code>匹配一个以四位十六进制数（<code>\u0000</code>-<code>\uFFFF</code>）表示的 Unicode 字符。</p>
<p>在正则表达式中常见于匹配中文字符</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::apx7zp5z9niyobe1l73qb::--><code>const r = /[\u4e00-\u9fa5]/
r.test(&#039;中文&#039;) // true
r.test(&#039;English&#039;) // false</code></pre>
</div><h2 id="常规字符与unicode字符互转" tabindex="-1">常规字符与Unicode字符互转 <a class="header-anchor" href="#常规字符与unicode字符互转" aria-label="Permalink to “常规字符与Unicode字符互转”">&#8203;</a></h2>
<h3 id="str2unicode" tabindex="-1">str2Unicode <a class="header-anchor" href="#str2unicode" aria-label="Permalink to “str2Unicode”">&#8203;</a></h3>
<ol>
<li>使用<code>String.prototype.charCodeAt</code>获取指定位置的 Unicode 码点（十进制表示）</li>
<li>使用<code>String.prototype.toString</code>将其转为十六进制字符,转为16进制字符不会自动补0</li>
<li>通过<code>String.prototype.padStart</code>进行补<code>0</code></li>
</ol>
<p>编写的通用处理方法如下</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::fs56mp4fo19ugt23vjg63o::--><code>function str2Unicode(str) {
    let s = &#039;&#039;
    for (const c of str) {
        s += `\\u${c.charCodeAt(0).toString(16).padStart(4, &#039;0&#039;)}`
    }
    return s
}

str2Unicode(&#039;1a中文&#039;) // &#039;\\u0031\\u0061\\u4e2d\\u6587&#039;</code></pre>
</div><h3 id="unicode2str" tabindex="-1">unicode2Str <a class="header-anchor" href="#unicode2str" aria-label="Permalink to “unicode2Str”">&#8203;</a></h3>
<ol>
<li>通过正则<code>/\\u[\da-f]{4}/g</code>匹配出所有的unicode字符</li>
<li>使用<code>Number</code>将<code>0x${matchStr}</code>转换为10进制数</li>
<li>使用<code>String.fromCodePoint</code>将unicode码点转为字符</li>
<li>使用<code>String.prototype.replace</code>进行逐字符的转换</li>
</ol>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::xl7je28zofrj07fv2bc4h9::--><code>function unicode2Str(str) {
    const unicodeList = str.match(/\\u[\da-f]{4}/g) || []
    return unicodeList.reduce((pre, u) =&gt; {
        return pre.replace(u, String.fromCodePoint(Number(`0x${u.slice(2)}`)))
    }, str)
}

unicode2Str(&#039;1\\u0061\\u4e2d文&#039;) // 1a中文</code></pre>
</div><h2 id="还原chalk处理后的字符串" tabindex="-1">还原chalk处理后的字符串 <a class="header-anchor" href="#还原chalk处理后的字符串" aria-label="Permalink to “还原chalk处理后的字符串”">&#8203;</a></h2>
<p>自己从0-1写一个正则难免会有许多边界情况考虑不周全，于是在chalk的README中找到了<a href="https://github.com/chalk/ansi-regex" target="_blank" rel="noreferrer">chalk/ansi-regex</a>这个库</p>
<p>可以将色值相关的 <code>ANSI转义码</code> 匹配出来</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::9jra430ipupxbx3dzs0pgb::--><code>import ansiRegex from &#039;ansi-regex&#039;;

&#039;\u001B[4mcake\u001B[0m&#039;.match(ansiRegex());
//=&gt; [&#039;\u001B[4m&#039;, &#039;\u001B[0m&#039;]

&#039;\u001B[4mcake\u001B[0m&#039;.match(ansiRegex({onlyFirst: true}));
//=&gt; [&#039;\u001B[4m&#039;]</code></pre>
</div><p>编写一下处理方法</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::wo85dmtyscb8plkn2yzjn::--><code>function resetChalkStr(str) {
    return str.replace(ansiRegex(), &#039;&#039;)
}</code></pre>
</div><p>测试</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::w2apiakyu9sj8ndq8iwkae::--><code>console.log(chalk.green(&#039;green&#039;), chalk.greenBright(&#039;greenBright&#039;));

console.log([chalk.green(&#039;green&#039;), chalk.greenBright(&#039;greenBright&#039;)]);

console.log(resetChalkStr(`${chalk.green(&#039;green&#039;)} ${chalk.greenBright(&#039;greenBright&#039;)}`));</code></pre>
</div><p><img src="./ux/MTYzMzMzMzExNzEzOA==633333117138.png" alt="图片" loading="lazy"></p>
<h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">&#8203;</a></h2>
<p>重拾了一下<code>\x</code>与<code>\u</code>相关的内容，突然额外想到一个点，使用\u去做字符串的加解密(下来再捋一捋)</p>
<p>解决了一个<code>chalk</code>相关的问题“还原终端中的彩色内容”</p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/ux/MTYzMzE1NzQ3MjA5OQ==633157472099.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[Vite插件开发纪实：vite-plugin-monitor（下）]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/vite-plugin-monitor3.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/vite-plugin-monitor3.html</guid>
            <pubDate>Fri, 01 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[前言
上一篇介绍了Vite启动，HMR等时间的获取。
但各阶段详细的耗时信息，只能通过debug的日志获取
本文就实现一下debug日志的拦截
 插件效果预览
 --debug做了什么
项目启动指令
]]></description>
            <content:encoded><![CDATA[<h1 id="vite插件开发纪实-vite-plugin-monitor-下" tabindex="-1">Vite插件开发纪实：vite-plugin-monitor（下） <a class="header-anchor" href="#vite插件开发纪实-vite-plugin-monitor-下" aria-label="Permalink to “Vite插件开发纪实：vite-plugin-monitor（下）”">&#8203;</a></h1>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p><a href="./vite-plugin-monitor2.html">上一篇</a>介绍了Vite启动，HMR等时间的获取。</p>
<p>但各阶段详细的耗时信息，只能通过debug的日志获取</p>
<p>本文就实现一下debug日志的拦截</p>
<h2 id="插件效果预览" tabindex="-1">插件效果预览 <a class="header-anchor" href="#插件效果预览" aria-label="Permalink to “插件效果预览”">&#8203;</a></h2>
<p><img src="./vite-plugin-monitor3/MTYzMzA4MTY0NTkzNA==633081645934.png" alt="图片" loading="lazy"></p>
<h2 id="debug做了什么" tabindex="-1">--debug做了什么 <a class="header-anchor" href="#debug做了什么" aria-label="Permalink to “--debug做了什么”">&#8203;</a></h2>
<p>项目启动指令</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::nklb3120huhuwlcuyuhcf::--><code>vite --debug</code></pre>
</div><p>在源码中搜索 <code>--debug</code>，可以在<a href="https://github.com/vitejs/vite/blob/63c7a88cadfff1d9fb10f63415a7132bf5eec483/packages/vite/bin/vite.js#L14" target="_blank" rel="noreferrer">vite/packages/vite/bin/vite.js</a>文件中定位到目标代码</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::nfwcbkd48tfxskc88ahwg::--><code>const debugIndex = process.argv.findIndex((arg) =&gt; /^(?:-d|--debug)$/.test(arg))

if (debugIndex &gt; 0) {
  let value = process.argv[debugIndex + 1]
  if (!value || value.startsWith(&#039;-&#039;)) {
    value = &#039;vite:*&#039;
  } else {
    // support debugging multiple flags with comma-separated list
    value = value
      .split(&#039;,&#039;)
      .map((v) =&gt; `vite:${v}`)
      .join(&#039;,&#039;)
  }
  process.env.DEBUG = value
}</code></pre>
</div><p>可以看到如果使用了<code>--debug</code>或者<code>-d</code>参数，<code>process.env</code>上挂载<code>DEBUG</code>变量标识开启了Debug</p>
<h2 id="定位打印日志方法" tabindex="-1">定位打印日志方法 <a class="header-anchor" href="#定位打印日志方法" aria-label="Permalink to “定位打印日志方法”">&#8203;</a></h2>
<p>debug下每条日志都是以<code>vite:label</code>开头，比如</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::0zfo5rkc5hgg5n67ggyvj9m::--><code>vite:load 1ms   [fs] /src/router/routes/index.ts</code></pre>
</div><p>全局搜一下<code>vite:load</code>就定位到了如下的<a href="https://github.com/vitejs/vite/blob/63c7a88cadfff1d9fb10f63415a7132bf5eec483/packages/vite/src/node/server/transformRequest.ts#L23" target="_blank" rel="noreferrer">代码</a>，可以看到<code>createDebugger</code>是返回了一个可以打印日志的方法</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::qd6559yb7odwf3thfh0af9::--><code>import {
  createDebugger,
} from &#039;../utils&#039;
const debugLoad = createDebugger(&#039;vite:load&#039;)
const isDebug = !!process.env.DEBUG
// ..code
isDebug &amp;&amp; debugLoad(`${timeFrom(loadStart)} [fs] ${prettyUrl}`)</code></pre>
</div><p><code>createDebugger</code> 的源码如下，其返回一个自定函数，简单捋一下就能看出，负责打印的方法是<code>log(msg,...args)</code></p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::yrtxyyxdeea7ezxlbsgj7::--><code>import debug from &#039;debug&#039;

export function createDebugger(
  namespace: ViteDebugScope,
  options: DebuggerOptions = {}
): debug.Debugger[&#039;log&#039;] {
  const log = debug(namespace)
  const { onlyWhenFocused } = options
  const focus =
    typeof onlyWhenFocused === &#039;string&#039; ? onlyWhenFocused : namespace
  return (msg: string, ...args: any[]) =&gt; {
    if (filter &amp;&amp; !msg.includes(filter)) {
      return
    }
    if (onlyWhenFocused &amp;&amp; !DEBUG?.includes(focus)) {
      return
    }
    log(msg, ...args)
  }
}</code></pre>
</div><p>其中<code>log</code>实例通过<code>debug</code>方法创建，但这个<code>debug</code>方法是一个第三方的库<code>visionmedia/debug</code></p>
<p><img src="./vite-plugin-monitor3/MTYzMzA5MTM2MjM0Mg==633091362342.png" alt="图片" loading="lazy"></p>
<p>这个方库虽小，能在<code>Vite</code>中被用上想必也不简单，<a href="https://github1s.com/visionmedia/debug/blob/HEAD/src/node.js" target="_blank" rel="noreferrer">在线查看源码</a></p>
<h2 id="debug方法源码分析" tabindex="-1">debug方法源码分析 <a class="header-anchor" href="#debug方法源码分析" aria-label="Permalink to “debug方法源码分析”">&#8203;</a></h2>
<p>入口文件比较简单，这里直接去看<code>./node.js</code>中的逻辑</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::d9y97mdne8dfiod4lv08h::--><code>if (typeof process === &#039;undefined&#039; || process.type === &#039;renderer&#039; || process.browser === true || process.__nwjs) {
	module.exports = require(&#039;./browser.js&#039;);
} else {
	module.exports = require(&#039;./node.js&#039;);
}</code></pre>
</div><p>这部分代码一共只有<strong>264</strong>行，关键代码如下</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::wv38xcqgp8ecfbxuofl7qm::--><code>exports.log = log;

function log(...args) {
	return process.stderr.write(util.format(...args) + &#039;\n&#039;);
}

module.exports = require(&#039;./common&#039;)(exports);</code></pre>
</div><p><strong>./common.js</strong>中部分代码</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::978rkqe9h2v3ig38dad0ok::--><code>function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;

	function createDebug(namespace) {
		function debug(...args) {
			const self = debug;
			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}
		return debug;
	}
	return createDebug;
}

module.exports = setup;</code></pre>
</div><p>到此能够确定日志的打印都是通过<code>process.stderr.write</code>方法输出的内容</p>
<p>这个方法的好处就是，输出内容不会直接换行</p>
<p>那么我们在插件中重新定义一下这个方法就能拦截到打印的内容</p>
<h2 id="debug日志拦截实现" tabindex="-1">debug日志拦截实现 <a class="header-anchor" href="#debug日志拦截实现" aria-label="Permalink to “debug日志拦截实现”">&#8203;</a></h2>
<p>定义插件入参</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::g9a2cp0ne4hjygm6bsyndj::--><code>interface PluginOptions {
    /**
     * 是否在终端中输出原来的日志
     */
    log?: boolean
    /**
     * 默认回调
     */
    monitor?: MonitorCallback
    /**
     * debug回调
     */
    debug?: DebugCallback
}</code></pre>
</div><p>直接在调用插件方法的时候进行<code>write</code>方法重写，具体实现逻辑如下</p>
<ul>
<li>启用了<code>--debug</code>，传入了<code>monitor</code>或<code>debug</code>方法才重新定义write方法</li>
<li>将获取到的日志信息做简单解析，通过<code>monitor</code>方法传递给外部</li>
<li>原始参数传递给外部的debug方法</li>
</ul>
<p>其中解析出的几个参数几个参数与原日志内容对应关系如下</p>
<p><img src="./vite-plugin-monitor3/MTYzMzA5MzM0NDMxNg==633093344317.png" alt="图片" loading="lazy"></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::ci9cor5nadoa9ktqtzb9dh::--><code>import type { Plugin } from &#039;vite&#039;;
import type { PluginOptions } from &#039;./types&#039;;

export default function Monitor(ops: PluginOptions = {}): Plugin {
  const { log, monitor, debug } = ops;
  // 如果debug方法且启动时添加了--debug参数
  if ((typeof debug === &#039;function&#039; || typeof monitor === &#039;function&#039;) &amp;&amp; process.env.DEBUG) {
    const { write } = process.stderr;
    Object.defineProperty(process.stderr, &#039;write&#039;, {
      get() {
        return function _write(...argv) {

          // log为true才执行原来的打印逻辑
          if (log &amp;&amp; typeof argv[0] === &#039;string&#039;) {
            process.stdout.write(argv[0]);
          }
          const originStr = argv[0];

          // 解析日志的label与打印的时间信息
          const tag = (originStr.match(/vite:(.*?)\s/) || [])[1];
          const time1 = (originStr.replace(/\+\d+ms/, &#039;&#039;).match(/(\d+)ms/) || [])[1];
          const time2 = (originStr.match(/\+(\d+)ms/) || [])[1];
          const time = +(time1 || 0) + +(time2 || 0);


          if (tag &amp;&amp; monitor) {
            monitor(tag, time, {
              time1: +(time1 || 0),
              time2: +(time2 || 0),
              originValue: originStr,
            });
          }

          if (debug) {
            debug(...argv);
          }
        };
      },
    });
  }
  return {
    name: &#039;vite-plugin-monitor&#039;,
    apply: &#039;serve&#039;,
    },
  };
}</code></pre>
</div><p>到此拦截日志的feature就完成了,最初定下目标也已完成</p>
<h2 id="体验插件" tabindex="-1">体验插件 <a class="header-anchor" href="#体验插件" aria-label="Permalink to “体验插件”">&#8203;</a></h2>
<blockquote>
<p><a href="https://github.com/ATQQ/vite-plugin-monitor/tree/main/#readme" target="_blank" rel="noreferrer">插件源码</a></p>
</blockquote>
<p>安装依赖</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::71hj5npnjc9crv5tp6ztnr::--><code>yarn add vite-plugin-monitor --dev</code></pre>
</div><p>引入插件，修改<strong>vite.config.js</strong>文件</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::hebv50387feayadh7uf5q::--><code>import { defineConfig } from &#039;vite&#039;
import vitePluginMonitor from &#039;vite-plugin-monitor&#039;

export default defineConfig({
  plugins: [
    vitePluginMonitor({
      // log: false,
      monitor(label, time, originData) {
        const { time1, time2, originValue } = originVal
        console.log(originValue)
        console.log(label, time1, time2, `${time}ms`)
      },
      debug(str) {
        // 打印完整日志
        // process.stdout.write(str)
      },
    }),
  ],
})</code></pre>
</div><p>启动指令中添加<code>--debug</code></p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::020pz5jry7h1iirc78qbys::--><code>vite --debug</code></pre>
</div><p>通过<code>monitor</code>与<code>debug</code>方法中就能拿到原始的日志和简单处理后的日志，在此处<strong>加入自定义的埋点监控代码即可</strong></p>
<p><strong>一点补充：</strong> 在<code>log</code>为<code>false</code>的时，并且定义了<code>monitor</code>或<code>debug</code>方法，那么原来的日志内容都将会被这两个方法拦截</p>
<h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to “小结”">&#8203;</a></h2>
<p>目前已经能够完全拦截到debug下的所有内容，但内容由于有彩色打印相关的字符，提取信息比较麻烦</p>
<p>下一步将对日志的提取再做一些格式化，确保能够解析出完整的日志内容</p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/vite-plugin-monitor3/MTYzMzA4MTY0NTkzNA==633081645934.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[Vite插件开发纪实：vite-plugin-monitor（上）]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/vite-plugin-monitor1.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/vite-plugin-monitor1.html</guid>
            <pubDate>Mon, 27 Sep 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[背景
最近在webpack项目里接入了Vite（dev mode），为开发提效。效果是真的猛。
项目启动速度提升70%-80%，HMR直接碾压webpack dev server
为了更加精准的计算收]]></description>
            <content:encoded><![CDATA[<h1 id="vite插件开发纪实-vite-plugin-monitor-上" tabindex="-1">Vite插件开发纪实：vite-plugin-monitor（上） <a class="header-anchor" href="#vite插件开发纪实-vite-plugin-monitor-上" aria-label="Permalink to “Vite插件开发纪实：vite-plugin-monitor（上）”">&#8203;</a></h1>
<h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to “背景”">&#8203;</a></h2>
<p>最近在webpack项目里接入了Vite（dev mode），为开发提效。效果是真的猛。</p>
<p>项目启动速度提升70%-80%，HMR直接碾压webpack dev server</p>
<p>为了更加精准的计算收益，就需要将Vite启动相关的指标进行上报（启动时间，HMR，页面加载等等时间）</p>
<p>为此就要通过开发插件收集这些信息，然后通过埋点上报sdk上报到数据分析的平台</p>
<h2 id="遇到的问题" tabindex="-1">遇到的问题 <a class="header-anchor" href="#遇到的问题" aria-label="Permalink to “遇到的问题”">&#8203;</a></h2>
<p>通过查阅<a href="https://vitejs.dev/guide/api-plugin.html" target="_blank" rel="noreferrer">官方文档</a>并未找到相关的钩子直接获取到这些指标</p>
<p>但在开发的时候添加 <code>--debug</code>就能很详细的看到所有资源的处理时间，HMR，详细的启动时间等等</p>
<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre><!--::markdown-it-async::d2t6yzsuqkqjn5lja55ile::--><code>{
    &quot;scripts&quot;: {
        &quot;dev&quot;: &quot;vite --debug&quot;,
    }
}</code></pre>
</div><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::nf9gb5f8y58zka6csab48::--><code>npm run dev</code></pre>
</div><p><img src="./vite-plugin-monitor1/MTYzMjcyMjY1NzQxMQ==632722657411.png" alt="图片" loading="lazy"></p>
<p>为此只能通过一些hack的手段获取这些指标了，下面将展开详细的介绍</p>
<h2 id="期望" tabindex="-1">期望 <a class="header-anchor" href="#期望" aria-label="Permalink to “期望”">&#8203;</a></h2>
<p>通过向目标工程引入插件，通过特定的回掉函数即可获取到<code>debug</code>模式下反馈的各种信息</p>
<h2 id="准备工作" tabindex="-1">准备工作 <a class="header-anchor" href="#准备工作" aria-label="Permalink to “准备工作”">&#8203;</a></h2>
<p>比较详细的介绍一下开发步骤</p>
<h3 id="初始化工程" tabindex="-1">初始化工程 <a class="header-anchor" href="#初始化工程" aria-label="Permalink to “初始化工程”">&#8203;</a></h3>
<p>创建插件目录</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::p3ynkyj5s2tle6e2bjtt::--><code>mkdir vite-plugin-monitor

cd vite-plugin-monitor</code></pre>
</div><p>初始化<code>pkg.json</code></p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::u3urfz5z0qgowhykva1s4::--><code>npm init -y</code></pre>
</div><p>安装必要依赖</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::kqld3vr0955tafqezelk2::--><code>yarn add -D vite typescript @types/node rimraf</code></pre>
</div><p>添加必要的两个指令<code>dev</code>,<code>build</code>，配置入口文件<code>dist/index.js</code></p>
<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre><!--::markdown-it-async::z0jvmxpzqjrhi9t6n6x::--><code>{
    &quot;main&quot;: &quot;dist/index.js&quot;,
    &quot;scripts&quot;: {
        &quot;dev&quot;: &quot;tsc -w -p .&quot;,
        &quot;build&quot;: &quot;rimraf dist &amp;&amp; tsc -p .&quot;
    }
}</code></pre>
</div><p>其中<code>dev</code>环境下添加了<code>-w(--watch)</code>参数，当文件有变动时，以便实时的进行更新</p>
<p><code>rimraf</code>的作用是替代<code>rm -rf</code>指令，且是跨平台的，windows下同样生效</p>
<p>插件使用<code>typescript</code>开发，更有助于插件后续的维护</p>
<p>其中<code>build</code>直接使用<code>typescript</code>提供的默认<code>tsc</code>指令，对ts直接进行转换</p>
<p>根目录创建 <code>tsconfig.json</code> 内容如下</p>
<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre><!--::markdown-it-async::3alm1eext6pvtyekk3ymvl::--><code>{
    &quot;compilerOptions&quot;: {
      &quot;target&quot;: &quot;es2015&quot;,
      &quot;moduleResolution&quot;: &quot;node&quot;,
      &quot;strict&quot;: false,
      &quot;declaration&quot;: true,
      &quot;noUnusedLocals&quot;: true,
      &quot;esModuleInterop&quot;: true,
      &quot;outDir&quot;: &quot;dist&quot;,
      &quot;module&quot;: &quot;commonjs&quot;,
      &quot;lib&quot;: [&quot;ESNext&quot;,&quot;DOM&quot;],
      &quot;sourceMap&quot;: true,
    },
    &quot;include&quot;: [&quot;./src&quot;]
  }</code></pre>
</div><p>在 <code>src</code> 目录下进行开发，里面存放我们的源码</p>
<h3 id="目录结构" tabindex="-1">目录结构 <a class="header-anchor" href="#目录结构" aria-label="Permalink to “目录结构”">&#8203;</a></h3>
<p>最终目录如下</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::zmxopkb8tloasm1iei3bvv::--><code>├── package.json
├── src
|  ├── index.ts     # 插件入口
|  ├── types
|  |  └── index.ts  # 类型定义
|  └── utils
|     └── index.ts  # 工具方法
├── tsconfig.json</code></pre>
</div><h3 id="简单插件示例" tabindex="-1">简单插件示例 <a class="header-anchor" href="#简单插件示例" aria-label="Permalink to “简单插件示例”">&#8203;</a></h3>
<p>根据插件开发文档，在<code>src/index.ts</code>文件下编写如下简单的代码;</p>
<ul>
<li>name：标识插件的名称</li>
<li>apply：标识插件在哪个时期工作(serve|build)，默认都会调用</li>
<li>config：这个钩子接收原始用户配置（命令行选项指定的会与配置文件合并）和一个描述配置环境的变量</li>
</ul>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::uffhaxqjsobtu93psehmxe::--><code>import type { Plugin } from &#039;vite&#039;;

export default function Monitor(): Plugin {
  return {
    name: &#039;vite-plugin-monitor&#039;,
    apply: &#039;serve&#039;,
    config(userConfig, env) {
      console.log(userConfig);
      console.log(env)
      // 可以做进一步的修改，会自动合入当前的配置
      // return
    },
  };
}</code></pre>
</div><p>一个打印Vite配置的插件就搞定了，下面就是测试我们开发的插件</p>
<h3 id="本地测试插件" tabindex="-1">本地测试插件 <a class="header-anchor" href="#本地测试插件" aria-label="Permalink to “本地测试插件”">&#8203;</a></h3>
<p>首先是转换我们的<code>ts</code>=&gt; <code>js</code> ，执行前面配置的指令<code>yarn dev</code>，就会看见生成了一个dist目录，里面有转换后的代码</p>
<p>接着执行<code>npm link</code>在全局生成一个软连接，指向当前项目</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::mc06cn8b7qqx32qk0iwcu::--><code>npm link</code></pre>
</div><p>在一个vite项目里的执行<code>npm link vite-plugin-monitor</code>(monitor根据实际情况替换)，向目标项目加入此依赖</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::uk1fp06o4wqkdax0mjvkbo::--><code>npm link vite-plugin-monitor</code></pre>
</div><p>接着就可以在Vite项目的<code>vite.config.js</code>配置文件中加入我们的插件了</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::dqcq1i8s39vnl34egyocxj::--><code>import { defineConfig } from &#039;vite&#039;
import vue from &#039;@vitejs/plugin-vue&#039;
import vitePluginMonitor from &#039;vite-plugin-monitor&#039;

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue(),
    vitePluginMonitor()
  ]
})</code></pre>
</div><p>接着通过配置的指令启动<code>vite</code>，就能看到我们插件的打印的配置文件内容了</p>
<p><img src="./vite-plugin-monitor1/MTYzMjc1NTgxNDM4Nw==632755814387.png" alt="图片" loading="lazy"></p>
<p>由于是通过软连接的方式引入的插件，那么在插件工程里的任意更改都会实时生效，也就避免了频繁的执行<code>yarn add file:localProjectDir</code></p>
<h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to “小结”">&#8203;</a></h2>
<p>本篇主要介绍了<code>monitor</code>插件开发的背景，要解决的问题，目标以及开发插件所需的一些列准备工作</p>
<p><a href="./vite-plugin-monitor2.html">下一篇文章</a>将详细介绍功能的实现</p>
<p>查看：<a href="https://github.com/ATQQ/vite-plugin-monitor" target="_blank" rel="noreferrer">仓库源码</a></p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/vite-plugin-monitor1/MTYzMjcyMjY1NzQxMQ==632722657411.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[Vite插件开发纪实：vite-plugin-monitor（中）]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/vite-plugin-monitor2.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/vite-plugin-monitor2.html</guid>
            <pubDate>Mon, 27 Sep 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[前言
上一篇文章主要介绍了开发插件所需的准备工作，以及此次要开发的插件将要解决的问题
 功能开发
有了前文的铺垫内容，下面就是功能开发
 获取启动耗时
项目启动后会在终端中输出`ready in xx]]></description>
            <content:encoded><![CDATA[<h1 id="vite插件开发纪实-vite-plugin-monitor-中" tabindex="-1">Vite插件开发纪实：vite-plugin-monitor（中） <a class="header-anchor" href="#vite插件开发纪实-vite-plugin-monitor-中" aria-label="Permalink to “Vite插件开发纪实：vite-plugin-monitor（中）”">&#8203;</a></h1>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p><a href="./vite-plugin-monitor1.html">上一篇</a>文章主要介绍了开发插件所需的准备工作，以及此次要开发的插件将要解决的问题</p>
<h2 id="功能开发" tabindex="-1">功能开发 <a class="header-anchor" href="#功能开发" aria-label="Permalink to “功能开发”">&#8203;</a></h2>
<p>有了前文的铺垫内容，下面就是功能开发</p>
<h3 id="获取启动耗时" tabindex="-1">获取启动耗时 <a class="header-anchor" href="#获取启动耗时" aria-label="Permalink to “获取启动耗时”">&#8203;</a></h3>
<p>项目启动后会在终端中输出<code>ready in xxms</code></p>
<p><img src="./vite-plugin-monitor2/MTYzMjkyMjIxNzI0Nw==632922217247.png" alt="图片" loading="lazy"></p>
<p>为此咱们使用Vs Code在<a href="https://github1s.com/vitejs/vite" target="_blank" rel="noreferrer">源码</a>中搜一下这个关键字</p>
<p><img src="./vite-plugin-monitor2/MTYzMjkyMjU5MDI2Mg==632922590262.png" alt="图片" loading="lazy"></p>
<p>可以看到此部分代码在源码中如下</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::39ikjfe6vv5gwz3b93j4yq::--><code>const info = server.config.logger.info

// @ts-ignore
if (global.__vite_start_time) {
  // @ts-ignore
  const startupDuration = performance.now() - global.__vite_start_time
  info(`\n  ${chalk.cyan(`ready in ${Math.ceil(startupDuration)}ms.`)}\n`)
}</code></pre>
</div><p>这个<code>performance.now()</code>等同于<code>Date.now()</code>即当前时间，通过<code>global.__vite_start_time</code>就能获取到服务启动时间</p>
<p>我们就从这个<code>info</code>方法入手，给它重定义一下，通过<code>configureServer</code>钩子可以获取到server实例</p>
<p><strong>index.ts</strong></p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::plea01xrzzf8s0dibo8s8r::--><code>import type { Plugin } from &#039;vite&#039;;

export default function Monitor(): Plugin {
  const startTime = global.__vite_start_time

  return {
    name: &#039;vite-plugin-monitor&#039;,
    apply: &#039;serve&#039;,
    configureServer(server) {
      const { info } = server.config.logger;
      // 拦截info方法的调用
      server.config.logger.info = function _info(str) {
        // 调用原info方法
        info.apply(this, arguments);
        // 通过字符串内容进行一个简单的判断
        if (str.includes(&#039;ready in&#039;)) {
          console.log(&#039;startupDuration&#039;, Date.now() - startTime)
        }
      };
    },
  };
}</code></pre>
</div><p>启动一个项目看看效果，成了。
<img src="./vite-plugin-monitor2/MTYzMjkyMzY1MjAzMg==632923652032.png" alt="图片" loading="lazy"></p>
<h3 id="hmr时间获取" tabindex="-1">HMR时间获取 <a class="header-anchor" href="#hmr时间获取" aria-label="Permalink to “HMR时间获取”">&#8203;</a></h3>
<p>热更新时，终端中会出现下面的日志</p>
<p><img src="./vite-plugin-monitor2/MTYzMjkyNDA0MzU2OQ==632924043569.png" alt="图片" loading="lazy"></p>
<p>同理源码里搜一搜，能够定位出如下内容</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::h5gpycj0ad7g7t7tcj76v7::--><code>config.logger.info(
    updates
    .map(({ path }) =&gt; chalk.green(`hmr update `) + chalk.dim(path))
    .join(&#039;\n&#039;),
  { clear: true, timestamp: true }
)</code></pre>
</div><p>暂以打印这个日志的时间作为HMR开始的时间</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::w5adfdgns7slio5d1pu18::--><code>let startTime = null
const { info } = server.config.logger;
server.config.logger.info = function _info(str) {
  info.apply(this, arguments);
  if (str.indexOf(&#039;hmr update&#039;) &gt;= 0) {
    startTime = Date.now()
  }
};</code></pre>
</div><p>触发HMR时，客户端会发出一个获取资源的请求，请求携带了一个import参数，我们通过这个参数来标识这个特定的请求</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::pxolicqmsygkvk6ravz5q8::--><code>http://localhost:8080/src/pages/home/index.vue?import&amp;t=1632924377207</code></pre>
</div><p>钩子中的server实例包含<code>middlewares</code>属性可以向上添加自定义的中间件处理方法</p>
<ul>
<li>通过URL实例解析<code>search</code>参数，然后判断是否包含<code>import&amp;</code></li>
<li>重定义<code>end</code>方法，在资源传回到客户端后打印耗时</li>
</ul>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::v0ykoiberdd41gdvqxjwpt::--><code>server.middlewares.use(async (req, res, next) =&gt; {
  const { search } = new URL(req.url, `http://${req.headers.host}`);
  if (
    search.indexOf(&#039;import&amp;&#039;) &gt;= 0
  ) {
    const { end } = res;
    res.end = function _end() {
      // 在资源返回后打印耗时
      end.apply(this, arguments);
      console.log(Date.now() - startTime)
    };
  }
  next();
});</code></pre>
</div><p>事实上通过<code>--debug</code>启动服务，能看到在HMR时会打印4个时间</p>
<p><img src="./vite-plugin-monitor2/MTYzMjkyNTQzMzEwNw==632925433107.png" alt="图片" loading="lazy"></p>
<p>目前方法仅仅得到了<code>vite:hmr</code>部分的时间，与实际耗时还有一丝丝差异</p>
<h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to “小结”">&#8203;</a></h2>
<p>更加详细的信息只能通过<code>--debug</code>看到，下一步的计划就是hack，模拟一下debug下的行为，将debug的打印的数据都拦截下来
由于时间关系，这部分hack还没完成。准备假期抽时间实现一下。下一篇文章将详细的介绍最终实现。</p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/vite-plugin-monitor2/MTYzMjkyMjIxNzI0Nw==632922217247.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[马上中秋了，把鼠标指针变为小玉兔]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/mid-autumn-festival.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/mid-autumn-festival.html</guid>
            <pubDate>Sat, 11 Sep 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[前言
马上中秋节啦，掘金又开始整活了，恰巧最近准备做的工具会涉及到鼠标指针的变动，就顺手先写个demo蹭蹭活动了。
顺便提前祝大家🎑中秋节快乐。
当然这个鼠标指针的变动只在Web应用中生效
方便的话]]></description>
            <content:encoded><![CDATA[<h1 id="马上中秋了-把鼠标指针变为小玉兔" tabindex="-1">马上中秋了，把鼠标指针变为小玉兔 <a class="header-anchor" href="#马上中秋了-把鼠标指针变为小玉兔" aria-label="Permalink to “马上中秋了，把鼠标指针变为小玉兔”">&#8203;</a></h1>
<blockquote>
<p>我正在参加中秋创意投稿大赛，详情请看：<a href="https://juejin.cn/post/7003154195826081800" target="_blank" rel="noreferrer">中秋创意投稿大赛</a>”</p>
</blockquote>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>马上中秋节啦，掘金又开始<a href="https://juejin.cn/post/7003154195826081800" target="_blank" rel="noreferrer">整活</a>了，恰巧最近准备做的工具会涉及到鼠标指针的变动，就顺手先写个demo蹭蹭活动了。</p>
<p>顺便提前祝大家🎑中秋节快乐。</p>
<p>当然这个鼠标指针的变动只在Web应用中生效</p>
<p>方便的话可以<a href="https://juejin.cn/post/7006592666846625823" target="_blank" rel="noreferrer">原文</a>戳个赞</p>
<h2 id="效果如下" tabindex="-1">效果如下 <a class="header-anchor" href="#效果如下" aria-label="Permalink to “效果如下”">&#8203;</a></h2>
<p><img src="./mid-autumn-festival/MTYzMTM0MDYwODYyOQ==631340608629.png" alt="图片" loading="lazy"></p>
<p>emmmmm...动图时间较长，需要等一会儿效果才出来</p>
<h2 id="码上体验" tabindex="-1">码上体验 <a class="header-anchor" href="#码上体验" aria-label="Permalink to “码上体验”">&#8203;</a></h2>
<p>在devtools中运行下面这段神秘代码即可，实现源码见<a href="https://github.com/ATQQ/demos/blob/main/yuebingCursor/index.js" target="_blank" rel="noreferrer">此处</a></p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::2vpcjwyf76zx7ab5v26vps::--><code>const script = document.createElement(&#039;script&#039;)
script.src = &#039;./mid-autumn-festival/index.js?s1=https%3A//img.cdn.sugarat.top/demo/js-sdk/zq-rabbit/0.0.2/index.js&#039;
document.body.append(script)</code></pre>
</div><p>将此部分代码加入到目标页面中即可</p>
<h2 id="实现思路" tabindex="-1">实现思路 <a class="header-anchor" href="#实现思路" aria-label="Permalink to “实现思路”">&#8203;</a></h2>
<p>从动图中看到共有两种元素：</p>
<ol>
<li>鼠标移动时，鼠标被替换成了玉兔</li>
<li>玉兔的尾巴处跟着一串月饼🥮</li>
</ol>
<p>下面通过QA的方式，将开发中涉及到的问题先过一下。</p>
<h3 id="获得鼠标指针的位置" tabindex="-1">获得鼠标指针的位置 <a class="header-anchor" href="#获得鼠标指针的位置" aria-label="Permalink to “获得鼠标指针的位置”">&#8203;</a></h3>
<p>通过监听<code>window</code>上的<code>mousemove</code>事件，即可获取到鼠标移动时的位置参数</p>
<h3 id="隐藏原来的指针" tabindex="-1">隐藏原来的指针 <a class="header-anchor" href="#隐藏原来的指针" aria-label="Permalink to “隐藏原来的指针”">&#8203;</a></h3>
<p>css有一个属性<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/cursor" target="_blank" rel="noreferrer">cursor</a>可以用于设置指针的类型。我们将捕获事件的dom(event.target)的cursor设置为<code>none</code>即可</p>
<h3 id="实现指针的变更" tabindex="-1">实现指针的变更 <a class="header-anchor" href="#实现指针的变更" aria-label="Permalink to “实现指针的变更”">&#8203;</a></h3>
<p>解决了上述两个问题后，我们可以通过创建一个简单的<code>dom</code>元素来替代我们的指针，通过实时获取到鼠标的位置，实时更新我们的dom元素位置即可</p>
<h3 id="实现鼠标轨迹" tabindex="-1">实现鼠标轨迹 <a class="header-anchor" href="#实现鼠标轨迹" aria-label="Permalink to “实现鼠标轨迹”">&#8203;</a></h3>
<p>每个一段时间（如30ms）记录一下鼠标的位置，然后与绘制指针一样的逻辑，将轨迹用月饼🥮绘制出来</p>
<p>这里只描述了开发中初期会遇到的问题，还有一些其它问题将在下面详细实现部分进行介绍</p>
<h2 id="玉兔指针实现" tabindex="-1">玉兔指针实现 <a class="header-anchor" href="#玉兔指针实现" aria-label="Permalink to “玉兔指针实现”">&#8203;</a></h2>
<p>监听<code>mousemove</code>事件，获取指针相对屏幕顶部与左侧位置信息</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::igd6audordqddwjpiyk66h::--><code>window.addEventListener(&#039;mousemove&#039;, function (e) {
    const { clientX, clientY } = e
})</code></pre>
</div><p>创建一个元素，设置其背景图为玉兔，并将其插入到主文档中，并初始化一些位置/形状相关的css属性。</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::1185dwidkmlne4pkcfkrcq::--><code>const size = &#039;30px&#039;
function createCursor() {
    const cursor = h()
    cursor.id = &#039;cursor&#039;

    addStyles(cursor, `
    #cursor{
        background-image:url(./mid-autumn-festival/MTYzMTMyNDYwNTgzMQ==631324605831.png);
        width:${size};
        height:${size};
        background-size:${size} ${size};
        position:fixed;
        display:none;
        cursor:none;
        transform: translate(-30%, -20%);
    }
    `)
    document.body.append(cursor)
    return cursor
}
const cursor = createCursor()

// 工具方法
function addStyles(target, styles) {
    const style = document.createElement(&#039;style&#039;)
    style.textContent = styles
    target.append(style)
}

function h(tag = &#039;div&#039;) {
    return document.createElement(tag)
}</code></pre>
</div><p>编写更新玉兔位置的方法<code>refreshCursorPos</code>，并在一段时间后，让指针恢复原状</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::0e8zcuj2tm1tptj3qi79fsb::--><code>function refreshCursorPos(x, y) {
    cursor.style.display = &#039;block&#039;
    cursor.style.cursor = &#039;none&#039;
    cursor.style.left = `${x}px`
    cursor.style.top = `${y}px`

    // 一段时间后隐藏
    if (refreshCursorPos.timer) {
        clearTimeout(refreshCursorPos.timer)
    }
    refreshCursorPos.timer = setTimeout(() =&gt; {
        cursor.style.display = &#039;none&#039;
    }, 500)
}</code></pre>
</div><p>与此前的方法结合，并将目标元素的指针隐藏一段时间，隐藏与恢复这里用<code>WeakMap</code>来做一个辅助，存储节点与定时器的映射关系，做个简单的防抖</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::3texzzsppz7puumo7k0ipf::--><code>const weakMap = new WeakMap()
window.addEventListener(&#039;mousemove&#039;, function (e) {
    const { clientX, clientY } = e

    // 隐藏捕获mousemove事件的元素的指针，并在一段时间后恢复
    e.target.style.cursor = &#039;none&#039;
    let timer = weakMap.get(e.target)
    if(timer){
        clearTimeout(timer)
    }
    timer = setTimeout(()=&gt;{
        e.target.style.cursor = &#039;auto&#039;
    },500)
    weakMap.set(e.target,timer)

    // 更新玉兔位置
    refreshCursorPos(clientX, clientY)
})</code></pre>
</div><p>到这里你以为就结束了？当然没有，此时会有一个问题，你的玉兔指针无法正常工作，如下所示</p>
<p><img src="./mid-autumn-festival/MTYzMTM0NDc3ODMwMQ==631344778301.png" alt="图片" loading="lazy"></p>
<p>当月兔出现的时候，无法正常点击跳链，选择文字元素</p>
<p>原因是由于，所有的事件都被你的&quot;月兔&quot;所捕获了</p>
<p>如何避免事件被目标元素捕获？ 通过css设置元素<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/pointer-events" target="_blank" rel="noreferrer">pointer-events</a>属性为<code>none</code>即可，设置为<code>none</code>后，目标元素永远不会成为鼠标事件的<code>target</code></p>
<p>于是为<code>#cursor</code>元素的css，添上一行样式<code>pointer-events: none;</code>即可</p>
<h2 id="月饼轨迹实现" tabindex="-1">月饼轨迹实现 <a class="header-anchor" href="#月饼轨迹实现" aria-label="Permalink to “月饼轨迹实现”">&#8203;</a></h2>
<p>有了上面实现玉兔指针的经验实现月饼轨迹就很容易了</p>
<p>每个月饼元素均用一个div绘制，将月饼的初始样式表先加入到页面中</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::e60x2pirn699kvqn3macr8::--><code>const orbitSize = &#039;40px&#039;
addStyles(document.body, `
    .orbit{
        background-image:url(./mid-autumn-festival/MTYzMTMyNDMwODg2Nw==631324308867.png);
        width:${orbitSize};
        height:${orbitSize};
        background-size:${orbitSize} ${orbitSize};
        position:fixed;
        display:none;
        cursor:none;
        pointer-events: none;
    }
`)</code></pre>
</div><p>月饼轨迹上限的月饼设置为<strong>5</strong>个，简单的循环创建一下</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::gpnhpxd8ptuklgcxhymz3s::--><code>const ybCounts = 5
const domList = []
for (let i = 0; i &lt; ybCounts; i++) {
    const d = h()
    d.classList.add(&#039;orbit&#039;)
    domList.push(d)
    document.body.append(d)
}</code></pre>
</div><p>创建一个数组用于存储指针最近的<strong>5</strong>个位置，一个临时变量用于后续辅助存储轨迹点信息</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::l563wvgf2iqfzhd39hw26m::--><code>const posList = []
let now = 0</code></pre>
</div><p>编写<code>refreshOrbit</code>方法用于更新轨迹：</p>
<ul>
<li>由于轨迹有个缩放的效果，越到后面的圆饼越小，这里通过<code>maxScale</code>确定最大的放大倍数</li>
<li>根据轨迹点个数，确定每个<code>月饼</code>最终的缩放倍数</li>
<li>根据存储的指针位置信息，一一对应的更新月饼位置即可</li>
</ul>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::so2786xipqj58pbncnp9::--><code>function refreshOrbit(x, y) {
    // 刷新位置
    const maxScale = 1.5
    const minScale = maxScale / domList.length
    posList.forEach(({ x, y }, idx) =&gt; {
        const dom = domList[idx]
        dom.style.display = &#039;block&#039;
        dom.style.left = `${x}px`
        dom.style.top = `${y}px`
        dom.style.transform = `scale(${(idx + 1) * minScale}) translate(10%,10%)`
        if (dom.timer) {
            clearTimeout(dom.timer)
        }
        dom.timer = setTimeout(() =&gt; {
            dom.style.display = &#039;none&#039;
        }, 50 * (idx + 1))
    })

    const nowTime = Date.now()
    // 隔一段时间存储一个
    if (now + 50 &gt; nowTime) {
        return
    }
    now = nowTime
    posList.push({
        x, y
    })
    // 只存储限定的个数
    if (posList.length === ybCounts+1) {
        posList.shift()
    }
}</code></pre>
</div><p>时间回掉中调用更新轨迹的方法</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::yedyqa59kinxjf2mrn4g1::--><code>window.addEventListener(&#039;mousemove&#039;, function (e) {
    const { clientX, clientY } = e
    // ...省略其它代码
    // 更新月饼轨迹
    refreshOrbit(clientX, clientY)
})</code></pre>
</div><h2 id="支持移动端" tabindex="-1">支持移动端 <a class="header-anchor" href="#支持移动端" aria-label="Permalink to “支持移动端”">&#8203;</a></h2>
<p>这个简单，监听<code>touchmove</code>事件即可</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::2zmuqtdu69r6ysbjfwy89o::--><code>window.addEventListener(&#039;touchmove&#039;, function (e) {
    const { clientX, clientY } = e.changedTouches[0]
    refreshCursorPos(clientX, clientY)

    // 更新月饼轨迹
    refreshOrbit(clientX, clientY)
})</code></pre>
</div><h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>后续准备把这个设置指针样式的脚本抽成一个通用的js sdk和大家分享，这样想怎么改指针样式就怎么改</p>
<p>大家有更好的方案可以评论区交流一波</p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/mid-autumn-festival/MTYzMTM0MDYwODYyOQ==631340608629.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[优雅的处理挂载window上的函数可能不存在的情况]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/window-var.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/window-var.html</guid>
            <pubDate>Wed, 01 Sep 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[背景
在做一个Web JS SDK（A）时，内部会用到另一个Web JS SDK（B）的方法。（文中后续用A/B代替两者）
B通常会提供Script和NPM包两种使用方式
::: warning 使用]]></description>
            <content:encoded><![CDATA[<h1 id="优雅的处理挂载window上的函数可能不存在的情况" tabindex="-1">优雅的处理挂载window上的函数可能不存在的情况 <a class="header-anchor" href="#优雅的处理挂载window上的函数可能不存在的情况" aria-label="Permalink to “优雅的处理挂载window上的函数可能不存在的情况”">&#8203;</a></h1>
<h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to “背景”">&#8203;</a></h2>
<p>在做一个Web JS SDK（A）时，内部会用到另一个Web JS SDK（B）的方法。（文中后续用A/B代替两者）</p>
<p>B通常会提供Script和NPM包两种使用方式</p>
<div  class="warning custom-block"><p class="custom-block-title">使用npm引入的缺点</p>
<ul>
<li>增加包体积</li>
<li>如果这个SDK被Web应用已经引入过页面，那么理论上可直接使用，不必要再整一个</li>
</ul>
</div>
<p>如果SDK B包含script引入的方式，目标页面也存在可能会引入B的情况，那么优先考虑使用Script引入依赖的SDK的情况：例如</p>
<ul>
<li>目标页面已经引入过JQuery（符合SDK A的使用需求），那么SDK A就可以直接使用已经存在的<code>$</code>进行操作即可，不必再创建jQuery的script</li>
<li>通常页面都会接入埋点监控等基建服务SDK B，SDK A也需要通过B进行数据的上报</li>
</ul>
<h2 id="衍生需求" tabindex="-1">衍生需求 <a class="header-anchor" href="#衍生需求" aria-label="Permalink to “衍生需求”">&#8203;</a></h2>
<ul>
<li>挂载在window上的函数不存在时，自动通过script或者polyfill（垫片方法）补全这个方法</li>
<li>调用方依旧按照SDK B的文档进行使用</li>
</ul>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::mk04mrie1qo102p8zmyx90f::--><code>window.sdkB(options)</code></pre>
</div><h2 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to “解决方案”">&#8203;</a></h2>
<p>编写一个通用的工具函数，处理上述的<code>衍生需求</code></p>
<p>方法定义如下</p>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::iw671wdpxmc9ywwl9o04jg::--><code>function patchWindowFun(
  key: string,
  value: string | Function,
  options?: {
    afterScriptLoad?: Function
    beforeAppendScript?: Function
    alreadyExistCB?: Function
    async?: boolean
    defer?: boolean
  },
)</code></pre>
</div><p>总共支持传入3个参数:</p>
<ol>
<li><code>key</code>：带判断的方法在window上的属性名</li>
<li><code>value</code>：不存在时的取值（function 表明直接使用此方法代替，string类型表明方法来源外部加载的js资源）</li>
<li><code>options</code>：是一些可选的配置项，主要用于处理使用过外部js资源加载方法的场景
<ol>
<li><code>afterScriptLoad</code>：资源加载完成后的回掉</li>
<li><code>beforeAppendScript</code>：资源加载前的回掉</li>
<li><code>alreadyExistCB</code>：方法如果已经存在执行的回掉</li>
<li><code>async</code>：控制script的<strong>async</strong>属性</li>
<li><code>defer</code>：控制script的<strong>defer</strong>属性</li>
</ol>
</li>
</ol>
<p>由于大多数web sdk都会存在需要调用特定函数或者方法进行初始化的情况，固提供了<code>afterScriptLoad</code>,<code>beforeAppendScript</code>,<code>alreadyExistCB</code>三个钩子函数处理不同时机初始化的情况</p>
<h2 id="方法实现" tabindex="-1">方法实现 <a class="header-anchor" href="#方法实现" aria-label="Permalink to “方法实现”">&#8203;</a></h2>
<p>如果目标属性存在则直接执行相应的回掉，不做进一步处理</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::rbfw4k4dptqklxq4l5vnp::--><code>  if (window[key]) {
    alreadyExistCB &amp;&amp; alreadyExistCB()
    console.log(key, &#039;already exist&#039;)
    return
  }</code></pre>
</div><p>目标属性不存在，传入的方法存在时直接进行赋值</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::6qrdqzc3yuhjo7vv70iwlj::--><code>  // 函数直接赋值
  if (typeof value === &#039;function&#039;) {
    window[key] = value
    return
  }</code></pre>
</div><p>剩余逻辑则是处理方法从外部js资源加载的情况</p>
<p>由于加载script大部分情况是异步的，业务代码中可能已经调用了相关方法，为此临时创建一个方法收集传入的参数</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::k8evz6cwsao8r526ookj::--><code>let params = []
window[key] = function () {
  params.push(arguments)
}</code></pre>
</div><p>下面的逻辑就是处理<code>script</code>加载的逻辑</p>
<p>在js资源加载完成后通过<code>apply</code>配合<code>forEach</code>将提前调用方法产生的参数重新正确的执行一次</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::5aq6e9dhyqhdq5ki1x26rr::--><code>const script = document.createElement(&#039;script&#039;)
script.src = value
script.async = !!defer
script.defer = !!async
script.onload = function () {
  afterScriptLoad &amp;&amp; afterScriptLoad()
  // 处理原来没处理的
  params.forEach(param =&gt; {
    window[key].apply(this, param)
  })
}
beforeAppendScript &amp;&amp; beforeAppendScript()
document.body.append(script)</code></pre>
</div><h2 id="完整源码如下" tabindex="-1">完整源码如下 <a class="header-anchor" href="#完整源码如下" aria-label="Permalink to “完整源码如下”">&#8203;</a></h2>
<div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre><!--::markdown-it-async::nnm1lz10eeen7rkls0w66::--><code>function patchWindowFun(
  key: string,
  value: string | Function,
  options?: {
    afterScriptLoad?: Function
    beforeAppendScript?: Function
    alreadyExistCB?: Function
    async?: boolean
    defer?: boolean
  },
) {
  // 存在不处理
  const { alreadyExistCB, afterScriptLoad, beforeAppendScript, defer, async } = options || {}

  if (window[key]) {
    alreadyExistCB &amp;&amp; alreadyExistCB()
    console.log(key, &#039;already exist&#039;)
    return
  }

  // 函数直接赋值
  if (typeof value === &#039;function&#039;) {
    window[key] = value
    return
  }

  // script url
  if (typeof value === &#039;string&#039;) {
    let params = []
    window[key] = function () {
      params.push(arguments)
    }

    const script = document.createElement(&#039;script&#039;)
    script.src = value
    script.async = !!defer
    script.defer = !!async
    script.onload = function () {
      afterScriptLoad &amp;&amp; afterScriptLoad()
      // 处理原来没处理的
      params.forEach(param =&gt; {
        window[key].apply(this, param)
      })
    }
    beforeAppendScript &amp;&amp; beforeAppendScript()
    document.body.append(script)
  }
}</code></pre>
</div><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to “小结”">&#8203;</a></h2>
<p>目前的方法实现仅适用于，<strong>调用的方法相对独立</strong>不影响正常的交互</p>
<p>如果业务代码依赖方法的返回值，那么异步通过<code>script</code>加载的方法方式将不太适用</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[实现调用就执行一次的定时器]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/js/immed-setInterval.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/bigWeb/js/immed-setInterval.html</guid>
            <pubDate>Sun, 29 Aug 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[问题描述
部分场景需要使用定时器延迟或者循环执行
通常在循环场景下又希望首次调用的时候立即执行一次
当然这个处理，也是比较简单的，但是看上去总觉得不太优雅
```js
function fn(){}
]]></description>
            <content:encoded><![CDATA[<h1 id="实现调用就执行一次的定时器" tabindex="-1">实现调用就执行一次的定时器 <a class="header-anchor" href="#实现调用就执行一次的定时器" aria-label="Permalink to “实现调用就执行一次的定时器”">&#8203;</a></h1>
<h2 id="问题描述" tabindex="-1">问题描述 <a class="header-anchor" href="#问题描述" aria-label="Permalink to “问题描述”">&#8203;</a></h2>
<p>部分场景需要使用定时器延迟或者循环执行</p>
<p>通常在循环场景下又希望首次调用的时候立即执行一次</p>
<p>当然这个处理，也是比较简单的，但是看上去总觉得不太优雅</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::ogiwrw10pbh9ggq66u23bn::--><code>function fn(){}

fn()
const timer = setTimeout(fn,timeout)</code></pre>
</div><p>咱的目的是整个优雅的<code>setImmTimeout</code>和<code>setImmInterval</code>，即在调用够会立即执行一次回掉函数</p>
<blockquote>
<p>关于实现较准时的setTimeout，可以进一步阅读<a href="https://mp.weixin.qq.com/s/JYfm8oiQmomkNnJIFWDkrQ" target="_blank" rel="noreferrer">这篇文章</a>,本文不涉及定时器的实现</p>
</blockquote>
<h2 id="前置知识" tabindex="-1">前置知识 <a class="header-anchor" href="#前置知识" aria-label="Permalink to “前置知识”">&#8203;</a></h2>
<p>定时器的参数构成:</p>
<ol>
<li>func：被调用的函数</li>
<li>delay：延迟的时间</li>
<li>(可选)arg1-argN：传递给被调用函数的参数</li>
</ol>
<p>返回值：一个标识目标计时器的非零数字，用于清楚目标计数器</p>
<p>参数构成如下，<code>[]</code>中包含的是可选的参数，并不是传递一个数组</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::v9utc0jnnlrw9v8whh4ps::--><code>(func, delay, [arg1, arg2, ...]);</code></pre>
</div><h2 id="setimmx" tabindex="-1">setImmX <a class="header-anchor" href="#setimmx" aria-label="Permalink to “setImmX”">&#8203;</a></h2>
<p>朴素的实现方法如下，延迟执行前调用一次</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::peri2khetw2m3t15sa6g7::--><code>function setImmTimeout(func, delay = 0, ...args) {
    if (typeof func !== &#039;function&#039;) throw new TypeError(&#039;func is not function&#039;)
    func.apply(this, args)
    return setTimeout(func, delay, ...args)
}

function setImmInterval(func, delay = 0, ...args){
    if (typeof func !== &#039;function&#039;) throw new TypeError(&#039;func is not function&#039;)
    func.apply(this, args)
    return setInterval(func, delay, ...args)
}</code></pre>
</div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[做一个CL版的时间管理工具（15）]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/works/time-tools/time-tools-15.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/works/time-tools/time-tools-15.html</guid>
            <pubDate>Mon, 23 Aug 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[前言
在前一期文章中完善了一个生成Web页面浏览事务进展的`timec page`指令
但在日`常使用工具中发现发现了两个痛点：
1. 由于事务繁多，经常会忘记结束一个事情，就开始了下一个事情
2. ]]></description>
            <content:encoded><![CDATA[<h1 id="做一个cli版的时间管理工具-15" tabindex="-1">做一个CLI版的时间管理工具（15） <a class="header-anchor" href="#做一个cli版的时间管理工具-15" aria-label="Permalink to “做一个CLI版的时间管理工具（15）”">&#8203;</a></h1>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>在前一期文章中完善了一个生成Web页面浏览事务进展的<code>timec page</code>指令</p>
<p>但在日`常使用工具中发现发现了两个痛点：</p>
<ol>
<li>由于事务繁多，经常会忘记结束一个事情，就开始了下一个事情</li>
<li>在切换任务的时候需要完整的输入任务名才能进行任务的切换</li>
</ol>
<p>当然还有一些其它的痛点，本期着重<strong>解决第1个痛点</strong></p>
<h2 id="定时提醒feature开发" tabindex="-1">定时提醒Feature开发 <a class="header-anchor" href="#定时提醒feature开发" aria-label="Permalink to “定时提醒Feature开发”">&#8203;</a></h2>
<p>定时提醒，并自动执行<code>timec thing -s</code>保存，使用一个提示音进行提示</p>
<p>预期指令<code>timec remind</code></p>
<ul>
<li><code>-c,--cycle [time]</code>:设置提醒的周期，单位分钟，默认40分钟提醒一次</li>
</ul>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::hcxlgeegbz3l17wezjpj2::--><code>timec remind [option]</code></pre>
</div><h3 id="注册指令" tabindex="-1">注册指令 <a class="header-anchor" href="#注册指令" aria-label="Permalink to “注册指令”">&#8203;</a></h3>
<p>使用<code>commander.command</code>注册<code>remind</code>指令，使用<code>.option</code>方法设置一个可选参数<code>cycle</code>, 第二个参数传入默认值<code>'40'</code></p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::jqnfrjk9s16qkzxq9vme::--><code>commander.command(&#039;remind&#039;)
  .description(&#039;Open auto remind music&#039;)
  .option(&#039;-c,--cycle [time]&#039;, &#039;Set the duration of the reminder cycle（minute）&#039;, &#039;40&#039;)
  .action(remindCommand);</code></pre>
</div><p>具体逻辑如下:</p>
<ol>
<li>将<code>cycle</code>参数转为整数</li>
<li>然后使用定时器<code>setTimeout</code>，在<code>cycle*oneMinute</code>毫秒后,播放音频与自动记录</li>
</ol>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::iv3b2s7nsqql1qk6vjwtb::--><code>const spawn = require(&#039;cross-spawn&#039;);

// 提醒周期（minute）
  const time = +cmdObj.cycle;
  const oneMinute = 1000 * 60;
  const loop = () =&gt; {
    setTimeout(() =&gt; {
      playRemindAudio(loop);
      // 自动记录一下
      const cwd = getCWD();
      const { thing } = getConfig();
      spawn(&#039;timec&#039;, [&#039;thing&#039;, thing.name], {
        cwd,
        stdio: &#039;inherit&#039;,
      });
    }, time * oneMinute);
  };
  loop();</code></pre>
</div><p>其中自动记录的方法比较简单，通过<code>spawn</code>执行<code>timec thing [newthing]</code>指令即可进行自动的事件记录</p>
<p><code>playRemindAudio</code>中包含的就是播放预设音频的逻辑</p>
<h3 id="播放声音" tabindex="-1">播放声音 <a class="header-anchor" href="#播放声音" aria-label="Permalink to “播放声音”">&#8203;</a></h3>
<p>这个算是知识盲区，以前从来没有使用Node.js原生的API播放过音频</p>
<h4 id="系统指令" tabindex="-1">系统指令 <a class="header-anchor" href="#系统指令" aria-label="Permalink to “系统指令”">&#8203;</a></h4>
<p>首先想到的方案就是通过<code>spawn</code>调用系统的指令播放音频</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::50jk4h9o9i46b302nh8chp::--><code>spawn(&#039;mpg123&#039;, [&#039;url.mp3&#039;);</code></pre>
</div><p>这个是调用<a href="https://mpg123.org/" target="_blank" rel="noreferrer">mpg123</a>系统指令</p>
<p>linux操作系统安装指令如下</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::hov6exn6e1nrz9o9sgd0jn::--><code>sudo apt-get install mpg123</code></pre>
</div><p>调用系统指令播放音乐，比较有局限性，常见操作系统有3种，不一定所有操作系统都支持一样的指令</p>
<p>如果使用此种方式就需要调研目标平台，装机就默认支持的指令</p>
<h4 id="现存npm包" tabindex="-1">现存NPM包 <a class="header-anchor" href="#现存npm包" aria-label="Permalink to “现存NPM包”">&#8203;</a></h4>
<p>这个问题肯定不是开发者第一次遇见，肯定是有前辈们遇到过，通过搜索引擎检索，pick了下述两个：</p>
<ul>
<li><a href="https://github.com/Marak/play.js#readme" target="_blank" rel="noreferrer">play</a></li>
<li><a href="https://www.npmjs.com/package/audio-play" target="_blank" rel="noreferrer">audio-play</a></li>
</ul>
<p>首先是第一个,API 比较简单，通过<a href="https://github.com/Marak/play.js/blob/d3ca7a04d1bd58c3ad72df3088f92985742e41cc/lib/play.js#L54" target="_blank" rel="noreferrer">查看源码</a>，实际上他也是调用系统指令播放</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::8e13l4ugy3s5blgtwwg3lc::--><code>const play = require(&#039;play/lib/play&#039;);

play.sound(&#039;filepath.wav&#039;);</code></pre>
</div><p><img src="./time-tools-15/MTYyOTczMTE1Mjk1MA==629731152950.png" alt="图片" loading="lazy"></p>
<p>其次是<code>audio-play</code>,需要配合<code>audio-loader</code>使用</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::8bzujhorqcimk0fhn84x0r::--><code>const audioPlay = require(&#039;audio-play&#039;);
const audioLoad = require(&#039;audio-loader&#039;);
audioLoad(&#039;filepath.wav&#039;).then((v) =&gt; {
  audioPlay(v);
});</code></pre>
</div><p>在<code>mac</code>上测试播放正常，在linux上依旧无法正常播放</p>
<h4 id="使用系统蜂鸣器" tabindex="-1">使用系统蜂鸣器 <a class="header-anchor" href="#使用系统蜂鸣器" aria-label="Permalink to “使用系统蜂鸣器”">&#8203;</a></h4>
<p>这个就比较简单，执行下面代码即可，但是在我的linux上测试仍然无效，emmmm裂开了</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::i0yvfqjc5gltmtt037f8k::--><code>process.stdout.write(&#039;\x07&#039;)</code></pre>
</div><h4 id="todo" tabindex="-1">TODO <a class="header-anchor" href="#todo" aria-label="Permalink to “TODO”">&#8203;</a></h4>
<p>整理一篇Node.js播放音频的干货实践文章，目标3端通用一个API</p>
<h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>由于每天空闲时间有限，本文就先到这，下一期将继续完善<code>timec page</code>指令</p>
<p>如果读者还感觉意犹未尽，敬请期待后续更新，或持续关注一下<a href="https://github.com/ATQQ/time-control" target="_blank" rel="noreferrer">仓库</a>的状态</p>
<p>欢迎评论区提需求，交流探讨</p>
<p>本系列会不断的更新迭代，直至产品初代完成</p>
<ul>
<li><a href="https://github.com/ATQQ/time-control" target="_blank" rel="noreferrer">仓库地址</a></li>
</ul>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/time-tools-15/MTYyOTczMTE1Mjk1MA==629731152950.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[Node中require与fs.readFile读取JSON文件的对比]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/node-require-json.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/technology/learn/node-require-json.html</guid>
            <pubDate>Thu, 19 Aug 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[背景
在做时间管理工具出现了一个问题
代码中使用require读取JSON文件，服务端启动后发现当JSON文件发生改动后，返回的仍然是原来的JSON内容
本着打破砂锅问道低的精神，就展开了资料查阅探究]]></description>
            <content:encoded><![CDATA[<h1 id="node中require与fs-readfile读取json文件的对比" tabindex="-1">Node中require与fs.readFile读取JSON文件的对比 <a class="header-anchor" href="#node中require与fs-readfile读取json文件的对比" aria-label="Permalink to “Node中require与fs.readFile读取JSON文件的对比”">&#8203;</a></h1>
<h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to “背景”">&#8203;</a></h2>
<p>在做<a href="https://github.com/ATQQ/time-control" target="_blank" rel="noreferrer">时间管理工具</a>出现了一个问题</p>
<p><a href="https://github.com/ATQQ/time-control/blob/2ce91222ac937dc10205d1153cee181985d87a5a/src/utils/index.js#L188" target="_blank" rel="noreferrer">代码</a>中使用require读取JSON文件，服务端启动后发现当JSON文件发生改动后，返回的仍然是原来的JSON内容</p>
<p>本着打破砂锅问道低的精神，就展开了资料查阅探究，趁机学习一波新知识</p>
<h2 id="原因" tabindex="-1">原因 <a class="header-anchor" href="#原因" aria-label="Permalink to “原因”">&#8203;</a></h2>
<p>结论先行，<code>require</code>引入的模块会被Node缓存，下面用一个简单的demo实验一下</p>
<h3 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to “示例”">&#8203;</a></h3>
<p><strong>test-module.js</strong></p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::9uu8udnuerqar6qgp31c1u::--><code>console.log(&#039;1&#039;);

module.exports = {
    name:&#039;0&#039;
}</code></pre>
</div><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::6sc97dfmv6ct8qy6866m4r::--><code>const m1 = require(&#039;./test-module&#039;)
m1.name = &#039;2&#039;
const m2 = require(&#039;./test-module&#039;)
console.log(m2.name);</code></pre>
</div><p>运行后的输出结果输出如下</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::w35njphn336ttly3doake::--><code>1
2</code></pre>
</div><p>从这就可以得出结论Node会缓存引入的模块，name如何查看已经被缓存的模块</p>
<h3 id="查看缓存" tabindex="-1">查看缓存 <a class="header-anchor" href="#查看缓存" aria-label="Permalink to “查看缓存”">&#8203;</a></h3>
<p>通过<a href="http://nodejs.cn/api/modules/require_cache.html" target="_blank" rel="noreferrer">require.cache</a>即可获取被缓存的模块：</p>
<ul>
<li>返回一个对象</li>
</ul>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::vq56y2co5z9peqggi6jfm::--><code>const m1 = require(&#039;./test-module&#039;)
console.log(require.cache);</code></pre>
</div><p>输出内容如下(这里就贴一张截图)
<img src="./node-require-json/MTYyOTM4NTA0MDE2MQ==629385040161.png" alt="图片" loading="lazy"></p>
<h3 id="删除缓存" tabindex="-1">删除缓存 <a class="header-anchor" href="#删除缓存" aria-label="Permalink to “删除缓存”">&#8203;</a></h3>
<p>既然<code>require.cache</code>返回内容是一个普普通通的对象，name可以通过<code>delete</code>关键字进行移除</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::2tqmnj8790mmad4ln6th5c::--><code>const m1 = require(&#039;./test-module&#039;)
m1.name = &#039;2&#039;
console.log(m1.name);

delete require.cache[`${__dirname}/test-module.js`]
const m2 = require(&#039;./test-module&#039;)
console.log(m2.name);</code></pre>
</div><p>内容输出如下</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::wx5o1xkpxwstq4tfqmipk::--><code>1
2
1
0</code></pre>
</div><p>原因捋完后，咱们就开始进入主题</p>
<p>进行<code>读取JSON</code>文件的对比分析</p>
<h2 id="读取json对比" tabindex="-1">读取JSON对比 <a class="header-anchor" href="#读取json对比" aria-label="Permalink to “读取JSON对比”">&#8203;</a></h2>
<ul>
<li>require可以省略<code>.json</code>后缀</li>
<li>fs.readFile读取不能省略后缀
test.json</li>
</ul>
<div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre><!--::markdown-it-async::z2m191uhua1n4uzztcfr1::--><code>{
    &quot;name&quot;:&quot;xm&quot;
}</code></pre>
</div><p>测试demo</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::xu01dzmlhb92gxgdgglt1e::--><code>const d1 = require(&#039;./test.json&#039;)
console.log(d1); // { name: &#039;xm&#039; }
const d2 = require(&#039;./test&#039;)
console.log(d2); // { name: &#039;xm&#039; }</code></pre>
</div><h2 id="其它差异" tabindex="-1">其它差异 <a class="header-anchor" href="#其它差异" aria-label="Permalink to “其它差异”">&#8203;</a></h2>
<h3 id="编码" tabindex="-1">编码 <a class="header-anchor" href="#编码" aria-label="Permalink to “编码”">&#8203;</a></h3>
<ul>
<li>require只能按<code>utf-8</code>格式读取</li>
<li>fs.readFile<code>Sync</code>可以<strong>设置编码格式</strong></li>
</ul>
<h3 id="异步同步" tabindex="-1">异步同步 <a class="header-anchor" href="#异步同步" aria-label="Permalink to “异步同步”">&#8203;</a></h3>
<ul>
<li>require是同步读取</li>
<li>通过<code>fs</code>既可以同步读取也可以异步读取</li>
</ul>
<h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to “小结”">&#8203;</a></h2>
<ul>
<li><code>require</code>支持缓存</li>
<li><code>require</code>只能按UTF-8读取内容</li>
<li><code>require</code>是同步的</li>
<li><code>require</code>读取JSON文件可以省略<code>.json</code>后缀</li>
</ul>
<h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>本文内容比较精简，对于兼职学Node的同学可能会漏掉此部分知识</p>
<p>后续将继续更新<code>时间管理工具</code>的实践内容</p>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/node-require-json/MTYyOTM4NTA0MDE2MQ==629385040161.png" length="0" type="image/png"/>
        </item>
        <item>
            <title><![CDATA[做一个CL版的时间管理工具（14）]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/works/time-tools/time-tools-14.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/works/time-tools/time-tools-14.html</guid>
            <pubDate>Wed, 18 Aug 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[前言
在前一篇文章中完善了`timec page`指令的前后端交互逻辑,本期将完善这个指令打开页面的功能
 本期效果预览
 功能开发
 完善可视化页面
由于项目采用的Vue3，所以接入Element ]]></description>
            <content:encoded><![CDATA[<h1 id="做一个cli版的时间管理工具-14" tabindex="-1">做一个CLI版的时间管理工具（14） <a class="header-anchor" href="#做一个cli版的时间管理工具-14" aria-label="Permalink to “做一个CLI版的时间管理工具（14）”">&#8203;</a></h1>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>在前一篇文章中完善了<code>timec page</code>指令的前后端交互逻辑,本期将完善这个指令打开页面的功能</p>
<h2 id="本期效果预览" tabindex="-1">本期效果预览 <a class="header-anchor" href="#本期效果预览" aria-label="Permalink to “本期效果预览”">&#8203;</a></h2>
<p><img src="./time-tools-14/MTYyOTMwMDY4MzQwNA==timec-page.gif?s1=https://img.cdn.sugarat.top/mdImg/MTYyOTMwMDY4MzQwNA==timec-page.gif" alt="图片" loading="lazy"></p>
<h2 id="功能开发" tabindex="-1">功能开发 <a class="header-anchor" href="#功能开发" aria-label="Permalink to “功能开发”">&#8203;</a></h2>
<h3 id="完善可视化页面" tabindex="-1">完善可视化页面 <a class="header-anchor" href="#完善可视化页面" aria-label="Permalink to “完善可视化页面”">&#8203;</a></h3>
<p>由于项目采用的Vue3，所以接入<a href="https://element-plus.gitee.io/" target="_blank" rel="noreferrer">Element UI Plus组件库</a></p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::nlorlrpps482pgztcqc1i::--><code>yarn add element-plus</code></pre>
</div><p>直接全量引入饿了么UI，因为不需要Build，所以不考虑包体积带来的影响，其次使用了Vite也不用担心影响启动速度</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::l3fhac8arn9t8qwpfer9qb::--><code>// main.js
import { createApp } from &#039;vue&#039;;
import ElementPlus from &#039;element-plus&#039;;
import &#039;element-plus/lib/theme-chalk/index.css&#039;;
import App from &#039;./App.vue&#039;;

const app = createApp(App);
app.use(ElementPlus);

app.mount(&#039;#app&#039;);</code></pre>
</div><p>选用日历组件<code>el-calendar</code>，直接使用的化，默认样式如下：</p>
<p><img src="./time-tools-14/MTYyOTI5ODQxMTA5Ng==629298411096.png" alt="图片" loading="lazy"></p>
<p>我们可以通过插槽自定义每个单元格的内容，期望每个单元格的大概结构如下</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::eefbnaqo1qoux90yjog14h::--><code>&lt;div class=&quot;day&quot;&gt;
    &lt;div class=&quot;time&quot;&gt;
        &lt;strong&gt;
            &lt;span&gt;1&lt;/span&gt;
        &lt;/strong&gt;
        &lt;span&gt;0h&lt;/span&gt;
    &lt;/div&gt;
    &lt;ul class=&quot;tasks&quot;&gt;
        &lt;li&gt;
            &lt;span&gt;任务名&lt;/span&gt;
            &lt;span&gt;0.5h&lt;/span&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;span&gt;任务名2&lt;/span&gt;
            &lt;span&gt;0.53h&lt;/span&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;</code></pre>
</div><p>阅读组件文档通过<code>#dateCell</code>插槽进行内容自定义</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::a0v3hb3iijqkyiu96h4n::--><code>&lt;el-calendar v-model=&quot;value&quot;&gt;
  &lt;template #dateCell=&quot;{ data }&quot;&gt;
    &lt;!-- 自定义 --&gt;
  &lt;/template&gt;
&lt;/el-calendar&gt;</code></pre>
</div><p>其中<code>data</code>有一个属性<code>day</code>，其是一个具体的日期，格式为<code>yyyy-MM-dd</code>,例如2021-08-18</p>
<p>为了展示出这样的数据，先设计出一个单元格所需数据的JSON结构，下面是第一版的数据结构包含：</p>
<ul>
<li>一天总耗时</li>
<li>任务列表
<ul>
<li>任务名</li>
<li>任务耗时
<ul>
<li>事件列表
<ul>
<li>事件名</li>
<li>事件耗时</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::elim7po4ohah9lgyw32sob::--><code>const item = {
  time: &#039;5.55h&#039;,
  tasks: [
    {
      title: &#039;测试&#039;,
      time: &#039;5.55h&#039;,
      things: [
        {
          title: &#039;写文档&#039;,
          time: &#039;5.55h&#039;,
        },
      ],
    },
  ],
},</code></pre>
</div><p>但使用的时候发现，每一项要在插槽中使用，插槽没有暴露<code>v-for</code>渲染的方法，只有能拿到给予的日期，那么渲染的数据结构只能是个K-V的对象</p>
<p>优化后的数据结构如下,对外包了一层</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::mxd27dccr9ifl8xqhak4uh::--><code>const oneDay = {
  &#039;2021-08-18&#039;:item
}</code></pre>
</div><p>于是乎页面的代码就能梳理出第一版，包含渲染每一天的数据（时间+任务），但并未包含上things的数据</p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::d7g1hgku2ay89k08llm::--><code>&lt;template&gt;
  &lt;div&gt;
    &lt;el-calendar v-model=&quot;value&quot;&gt;
      &lt;template #dateCell=&quot;{ data }&quot;&gt;
        &lt;div class=&quot;day&quot;&gt;
          &lt;div class=&quot;time&quot;&gt;
            &lt;strong&gt;
              &lt;span&gt;{{ parseDay(data.day) }}&lt;/span&gt;
            &lt;/strong&gt;
            &lt;span&gt;{{ sumData[data.day]?.time || &#039;0h&#039; }}&lt;/span&gt;
          &lt;/div&gt;
          &lt;ul class=&quot;tasks&quot; v-if=&quot;sumData[data.day]?.tasks?.length&quot;&gt;
            &lt;li v-for=&quot;(v,idx) in sumData[data.day].tasks&quot; :key=&quot;idx&quot;&gt;
              &lt;span&gt;{{ v.title }}&lt;/span&gt;
              &lt;span&gt;{{ v.time }}&lt;/span&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
        &lt;/div&gt;
      &lt;/template&gt;
    &lt;/el-calendar&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { reactive, ref } from &#039;vue&#039;;

const value = ref(new Date());
const parseDay = (date) =&gt; {
  const [day] = date.split(&#039;-&#039;).slice(2);
  return +day;
};

const sumData = reactive({
  &#039;2021-08-18&#039;: {
    time: &#039;5.55h&#039;,
    tasks: [
      {
        title: &#039;测试&#039;,
        time: &#039;5.55h&#039;,
        things: [
          {
            title: &#039;写文档&#039;,
            time: &#039;5.55h&#039;,
          },
        ],
      },
    ],
  },
});

&lt;/script&gt;</code></pre>
</div><p>这里things的数据用<code>Popover 弹出框</code>渲染</p>
<p><img src="./time-tools-14/MTYyOTI5OTQ1Mzk2Ng==629299453966.png" alt="图片" loading="lazy"></p>
<p>于是乎将渲染tasks的逻辑小小改动一下，就成了下面这种，其中<code>#reference</code>插槽标识被包裹的内容，默认插槽是弹窗的内容，弹窗的标题即当天的日期<code>data.day</code></p>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::r5pwx9ruzhfitb0es6hjt::--><code>&lt;ul class=&quot;tasks&quot; v-if=&quot;sumData[data.day]?.tasks?.length&quot;&gt;
    &lt;div v-for=&quot;(v,idx) in sumData[data.day].tasks&quot; :key=&quot;idx&quot;&gt;
        &lt;el-popover v-if=&quot;v?.things?.length&quot; placement=&quot;right&quot; :title=&quot;data.day&quot; :width=&quot;200&quot; trigger=&quot;click&quot;&gt;
            &lt;template #reference&gt;
                &lt;li&gt;
                    &lt;span&gt;{{ v.title }}&lt;/span&gt;
                    &lt;span&gt;{{ v.time }}&lt;/span&gt;
                &lt;/li&gt;
            &lt;/template&gt;
            &lt;ol class=&quot;things&quot;&gt;
                &lt;li v-for=&quot;(t,idx) in v.things&quot; :key=&quot;idx&quot;&gt;
                    &lt;span&gt;{{ t.title }}&lt;/span&gt;
                    &lt;span&gt;{{ t.time }}&lt;/span&gt;
                &lt;/li&gt;
            &lt;/ol&gt;
        &lt;/el-popover&gt;
    &lt;/div&gt;
&lt;/ul&gt;</code></pre>
</div><p>到此页面渲染逻辑就搞定了</p>
<p>接下来是从接口拿取数据，然后格式化进行展示的逻辑:</p>
<ol>
<li>引入获取每日数据接口方法<code>getEveryDayData</code></li>
<li>遍历返回的数据，然后对每一项数据进行格式化</li>
<li>通过<code>Object.assign</code>将新的数据赋给旧数据<code>sumData</code></li>
</ol>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::f20r1gpgnjpastxf8rc1ck::--><code>import { getEveryDayData } from &#039;../api&#039;;
const sumData = reactive({})

const refresData = async ()=&gt;{
  const { data } = await getEveryDayData()
  data.forEach(v=&gt;{
    Object.assign(sumData,{
      ...parseOneDay(v)
    })
  })
}</code></pre>
</div><p>接口返回的数据结构如下</p>
<p><img src="./time-tools-14/MTYyOTI5OTg2NjczMw==629299866733.png" alt="图片" loading="lazy"></p>
<p>没法直接使用，需要咱们清洗格式化一下，格式化数据的方法<code>parseOneDay</code>逻辑如下:</p>
<ul>
<li>创建一个初始化对象，包含<code>time</code>和<code>tasks</code>属性</li>
<li>处理拿到的接口数据</li>
<li>遍历其<code>tasks</code>
<ul>
<li>创建一个初始的任务，包含任务名，消耗时间，事件列表等属性</li>
<li>遍历每个<code>task</code>的事件列表，时间累加即为对应任务的耗时</li>
<li>任务时间累加就是当天的总耗时</li>
</ul>
</li>
<li>返回的数据加上日期title包一层</li>
</ul>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::m95h7mlwqz4tvscvse4c8::--><code>const parseOneDay = (data) =&gt; {
  const o = {
    time: &#039;&#039;,
    tasks: []
  }
  if (!data || !data.title) {
    return {}
  }
  let sumTime = 0
  data.tasks.forEach(t =&gt; {
    let task = {
      title: t.title,
      time: &#039;&#039;,
      things: []
    }

    let taskTime = 0
    t.things.forEach(thing =&gt; {
      const { time, content } = thing
      taskTime += (+time)
      task.things.push({
        title: content,
        time: `${time}h`
      })
    })
    task.time = `${taskTime}h`
    sumTime += taskTime

    o.tasks.push(task)
  })
  o.time = `${sumTime}h`
  return {
    [data.title]: o
  }
}</code></pre>
</div><p>数据处理完毕后就是调用,将调用逻辑放到<code>onMounted</code>钩子中，并将执行逻辑放入<code>setInterval</code>定时器中，通过接口轮训达到数据实时展示的效果</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::2iqhrma0dg5fngjwbkmjg6::--><code>import { onMounted } from &#039;vue&#039;;

onMounted(()=&gt;{
  setInterval(()=&gt;{
    refresData()
  },1200)
})</code></pre>
</div><h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>时间紧张，本文的代码可能有点shi，后续会抽时间在仓库中进行优化</p>
<p>由于每天空闲时间有限，本文就先到这，下一期将继续完善项目的交互和功能</p>
<p>如果读者还感觉意犹未尽，敬请期待后续更新，或持续关注一下<a href="https://github.com/ATQQ/time-control" target="_blank" rel="noreferrer">仓库</a>的状态</p>
<p>欢迎评论区提需求，交流探讨</p>
<p>本系列会不断的更新迭代，直至产品初代完成</p>
<ul>
<li><a href="https://github.com/ATQQ/time-control" target="_blank" rel="noreferrer">仓库地址</a></li>
</ul>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/time-tools-14/MTYyOTMwMDY4MzQwNA==timec-page.gif?s1=https%3A//img.cdn.sugarat.top/mdImg/MTYyOTMwMDY4MzQwNA%3D%3Dtimec-page.gif" length="0" type="image/gif"/>
        </item>
        <item>
            <title><![CDATA[做一个CL版的时间管理工具（13）]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/works/time-tools/time-tools-13.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/works/time-tools/time-tools-13.html</guid>
            <pubDate>Mon, 16 Aug 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[前言
在前一篇文章中加入了一个启动Web服务的指令`timec page`
本期就继续完善这个指令的效果
 本期效果预览
 功能开发
 Web侧
拟采用Vue3开发页面
安装项目依赖
```sh
ya]]></description>
            <content:encoded><![CDATA[<h1 id="做一个cli版的时间管理工具-13" tabindex="-1">做一个CLI版的时间管理工具（13） <a class="header-anchor" href="#做一个cli版的时间管理工具-13" aria-label="Permalink to “做一个CLI版的时间管理工具（13）”">&#8203;</a></h1>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>在前一篇文章中加入了一个启动Web服务的指令<code>timec page</code></p>
<p>本期就继续完善这个指令的效果</p>
<h2 id="本期效果预览" tabindex="-1">本期效果预览 <a class="header-anchor" href="#本期效果预览" aria-label="Permalink to “本期效果预览”">&#8203;</a></h2>
<h2 id="功能开发" tabindex="-1">功能开发 <a class="header-anchor" href="#功能开发" aria-label="Permalink to “功能开发”">&#8203;</a></h2>
<h3 id="web侧" tabindex="-1">Web侧 <a class="header-anchor" href="#web侧" aria-label="Permalink to “Web侧”">&#8203;</a></h3>
<p>拟采用Vue3开发页面</p>
<p>安装项目依赖</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::jmwufxv2fknnuoay3oz2e::--><code>yarn add vue@next @vue/compiler-sfc @vitejs/plugin-vue</code></pre>
</div><p>快速创建一个基于Vite+Vue3的模板项目</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::w3klosotskxcojsonut3j::--><code>npm init vite@latest my-vue-app --template vue</code></pre>
</div><p>完成后的目录结构如下</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::xytm88xmntqpbf1z6zpug::--><code>my-vue-app
├── index.html
├── package.json
├── public
|  └── favicon.ico
├── src
|  ├── App.vue
|  ├── assets
|  ├── components
|  └── main.js
└── vite.config.js</code></pre>
</div><p>我们将<code>vite.config.js</code>,<code>main.js</code>,<code>components</code>,<code>App.vue</code>,<code>index.html</code>这五部分的内容拷贝到我们项目的<code>src/page</code>目录下</p>
<p>拷贝完后的目录如下</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::wuc76xshbe92x6i7awxhz4::--><code>├── App.vue
├── assets
|  └── logo.png
├── components
|  └── HelloWorld.vue
├── index.html
├── main.js
└── vite.config.js</code></pre>
</div><p>接着改造一下<code>timec page</code>指令中的逻辑:</p>
<ul>
<li>定位到<code>vite.config.js</code>文件的位置</li>
<li>使用<code>--config</code>指定配置文件的位置</li>
<li>在<code>spawn</code>调用的方法中传入设置配置文件的参数</li>
</ul>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::vuhy3dlol8k4dhqfla09::--><code>const cwd = path.resolve(__dirname, &#039;../&#039;);
const viteConfigPath = path.join(cwd, &#039;src/page/vite.config.js&#039;);
const serveService = spawn(&#039;node_modules/.bin/vite&#039;, [&#039;src/page&#039;, &#039;--host&#039;, &#039;--config&#039;, viteConfigPath], {
  cwd,
  stdio: &#039;inherit&#039;,
});
// 。。。code</code></pre>
</div><p>到这一步前端工程的基本内容算搭好了，页面展示需要的数据，需通过Node相关的API才能获取，这里有两种方案：</p>
<ol>
<li>页面使用SSR（服务端渲染）方案</li>
<li>添加一个后端服务，通过接口调用传递所需要的数据</li>
</ol>
<p>项目采用第二种方案，下面展开介绍一下简单后端服务的搭建</p>
<h3 id="服务端" tabindex="-1">服务端 <a class="header-anchor" href="#服务端" aria-label="Permalink to “服务端”">&#8203;</a></h3>
<p>这里使用自己DIY的玩具框架<code>flash-wolves</code></p>
<p>安装依赖</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::il3t16w4aek5b4wpqspgp::--><code>yarn add flash-wolves</code></pre>
</div><p>编写基本调用逻辑,在src/page下创建一个文件<code>server.js</code></p>
<ul>
<li>使用<code>Node</code>执行这3行代码，这样一个简单的后端服务就在3001端口启动了</li>
</ul>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::iyb1227x8cb8awuro1wrfn::--><code>const { Fw } = require(&#039;flash-wolves&#039;);
const app = new Fw();
app.listen(3001);</code></pre>
</div><p>编写2个接口：</p>
<ol>
<li>获取配置文件</li>
<li>获取所有的数据（按天区分）</li>
</ol>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::zs78gavm82ajdx00vrgcjf::--><code>app.get(&#039;/json&#039;, (req, res) =&gt; {
  const config = getConfig();
  const { recordFilepath } = config;
  if (fs.existsSync(recordFilepath)) {
    res.success(getJSON(getFileContent(recordFilepath)));
    return;
  }
  res.fail(500, &#039;not set default recordFilepath&#039;);
});

app.get(&#039;/config&#039;, (req, res) =&gt; {
  const config = getConfig();
  res.success(config);
});</code></pre>
</div><p><strong>在什么时候启动这个服务？</strong></p>
<p>当然是和启动Web服务的时候一起启动</p>
<p>这就需要我们在<code>timec page</code>指令中添加启动后端服务的逻辑:</p>
<ol>
<li>同样使用<code>spawn</code>创建子进程启动后端服务</li>
<li>在客户端服务关闭的时候，杀死这个后端服务的子进程</li>
</ol>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::k8j1azhmh9owillh3j0dd::--><code>const server = spawn(&#039;node&#039;, [&#039;src/page/server.js&#039;], {
  cwd,
  stdio: &#039;inherit&#039;,
});
serveService.on(&#039;close&#039;, (code) =&gt; {
  server.kill(&#039;SIGSTOP&#039;);
  process.exit(code);
});</code></pre>
</div><p><strong>客户端如何访问这些接口？</strong>：</p>
<ol>
<li>为了降低项目复杂性，这里直接调用fetch方法获取后端接口的数据</li>
<li>单独建立一个文件<code>src/page/api.js</code>存放这些逻辑</li>
</ol>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::njrwz9nafjflwew7vamw1i::--><code>export function getConfig() {
  return fetch(&#039;http://localhost:3000/config&#039;);
}

export function getEveryDayData() {
  return fetch(&#039;http://localhost:3001/json&#039;).then((res) =&gt; res.json());
}</code></pre>
</div><p>由于Web会受同源策略限制，这里在<code>Fw</code>实例化函数里加入以下逻辑开启CORS，解决跨域问题</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::p3abgymioldg6yh73748lw::--><code>const app = new Fw((req, res) =&gt; {
  // 开启CORS
  const { method } = req;
  // 允许跨域
  res.setHeader(&#039;Access-Control-Allow-Origin&#039;, req.headers.origin);
  // 跨域允许的header类型
  res.setHeader(&#039;Access-Control-Allow-Headers&#039;, &#039;*&#039;);
  // 允许跨域携带cookie
  res.setHeader(&#039;Access-Control-Allow-Credentials&#039;, &#039;true&#039;);
  // 允许的方法
  res.setHeader(&#039;Access-Control-Allow-Methods&#039;, &#039;PUT, GET, POST, DELETE, OPTIONS&#039;);
  // 设置响应头
  res.setHeader(&#039;Content-Type&#039;, &#039;application/json;charset=utf-8&#039;);
  // 对预检请求放行
  if (method === &#039;OPTIONS&#039;) {
    res.statusCode = 204;
    res.end();
  }
});</code></pre>
</div><p>这样简单的前后端逻辑就都写好了,下面就是一键启动</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::inuxxibu6jm7a04bx3n3ra::--><code>timec page</code></pre>
</div><h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>由于每天空闲时间有限，本文就先到这，下一期将继续完善<code>timec page</code>指令</p>
<p>如果读者还感觉意犹未尽，敬请期待后续更新，或持续关注一下<a href="https://github.com/ATQQ/time-control" target="_blank" rel="noreferrer">仓库</a>的状态</p>
<p>欢迎评论区提需求，交流探讨</p>
<p>本系列会不断的更新迭代，直至产品初代完成</p>
<ul>
<li><a href="https://github.com/ATQQ/time-control" target="_blank" rel="noreferrer">仓库地址</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[做一个CL版的时间管理工具（12）]]></title>
            <link>https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/works/time-tools/time-tools-12.html</link>
            <guid isPermaLink="false">https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/preview/ripplejourney/ripplejourney.github.io/branch/renovate/master-minor-and-patch-deps/works/time-tools/time-tools-12.html</guid>
            <pubDate>Sun, 15 Aug 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[前言
初版的功能已经完成的差不多了，后续主要是优化一下体验和交互
本文将为插件接入`彩色打印`交互日志，加入启动web服务的指令（用于后续编写可视化的页面）
 本期效果预览

 功能开发
 彩色日志
]]></description>
            <content:encoded><![CDATA[<h1 id="做一个cli版的时间管理工具-12" tabindex="-1">做一个CLI版的时间管理工具（12） <a class="header-anchor" href="#做一个cli版的时间管理工具-12" aria-label="Permalink to “做一个CLI版的时间管理工具（12）”">&#8203;</a></h1>
<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">&#8203;</a></h2>
<p>初版的功能已经完成的差不多了，后续主要是优化一下体验和交互</p>
<p>本文将为插件接入<code>彩色打印</code>交互日志，加入启动web服务的指令（用于后续编写可视化的页面）</p>
<h2 id="本期效果预览" tabindex="-1">本期效果预览 <a class="header-anchor" href="#本期效果预览" aria-label="Permalink to “本期效果预览”">&#8203;</a></h2>
<blockquote>
<p>指令有些多，演示可能有些啰嗦</p>
</blockquote>
<p><img src="./time-tools-12/MTYyOTAzMzQyMjQ0OQ==timec12.gif?s1=https://img.cdn.sugarat.top/mdImg/MTYyOTAzMzQyMjQ0OQ==timec12.gif" alt="图片" loading="lazy"></p>
<h2 id="功能开发" tabindex="-1">功能开发 <a class="header-anchor" href="#功能开发" aria-label="Permalink to “功能开发”">&#8203;</a></h2>
<h3 id="彩色日志" tabindex="-1">彩色日志 <a class="header-anchor" href="#彩色日志" aria-label="Permalink to “彩色日志”">&#8203;</a></h3>
<p>这个是直接引入了<a href="https://github.com/chalk/chalk" target="_blank" rel="noreferrer">chalk</a>这个第三方库</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::r3lwrnta09jnht1eljnfi::--><code>yarn add chalk
# or
npm i chalk</code></pre>
</div><p>使用的时候非常简单，这里简单介绍一下，详细的可以直接去看<a href="https://github.com/chalk/chalk/blob/main/readme.md" target="_blank" rel="noreferrer">官方的示例</a></p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::d3e83fio969itkovk6lrnn::--><code>// 引入依赖
const chalk = require(&#039;chalk&#039;)

// 打印
console.log(chalk.yellow(&#039;hello&#039;),chalk.red(&#039;world&#039;))</code></pre>
</div><p><img src="./time-tools-12/MTYyOTAzMzYyNTg5NQ==629033625895.png" alt="图片" loading="lazy"></p>
<p>项目中进行简单的封装:</p>
<ul>
<li>项目中不直接使用 <code>console.log</code></li>
<li>对外暴露<code>print</code>方法代替<code>log</code></li>
<li>print方法额为添加三个默认的方法属性
<ul>
<li>success:绿色</li>
<li>fail:红色</li>
<li>advice:蓝色</li>
</ul>
</li>
</ul>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::i057vq589vqqg76qm24sm::--><code>const { log } = console;

function print(...str) {
  log(...str);
}

Object.assign(print, {
  success(...str) {
    log(chalk.green(&#039;success:&#039;), ...str);
  },
  fail(...str) {
    log(chalk.red(&#039;fail:&#039;), ...str);
  },
  advice(...str) {
    log(chalk.blue(&#039;advice:&#039;), ...str);
  },
});</code></pre>
</div><p>使用示例如下</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::53ys4naten505x2dex71q1j::--><code>const { print } = require(&#039;../src/utils&#039;);

print(&#039;default&#039;);
print.success(&#039;成功文案&#039;);
print.fail(&#039;失败提示&#039;);
print.advice(&#039;建议文案&#039;);</code></pre>
</div><p><img src="./time-tools-12/MTYyOTAzMzkyMDI0Mg==629033920242.png" alt="图片" loading="lazy"></p>
<p>利用封装的这三个方法，配合chalk的一些默认方法便完成了打印日志的改造</p>
<h3 id="启动web服务" tabindex="-1">启动Web服务 <a class="header-anchor" href="#启动web服务" aria-label="Permalink to “启动Web服务”">&#8203;</a></h3>
<p>这个功能的目的是通过一个指令，即可运行出一个Web页面</p>
<p>通过Web页面结合可视化库，更加详细生动的展示数据</p>
<p>添加一个新的指令<code>timec page</code>:</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::7tha28ew3el4ts9n5gjoll::--><code>commander.command(&#039;page&#039;)
  .description(&#039;Use Page show report&#039;)
  .action(() =&gt; {
      // ..code
  });</code></pre>
</div><p>这里准备用<a href="https://vitejs.dev/" target="_blank" rel="noreferrer">Vite</a>来启动这个本地服务</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::xfbuxnnig1cev5lzd9l57s::--><code>yarn add vite</code></pre>
</div><p>创建页面相关目录与文件</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::4nya128n65nn9xz8c3ushb::--><code>src
├── page
|  ├── index.html
|  └── main.js</code></pre>
</div><p>index.html内容如下，一个很简单的内容</p>
<ul>
<li>使用<code>&lt;script type=&quot;module&quot; src=&quot;js-url&quot;&gt;&lt;/script&gt;</code>引入js资源</li>
</ul>
<div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre><!--::markdown-it-async::k2x54dqtfat1jtag47hi::--><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;h1&gt;🚀hello world🚀&lt;/h1&gt;
    &lt;h2&gt;功能正在完善中&lt;/h2&gt;
    &lt;script type=&quot;module&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div><p>下面编写调用Vite启用服务的逻辑:</p>
<ul>
<li>引入Node自带的<a href="http://nodejs.cn/api/child_process.html" target="_blank" rel="noreferrer">child_process</a>模块</li>
<li>使用<code>child_process.spawn(command[, args][, options])</code>方法运行shell指令（启动一个子进程）
<ul>
<li>其中options中的cwd参数用于描述子进程的工作目录</li>
<li>第一个参数是要执行的指令</li>
<li>第二个参数是需要添加的参数</li>
</ul>
</li>
</ul>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::n6uppgjer6ezrx93yxk6g::--><code>const child_process = require(&#039;child_process&#039;);

const cwd = path.resolve(__dirname, &#039;../&#039;);
const serveService = child_process.spawn(&#039;node_modules/.bin/vite&#039;, [&#039;src/page&#039;, &#039;--host&#039;], {
  cwd,
  stdio: &#039;inherit&#039;,
});
serveService.on(&#039;close&#039;, (code) =&gt; {
  process.exit(code);
});</code></pre>
</div><p>安装<code>Vite</code>后就会在<code>node_modules/.bin/vite</code>下创建一个可执行文件，当然这个可执行文件里会有如下一行注释代码</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::6t1o9wcjj56yf9v4ltytxe::--><code>#!/usr/bin/env node</code></pre>
</div><p>接着就是指定<code>index.html</code>的目录，执行<code>./node_modules/.bin/vite --help</code>可看到如下提示信息</p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::wzbpkzref73tq9izmzt3i::--><code>Usage:
  $ vite [root]

Commands:
  [root]
  build [root]
  optimize [root]
  preview [root]
  ....</code></pre>
</div><p>咱们直接第一个参数指定文件所在目录即可，加上<code>--host</code> option后将会提供一个局域网的地址访问，像下面这样</p>
<p><img src="./time-tools-12/MTYyOTAzNjc5Nzg4OA==629036797888.png" alt="图片" loading="lazy"></p>
<p>同一局域网的其它设备也可通过这个地址访问这个页面的信息</p>
<h3 id="其它" tabindex="-1">其它 <a class="header-anchor" href="#其它" aria-label="Permalink to “其它”">&#8203;</a></h3>
<p>直接使用<code>child_process.spawn</code>在windows上会有<a href="https://github.com/moxystudio/node-cross-spawn" target="_blank" rel="noreferrer">一些兼容性问题</a></p>
<p>项目中使用<a href="https://github.com/moxystudio/node-cross-spawn" target="_blank" rel="noreferrer">cross-spawn</a>来替代直接使用<code>child_process.spwan</code></p>
<div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><!--::markdown-it-async::j7qmfh79e1lvnr5fpcews::--><code>yarn add cross-spawn</code></pre>
</div><p>更新上面的启动代码</p>
<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre><!--::markdown-it-async::4r2xiinyp8bsog0n570mfd::--><code>const spawn = require(&#039;cross-spawn&#039;);

commander.command(&#039;page&#039;)
  .description(&#039;Use Page show report&#039;)
  .action(() =&gt; {
    const cwd = path.resolve(__dirname, &#039;../&#039;);
    const serveService = spawn(&#039;node_modules/.bin/vite&#039;, [&#039;src/page&#039;, &#039;--host&#039;], {
      cwd,
      stdio: &#039;inherit&#039;,
    });
    serveService.on(&#039;close&#039;, (code) =&gt; {
      process.exit(code);
    });
  });</code></pre>
</div><h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">&#8203;</a></h2>
<p>由于每天空闲时间有限，本文就先到这，下一期将继续完善<code>timec page</code>指令</p>
<p>如果读者还感觉意犹未尽，敬请期待后续更新，或持续关注一下<a href="https://github.com/ATQQ/time-control" target="_blank" rel="noreferrer">仓库</a>的状态</p>
<p>欢迎评论区提需求，交流探讨</p>
<p>本系列会不断的更新迭代，直至产品初代完成</p>
<ul>
<li><a href="https://github.com/ATQQ/time-control" target="_blank" rel="noreferrer">仓库地址</a></li>
</ul>
]]></content:encoded>
            <enclosure url="https://www.dmsrs.org/preview/ripplejourney/ripplejourney.github.io/branch/renovate/time-tools-12/MTYyOTAzMzQyMjQ0OQ==timec12.gif?s1=https%3A//img.cdn.sugarat.top/mdImg/MTYyOTAzMzQyMjQ0OQ%3D%3Dtimec12.gif" length="0" type="image/gif"/>
        </item>
    </channel>
</rss>